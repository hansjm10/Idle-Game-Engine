"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[48],{3407:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"runtime-command-queue-design","title":"Runtime Command Queue Design Document","description":"Issue: #6","source":"@site/../../docs/runtime-command-queue-design.md","sourceDirName":".","slug":"/runtime-command-queue-design","permalink":"/Idle-Game-Engine/runtime-command-queue-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/runtime-command-queue-design.md","tags":[],"version":"current","frontMatter":{},"sidebar":"developerSidebar","previous":{"title":"Runtime Step Lifecycle Alignment","permalink":"/Idle-Game-Engine/runtime-step-lifecycle"},"next":{"title":"Runtime Command Queue Validation Plan","permalink":"/Idle-Game-Engine/runtime-command-queue-validation-plan"}}');var s=t(5270),i=t(7678);const a={},o="Runtime Command Queue Design Document",c={},d=[{value:"1. Overview",id:"1-overview",level:2},{value:"2. Goals",id:"2-goals",level:2},{value:"3. Non-Goals",id:"3-non-goals",level:2},{value:"3.1 State Graph Structure Requirements",id:"31-state-graph-structure-requirements",level:2},{value:"Supported State Structures",id:"supported-state-structures",level:3},{value:"Cloning Behavior",id:"cloning-behavior",level:3},{value:"Unsupported Types",id:"unsupported-types",level:3},{value:"State Design Guidelines",id:"state-design-guidelines",level:3},{value:"Freeze Behavior with Cycles",id:"freeze-behavior-with-cycles",level:3},{value:"Callback Safety for Snapshots",id:"callback-safety-for-snapshots",level:3},{value:"Performance Implications",id:"performance-implications",level:3},{value:"4. Architecture",id:"4-architecture",level:2},{value:"4.1 Command Interface",id:"41-command-interface",level:3},{value:"4.2 Command Queue Structure",id:"42-command-queue-structure",level:3},{value:"4.3 Step Field Population",id:"43-step-field-population",level:3},{value:"Step Stamping Locations",id:"step-stamping-locations",level:4},{value:"Step Lifecycle Summary",id:"step-lifecycle-summary",level:4},{value:"Replay Behavior",id:"replay-behavior",level:4},{value:"4.4 Command Execution Flow",id:"44-command-execution-flow",level:3},{value:"4.3.1 System-Queue Interaction Model",id:"431-system-queue-interaction-model",level:3},{value:"4.5 Command Dispatcher",id:"45-command-dispatcher",level:3},{value:"4.6 ResourceState Integration",id:"46-resourcestate-integration",level:3},{value:"5. Command Types (Initial Set)",id:"5-command-types-initial-set",level:2},{value:"5.1 Resource Commands",id:"51-resource-commands",level:3},{value:"5.2 Prestige Commands",id:"52-prestige-commands",level:3},{value:"5.3 System Commands",id:"53-system-commands",level:3},{value:"6. Priority Resolution",id:"6-priority-resolution",level:2},{value:"Example Scenario",id:"example-scenario",level:3},{value:"7. Integration with Presentation Layer",id:"7-integration-with-presentation-layer",level:2},{value:"7.1 Worker Bridge API",id:"71-worker-bridge-api",level:3},{value:"7.2 Runtime Command Reception",id:"72-runtime-command-reception",level:3},{value:"7.2.1 Purchase Evaluator Pattern (Existing Implementation)",id:"721-purchase-evaluator-pattern-existing-implementation",level:4},{value:"7.3 Usage in React Components",id:"73-usage-in-react-components",level:3},{value:"7.4 Automation System Integration",id:"74-automation-system-integration",level:3},{value:"8. Command Recording &amp; Replay",id:"8-command-recording--replay",level:2},{value:"8.1 Recorder Snapshot Lifecycle",id:"81-recorder-snapshot-lifecycle",level:3},{value:"Supporting Utilities",id:"supporting-utilities",level:4},{value:"8.3 Deterministic Replay Guarantees",id:"83-deterministic-replay-guarantees",level:3},{value:"1. Step Counter Preservation",id:"1-step-counter-preservation",level:4},{value:"2. Recording Loop Prevention",id:"2-recording-loop-prevention",level:4},{value:"3. RNG Seed Restoration",id:"3-rng-seed-restoration",level:4},{value:"8.4 Freeze/Clone/Restore Lifecycle",id:"84-freezeclonerestore-lifecycle",level:3},{value:"Lifecycle Stages",id:"lifecycle-stages",level:4},{value:"Why This Works",id:"why-this-works",level:4},{value:"9. Performance Considerations",id:"9-performance-considerations",level:2},{value:"9.1 Queue Capacity Limits",id:"91-queue-capacity-limits",level:3},{value:"9.2 Batch Processing Optimization",id:"92-batch-processing-optimization",level:3},{value:"9.3 Memory Footprint",id:"93-memory-footprint",level:3},{value:"10. Error Handling",id:"10-error-handling",level:2},{value:"10.1 Invalid Command Rejection",id:"101-invalid-command-rejection",level:3},{value:"10.2 Validation Before Enqueue",id:"102-validation-before-enqueue",level:3},{value:"11. Testing Strategy",id:"11-testing-strategy",level:2},{value:"11.1 Unit Tests",id:"111-unit-tests",level:3},{value:"11.2 Integration Tests",id:"112-integration-tests",level:3},{value:"11.3 Replay Tests",id:"113-replay-tests",level:3},{value:"12. Implementation Plan",id:"12-implementation-plan",level:2},{value:"12.1 Week 1 Tasks",id:"121-week-1-tasks",level:3},{value:"12.2 Week 2 Tasks",id:"122-week-2-tasks",level:3},{value:"12.3 Week 3 Tasks",id:"123-week-3-tasks",level:3},{value:"13. Success Criteria",id:"13-success-criteria",level:2},{value:"14. Future Enhancements (Post-Prototype)",id:"14-future-enhancements-post-prototype",level:2},{value:"15. Resolved Decisions",id:"15-resolved-decisions",level:2},{value:"16. References",id:"16-references",level:2},{value:"Appendix A \u2013 2025-10-11 Update Summary",id:"appendix-a--2025-10-11-update-summary",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"runtime-command-queue-design-document",children:"Runtime Command Queue Design Document"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Issue:"})," #6\n",(0,s.jsx)(n.strong,{children:"Workstream:"})," Runtime Core\n",(0,s.jsx)(n.strong,{children:"Status:"})," Design\n",(0,s.jsx)(n.strong,{children:"Last Updated:"})," 2025-10-11"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Execution Order:"})," Tackle the subissues derived from this document sequentially. Each one must be completed and reviewed before starting the next to keep the workstream focused and in sync."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"1-overview",children:"1. Overview"}),"\n",(0,s.jsx)(n.p,{children:"The command queue is a core runtime component that enables deterministic, replayable game state mutations. It decouples user input, automation systems, and server-confirmed actions from immediate execution, allowing the runtime to process all state changes within the fixed-step tick loop described in the engine design."}),"\n",(0,s.jsx)(n.h2,{id:"2-goals",children:"2. Goals"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Determinism"}),": All state mutations occur through commands executed within tick steps, ensuring reproducible simulation for offline catch-up and debugging"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Priority Control"}),": Support multiple command sources (player, automation, system) with configurable priority tiers to resolve execution order conflicts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serialization"}),": Enable command recording/replay for debugging, testing, and potential multiplayer synchronization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Minimal overhead for command enqueueing and processing within the 100ms tick budget"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),": Strongly-typed command payloads that prevent invalid mutations at compile time"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-non-goals",children:"3. Non-Goals"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Network synchronization protocols (handled by separate social system layer)"}),"\n",(0,s.jsx)(n.li,{children:"Complex undo/redo UI flows (out of scope for prototype milestone)"}),"\n",(0,s.jsx)(n.li,{children:"Cross-tick command scheduling (time-based tasks use dedicated Task Scheduler system)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"31-state-graph-structure-requirements",children:"3.1 State Graph Structure Requirements"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Decision"}),": The runtime supports ",(0,s.jsx)(n.strong,{children:"cyclic state graphs"})," with ",(0,s.jsx)(n.strong,{children:"structured-cloneable types"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"supported-state-structures",children:"Supported State Structures"}),"\n",(0,s.jsx)(n.p,{children:"The runtime state graph can contain:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cyclic References"}),": Parent-child relationships and entity cross-references are fully supported"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface Entity {\n  id: string;\n  parent?: Entity; // Cycle: child \u2192 parent \u2192 child\n  children: Entity[];\n  dependencies: Set<Entity>; // Cross-references\n}\n\nconst parent: Entity = { id: 'p', children: [] };\nconst child: Entity = { id: 'c', parent, children: [] };\nparent.children.push(child); // Cycle created\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Collection Types"}),": Map, Set, and native collections are first-class citizens"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface GameState {\n  entities: Map<string, Entity>; // Entity registry\n  activeIds: Set<string>; // Active entity tracking\n  resourceGraph: Map<string, Set<string>>; // Adjacency list\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complex Nested Structures"}),": Arbitrary nesting depth is supported"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface GameState {\n  resources: {\n    byType: Map<string, {\n      instances: Map<string, Resource>;\n      producers: Set<Entity>;\n    }>;\n  };\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"cloning-behavior",children:"Cloning Behavior"}),"\n",(0,s.jsxs)(n.p,{children:["The recorder uses ",(0,s.jsx)(n.code,{children:"structuredClone()"})," which provides:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cycle Preservation"}),": Circular references are cloned correctly"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const original = { self: null };\noriginal.self = original; // Cycle\n\nconst clone = structuredClone(original);\nclone.self === clone; // true (cycle preserved)\nclone !== original; // true (different object)\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Collection Cloning"}),": Map and Set are deeply cloned"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const state = {\n  entities: new Map([['e1', { id: 'e1', value: 10 }]])\n};\n\nconst clone = structuredClone(state);\nclone.entities.get('e1').value = 20;\nstate.entities.get('e1').value; // Still 10 (deep clone)\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type Preservation"}),": Objects maintain their identity"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const state = {\n  timestamp: new Date(),\n  config: new Map([['key', 'value']]),\n  buffer: new Uint8Array([1, 2, 3])\n};\n\nconst clone = structuredClone(state);\nclone.timestamp instanceof Date; // true\nclone.config instanceof Map; // true\nclone.buffer instanceof Uint8Array; // true\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"unsupported-types",children:"Unsupported Types"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"structuredClone()"})," and ",(0,s.jsx)(n.code,{children:"deepFreeze()"})," ",(0,s.jsx)(n.strong,{children:"cannot handle"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Functions"}),": Behavior is lost during cloning"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2717 INVALID state structure\ninterface BadState {\n  calculate: () => number; // Function cannot be cloned\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Class Instances with Methods"}),": Only data properties are preserved"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class Generator {\n  constructor(public id: string) {}\n  produce() { return 10; } // Method lost during clone\n}\n\n// \u2717 INVALID: Class instances with methods\nconst state = { gen: new Generator('g1') };\nconst clone = structuredClone(state);\nclone.gen.produce; // undefined (method lost)\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"DOM Nodes and Browser APIs"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2717 INVALID state structure\ninterface BadState {\n  element: HTMLElement; // Cannot be cloned\n  worker: Worker; // Cannot be cloned\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"WeakMap/WeakSet"}),": Not cloneable"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2717 INVALID state structure\ninterface BadState {\n  cache: WeakMap<object, any>; // Cannot be cloned\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Symbols as Keys"}),": Symbol-keyed properties are not cloned"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const sym = Symbol('key');\nconst state = { [sym]: 'value' }; // Symbol key\n\nconst clone = structuredClone(state);\nclone[sym]; // undefined (symbol properties not cloned)\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"state-design-guidelines",children:"State Design Guidelines"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"\u2713 Recommended Pattern"}),": Plain data with Maps/Sets/Arrays"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface GameState {\n  // Resources indexed by ID\n  resources: Map<string, {\n    id: string;\n    amount: number;\n    rate: number;\n  }>;\n\n  // Entity graph with cycles\n  entities: Map<string, {\n    id: string;\n    parent?: string; // Reference by ID, not object (alternative)\n    children: string[];\n  }>;\n\n  // Or direct object references (cycles preserved)\n  entityGraph: Map<string, {\n    id: string;\n    parent?: EntityNode; // Cycle: child \u2192 parent \u2192 child (works!)\n    children: EntityNode[];\n  }>;\n\n  // Temporal data\n  timeline: {\n    started: Date;\n    events: Array<{ at: Date; type: string }>;\n  };\n\n  // Metadata\n  version: string;\n  seed: number; // RNG seed for determinism\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"\u2717 Anti-Pattern"}),": Functions, classes, browser APIs"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// DON'T DO THIS\ninterface BadGameState {\n  // Functions\n  calculateProduction: () => number; // Lost during clone\n\n  // Class instances with methods\n  factory: new ProductionFactory(); // Methods lost\n\n  // Browser APIs\n  canvas: HTMLCanvasElement; // Cannot clone\n  cache: WeakMap<Entity, ComputedStats>; // Cannot clone\n\n  // Symbol keys\n  [Symbol.for('internal')]: any; // Not cloned\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"freeze-behavior-with-cycles",children:"Freeze Behavior with Cycles"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"deepFreeze()"})," implementation handles cycles via ",(0,s.jsx)(n.code,{children:"WeakSet"})," tracking:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Cyclic state is safe\nconst parent = { id: 'p', children: [] };\nconst child = { id: 'c', parent };\nparent.children.push(child);\n\ndeepFreeze(parent);\n// \u2713 Successfully frozen (WeakSet prevents infinite recursion)\n\nparent.id = 'new'; // Throws: Cannot assign to read only property\nchild.parent.id = 'new'; // Throws: Same object is frozen\n"})}),"\n",(0,s.jsx)(n.h3,{id:"callback-safety-for-snapshots",children:"Callback Safety for Snapshots"}),"\n",(0,s.jsxs)(n.p,{children:["Iteration helpers such as ",(0,s.jsx)(n.code,{children:"Map.prototype.forEach"}),", ",(0,s.jsx)(n.code,{children:"Set.prototype.forEach"}),", and typed-array traversal methods (",(0,s.jsx)(n.code,{children:"forEach"}),", ",(0,s.jsx)(n.code,{children:"map"}),", ",(0,s.jsx)(n.code,{children:"reduce"}),", etc.) are wrapped so that the container reference exposed to callbacks is always the immutable proxy. Attempted mutation through the callback-provided collection triggers the same runtime ",(0,s.jsx)(n.code,{children:"TypeError"})," as direct mutation. This prevents accidental leaks where consumers capture the callback argument and call mutating APIs (",(0,s.jsx)(n.code,{children:"set"}),", ",(0,s.jsx)(n.code,{children:"add"}),", ",(0,s.jsx)(n.code,{children:"set()"})," on typed arrays) on the underlying mutable structure."]}),"\n",(0,s.jsxs)(n.p,{children:["Helpers that synthesize new typed-array instances (",(0,s.jsx)(n.code,{children:"map"}),", ",(0,s.jsx)(n.code,{children:"filter"}),", ",(0,s.jsx)(n.code,{children:"subarray"}),", etc.) also route their return values back through the snapshot factory before handing them to the caller. The clone that is produced is immediately wrapped in the same mutation guards, so even if a consumer chains traversal helpers (",(0,s.jsx)(n.code,{children:"snapshot.typed.map(...).filter(...)"}),") the intermediate results continue to enforce immutability."]}),"\n",(0,s.jsx)(n.h3,{id:"performance-implications",children:"Performance Implications"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Clone Cost"}),": ",(0,s.jsx)(n.code,{children:"structuredClone()"})," has O(n) cost where n = object graph size"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Typical game state (10k entities): ~5-10ms clone time"}),"\n",(0,s.jsx)(n.li,{children:"Large state (100k entities): ~50-100ms clone time"}),"\n",(0,s.jsx)(n.li,{children:"Mitigation: Only clone at recording start, not per command"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Freeze Cost"}),": ",(0,s.jsx)(n.code,{children:"deepFreeze()"})," traverses entire graph once"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Same complexity as clone: O(n)"}),"\n",(0,s.jsxs)(n.li,{children:["Only called during ",(0,s.jsx)(n.code,{children:"export()"}),", not on hot path"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Memory"}),": Snapshot holds complete state copy"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Budget: ~5 MB for moderate game state (from design doc)"}),"\n",(0,s.jsx)(n.li,{children:"Monitor via telemetry if state grows beyond budget"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"4-architecture",children:"4. Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"41-command-interface",children:"4.1 Command Interface"}),"\n",(0,s.jsx)(n.p,{children:"Commands follow the classic Command pattern with typed payloads:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export interface Command<TPayload = unknown> {\n  readonly type: string;\n  readonly priority: CommandPriority;\n  readonly payload: TPayload;\n  readonly timestamp: number; // For ordering within same priority\n  readonly step: number; // Simulation tick that will execute the command\n}\n\ntype ImmutablePrimitive =\n  | string\n  | number\n  | bigint\n  | boolean\n  | symbol\n  | null\n  | undefined;\n\ntype ImmutableFunction = (...args: unknown[]) => unknown;\n\ntype ImmutableArrayLike<T> = readonly ImmutablePayload<T>[];\n\nexport type ImmutablePayload<T> = T extends ImmutablePrimitive\n  ? T\n  : T extends ImmutableFunction\n    ? T\n    : T extends ArrayBuffer\n      ? ImmutableArrayBufferSnapshot\n      : T extends SharedArrayBuffer\n        ? ImmutableSharedArrayBufferSnapshot\n        : T extends Map<infer K, infer V>\n          ? ReadonlyMap<ImmutablePayload<K>, ImmutablePayload<V>>\n          : T extends Set<infer V>\n            ? ReadonlySet<ImmutablePayload<V>>\n            : T extends Array<infer U>\n              ? ImmutableArrayLike<U>\n              : T extends ReadonlyArray<infer U>\n                ? ImmutableArrayLike<U>\n                : T extends object\n                  ? { readonly [K in keyof T]: ImmutablePayload<T[K]> }\n                  : T;\n\nexport type CommandSnapshot<TPayload = unknown> = ImmutablePayload<\n  Command<TPayload>\n>;\n\nexport type CommandSnapshotPayload<TPayload> = ImmutablePayload<TPayload>;\n\nexport enum CommandPriority {\n  SYSTEM = 0,    // Engine-generated (migrations, prestige resets)\n  PLAYER = 1,    // Direct user input (purchase, toggle)\n  AUTOMATION = 2 // Automated systems (auto-buy, auto-prestige)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"42-command-queue-structure",children:"4.2 Command Queue Structure"}),"\n",(0,s.jsx)(n.p,{children:"The queue maintains separate lanes per priority with FIFO ordering within each lane:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface CommandQueueEntry<TCommand extends Command = Command> {\n  readonly command: TCommand;\n  readonly sequence: number; // Tie-breaker when timestamps match\n}\n\nexport class CommandQueue {\n  private readonly queues: Map<\n    CommandPriority,\n    CommandQueueEntry<CommandSnapshot>[]\n  > = new Map([\n    [CommandPriority.SYSTEM, []],\n    [CommandPriority.PLAYER, []],\n    [CommandPriority.AUTOMATION, []]\n  ]);\n  private static readonly PRIORITY_ORDER: CommandPriority[] = [\n    CommandPriority.SYSTEM,\n    CommandPriority.PLAYER,\n    CommandPriority.AUTOMATION\n  ];\n\n  private nextSequence = 0;\n  private totalSize = 0;\n\n  /**\n   * Enqueue a command for execution in the next tick.\n   * The step field must already contain the simulation tick that will execute it.\n   */\n  enqueue(command: Command): void {\n    const queue = this.queues.get(command.priority);\n    if (!queue) {\n      throw new Error(`Invalid priority: ${command.priority}`);\n    }\n\n    // Snapshot the command so later mutations (object pooling, payload reuse)\n    // cannot alter what eventually executes.\n    const storedCommand = cloneCommand(command);\n\n    const entry: CommandQueueEntry<CommandSnapshot> = {\n      command: storedCommand,\n      sequence: this.nextSequence++\n    };\n\n    // Deterministic insertion by timestamp, then sequence for ties.\n    let lo = 0;\n    let hi = queue.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      const other = queue[mid];\n      if (\n        other.command.timestamp < entry.command.timestamp ||\n        (other.command.timestamp === entry.command.timestamp &&\n          other.sequence < entry.sequence)\n      ) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    queue.splice(lo, 0, entry);\n    this.totalSize++;\n  }\n\n  dequeueAll(): CommandSnapshot[] {\n    const result: CommandSnapshot[] = [];\n    for (const priority of CommandQueue.PRIORITY_ORDER) {\n      const queue = this.queues.get(priority);\n      if (queue && queue.length > 0) {\n        const laneLength = queue.length;\n        for (const entry of queue) {\n          result.push(entry.command);\n        }\n        queue.length = 0; // Clear the lane after draining\n        this.totalSize -= laneLength;\n      }\n    }\n    return result;\n  }\n\n  clear(): void {\n    for (const queue of this.queues.values()) {\n      this.totalSize -= queue.length;\n      queue.length = 0;\n    }\n    this.totalSize = 0;\n  }\n\n  get size(): number {\n    return this.totalSize;\n  }\n}\n\nfunction cloneCommand(command: Command): CommandSnapshot {\n  const snapshot = structuredClone(command);\n  return deepFreezeInPlace(snapshot);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Pre-seeding the per-priority lanes and iterating with ",(0,s.jsx)(n.code,{children:"PRIORITY_ORDER"})," keeps dequeue operations deterministic, while the binary-search insertion guarantees FIFO behavior within a lane based on ",(0,s.jsx)(n.code,{children:"timestamp"})," with a monotonic sequence fallback for ties. Cloning each command on enqueue ensures callers cannot mutate queued payloads after submission, preserving determinism for both live execution and recorded logs. This, combined with the sequence counter, prevents cross-thread enqueue races from reordering commands that share the same priority."]}),"\n",(0,s.jsxs)(n.p,{children:["Snapshots surfaced by ",(0,s.jsx)(n.code,{children:"dequeueAll()"})," expose payloads through ",(0,s.jsx)(n.code,{children:"CommandSnapshotPayload<T>"}),"; when a payload contains ",(0,s.jsx)(n.code,{children:"ArrayBuffer"})," or ",(0,s.jsx)(n.code,{children:"SharedArrayBuffer"})," instances the accessor yields immutable facades. Call sites must request writable copies with helpers like ",(0,s.jsx)(n.code,{children:"toArrayBuffer()"})," or ",(0,s.jsx)(n.code,{children:"toSharedArrayBuffer()"})," before mutating the data, ensuring replay logs never leak live runtime buffers."]}),"\n",(0,s.jsx)(n.h3,{id:"43-step-field-population",children:"4.3 Step Field Population"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Critical Design Pattern"}),": The ",(0,s.jsx)(n.code,{children:"step"})," field stores the ",(0,s.jsx)(n.strong,{children:"simulation tick that will execute the command"}),". The queuing site is responsible for stamping the step as the command crosses into the queue so that handlers receive the correct execution context during live play and replay."]}),"\n",(0,s.jsx)(n.h4,{id:"step-stamping-locations",children:"Step Stamping Locations"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. UI Commands (from Main Thread)"})}),"\n",(0,s.jsxs)(n.p,{children:["Commands sent from the presentation layer do ",(0,s.jsx)(n.strong,{children:"not"})," include the step field. The Worker runtime stamps it using the next execution step before adding the command to the queue:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Main thread - WorkerBridgeImpl.sendCommand()\nsendCommand<T>(type: string, payload: T): void {\n  this.worker.postMessage({\n    type: 'COMMAND',\n    command: {\n      type,\n      payload,\n      timestamp: performance.now()\n      // NO step field - will be stamped by Worker\n    }\n  });\n}\n\nlet currentStep = 0;\nlet nextExecutableStep = 0; // updated inside the tick loop\n\n// Worker runtime - onmessage handler\nself.onmessage = (event) => {\n  if (event.data.type === 'COMMAND') {\n    commandQueue.enqueue({\n      ...event.data.command,\n      priority: CommandPriority.PLAYER,\n      timestamp: performance.now(), // Overwrite caller-supplied timestamp\n      step: nextExecutableStep // <-- Stamp with the tick that will execute the command\n    });\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Stamping Window"}),": ",(0,s.jsx)(n.code,{children:"nextExecutableStep"})," is set to the current tick immediately\nbefore the runtime captures the batch (",(0,s.jsx)(n.code,{children:"dequeueAll()"}),"), then advanced to\n",(0,s.jsx)(n.code,{children:"currentStep + 1"})," as soon as the batch is secured. Commands that arrive after\nthe batch capture\u2014including those enqueued from within handlers\u2014are therefore\nstamped for the following tick, so ",(0,s.jsx)(n.code,{children:"command.step"})," always matches the tick that\nactually executes them."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why Worker Stamps It"}),": The main thread doesn't have access to ",(0,s.jsx)(n.code,{children:"currentStep"})," (it lives in the Worker). Only the Worker runtime knows the current tick number, so stamping happens at enqueue time in the Worker's message handler."]}),"\n",(0,s.jsxs)(n.p,{children:["The handler ",(0,s.jsx)(n.em,{children:"also"})," replaces any caller-provided timestamp with the Worker's ",(0,s.jsx)(n.code,{children:"performance.now()"})," reading so hostile callers cannot backdate commands to reorder the queue."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. System-Generated Commands (inside Worker)"})}),"\n",(0,s.jsxs)(n.p,{children:["Systems running inside the Worker have access to ",(0,s.jsx)(n.code,{children:"context.step"})," (the tick that is currently executing ",(0,s.jsx)(n.strong,{children:"now"}),"). Because their commands run on the ",(0,s.jsx)(n.strong,{children:"next"})," tick, they must stamp ",(0,s.jsx)(n.code,{children:"context.step + 1"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class ProductionSystem implements System {\n  tick(state: ReadonlyGameState, context: TickContext): void {\n    const production = calculateProduction(state, context.deltaMs);\n\n    commandQueue.enqueue({\n      type: 'APPLY_PRODUCTION',\n      priority: CommandPriority.SYSTEM,\n      payload: { resources: production },\n      timestamp: performance.now(),\n      step: context.step + 1 // <-- Executed next tick, so stamp with step+1\n    });\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why Systems Stamp It"}),": ",(0,s.jsx)(n.code,{children:"context.step"})," reflects the tick that is executing right now. Because queued commands run at the start of the ",(0,s.jsx)(n.em,{children:"next"})," tick, the system stamps ",(0,s.jsx)(n.code,{children:"context.step + 1"})," so handlers observe the correct execution tick regardless of whether they are running live or under replay."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Engine Commands (inside Worker)"})}),"\n",(0,s.jsxs)(n.p,{children:["Engine-level code (migrations, resets, etc.) must stamp commands with the tick they will execute on. When invoked during tick ",(0,s.jsx)(n.code,{children:"currentStep"}),", the command will execute on ",(0,s.jsx)(n.code,{children:"currentStep + 1"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Option A: Accept currentStep parameter\nfunction executePrestigeReset(currentStep: number, layer: number) {\n  commandQueue.enqueue({\n    type: 'PRESTIGE_RESET',\n    priority: CommandPriority.SYSTEM,\n    payload: { layer },\n    timestamp: performance.now(),\n    step: currentStep + 1 // <-- Executed next tick\n  });\n}\n\n// Option B: Access global currentStep (inside Worker)\nfunction executeMigration() {\n  commandQueue.enqueue({\n    type: 'APPLY_MIGRATION',\n    priority: CommandPriority.SYSTEM,\n    payload: { fromVersion: '1.0', toVersion: '1.1' },\n    timestamp: performance.now(),\n    step: currentStep + 1 // <-- Executed next tick\n  });\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-lifecycle-summary",children:"Step Lifecycle Summary"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Tick N                                                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1. currentStep = N                                          \u2502\n\u2502 2. Capture commands for step N (dequeueAll)                \u2502\n\u2502    - Immediately set nextExecutableStep = N+1              \u2502\n\u2502 3. Execute queued commands (all have step = N)             \u2502\n\u2502    - Handlers see ctx.step = cmd.step = N                  \u2502\n\u2502    - Follow-on enqueues are stamped with step = N+1        \u2502\n\u2502 4. Systems tick() with context.step = N                    \u2502\n\u2502    - Each system enqueues commands stamped with step = N+1 \u2502\n\u2502 5. currentStep++ (becomes N+1)                             \u2502\n\u2502    - nextExecutableStep \u2190 currentStep (now N+1)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Tick N+1                                                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1. currentStep = N+1                                        \u2502\n\u2502 2. Capture commands for step N+1 (dequeueAll)              \u2502\n\u2502    - Immediately set nextExecutableStep = N+2              \u2502\n\u2502 3. Execute queued commands (all have step = N+1)           \u2502\n\u2502    - Includes UI commands posted after tick N              \u2502\n\u2502 4. Systems tick() with context.step = N+1                  \u2502\n\u2502    - Enqueue commands stamped with step = N+2              \u2502\n\u2502 5. currentStep++ (becomes N+2)                             \u2502\n\u2502    - nextExecutableStep \u2190 currentStep (now N+2)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Insight"}),": ",(0,s.jsx)(n.code,{children:"command.step"})," always matches the simulation tick that will execute the command. Systems add ",(0,s.jsx)(n.code,{children:"+1"})," because their work executes on the next tick, while the Worker stamps external commands with ",(0,s.jsx)(n.code,{children:"nextExecutableStep"})," (which is ready to run on the upcoming tick). This keeps live execution and replay perfectly aligned."]}),"\n",(0,s.jsx)(n.h4,{id:"replay-behavior",children:"Replay Behavior"}),"\n",(0,s.jsxs)(n.p,{children:["During replay, ",(0,s.jsx)(n.code,{children:"CommandRecorder.replay()"})," uses ",(0,s.jsx)(n.code,{children:"cmd.step"})," directly to build execution context:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"for (const cmd of log.commands) {\n  const handler = dispatcher.getHandler(cmd.type);\n  if (handler) {\n    handler(cmd.payload, {\n      step: cmd.step, // Use STORED step, not incrementing counter\n      timestamp: cmd.timestamp,\n      priority: cmd.priority\n    });\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This ensures every command sees the same ",(0,s.jsx)(n.code,{children:"ctx.step"})," value during live execution and replay for the tick in which it actually mutates state."]}),"\n",(0,s.jsx)(n.h3,{id:"44-command-execution-flow",children:"4.4 Command Execution Flow"}),"\n",(0,s.jsx)(n.p,{children:"Commands are processed at the start of each tick step, before system execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"let currentStep = 0;        // Tick currently executing\nlet nextExecutableStep = 0; // Step used to stamp externally-enqueued commands\n\nfunction runTick(deltaMs: number) {\n  accumulator += deltaMs;\n  const steps = clamp(floor(accumulator / FIXED_STEP_MS), 0, MAX_STEPS_PER_FRAME);\n  accumulator -= steps * FIXED_STEP_MS;\n\n  for (let i = 0; i < steps; i++) {\n    // Accept commands for the current step until we capture the batch\n    nextExecutableStep = currentStep;\n    const commands = commandQueue.dequeueAll();\n\n    // Once the batch is captured, advance stamping to the next step.\n    // Any commands enqueued by handlers or telemetry during execution\n    // will now target the step that actually runs them.\n    nextExecutableStep = currentStep + 1;\n\n    for (const cmd of commands) {\n      if (cmd.step !== currentStep) {\n        telemetry.recordError('CommandStepMismatch', {\n          expectedStep: currentStep,\n          commandStep: cmd.step,\n          type: cmd.type\n        });\n        continue; // Skip mis-stamped command to preserve determinism\n      }\n\n      commandDispatcher.execute(cmd); // Apply state mutations using cmd.step\n    }\n\n    const systemContext: TickContext = {\n      step: currentStep,\n      deltaMs: FIXED_STEP_MS\n    };\n\n    const stateView =\n      process.env.NODE_ENV === 'development'\n        ? createReadOnlyProxy(gameState)\n        : gameState;\n\n    automationSystem.tick(stateView, systemContext);\n    productionSystem.tick(stateView, systemContext);\n    progressionSystem.tick(stateView, systemContext);\n    eventSystem.tick(stateView, systemContext);\n    telemetry.recordTick();\n\n    currentStep++;                    // Move to the next simulation step\n    nextExecutableStep = currentStep; // Commands arriving before the next dequeue target the new step\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The two-phase ",(0,s.jsx)(n.code,{children:"nextExecutableStep"})," update is deliberate: we briefly set it to\n",(0,s.jsx)(n.code,{children:"currentStep"})," so any commands that slipped in before the batch capture keep\ntheir intended execution tick, then immediately advance it to ",(0,s.jsx)(n.code,{children:"currentStep + 1"}),"\nbefore handlers run. Commands that enqueue additional work during execution are\ntherefore stamped for the following tick, guaranteeing their ",(0,s.jsx)(n.code,{children:"cmd.step"})," matches\nthe tick that will actually execute them."]}),"\n",(0,s.jsxs)(n.p,{children:["The runtime validates this invariant explicitly. A command whose ",(0,s.jsx)(n.code,{children:"step"})," does not\nmatch the tick that is currently executing is treated as a logic error: the\ndispatcher skips it and emits a ",(0,s.jsx)(n.code,{children:"CommandStepMismatch"})," telemetry record. This\nprotects replay determinism by preventing a mis-stamped command from mutating\nstate on the wrong tick during live execution or replay."]}),"\n",(0,s.jsxs)(n.p,{children:["Before systems run, the runtime constructs a shared ",(0,s.jsx)(n.code,{children:"TickContext"})," object and\npasses it to every system. At minimum the context includes the ",(0,s.jsx)(n.code,{children:"step"})," that just\nexecuted and the fixed ",(0,s.jsx)(n.code,{children:"deltaMs"}),", so systems have the information they need to\nstamp follow-up commands with ",(0,s.jsx)(n.code,{children:"context.step + 1"})," and to perform time-based\ncalculations deterministically."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface TickContext {\n  readonly step: number;    // Tick that just executed\n  readonly deltaMs: number; // Fixed step duration in milliseconds\n}\n\ntype ReadonlyGameState = DeepReadonly<GameState>; // Utility type from shared runtime typings\n\ninterface System {\n  tick(state: ReadonlyGameState, context: TickContext): void;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Each system receives a read-only view of ",(0,s.jsx)(n.code,{children:"gameState"})," alongside the tick metadata. In development builds ",(0,s.jsx)(n.code,{children:"state"})," is a proxy that throws on mutation; in production it is the live object reference. Systems must treat the argument as immutable in both cases."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Critical Constraint"}),": Systems MUST NOT mutate state directly during ",(0,s.jsx)(n.code,{children:"tick()"}),". Instead, they analyze current state and enqueue commands that will be executed in the ",(0,s.jsx)(n.strong,{children:"next"})," tick step. This ensures:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["All mutations flow through the command queue and are captured by ",(0,s.jsx)(n.code,{children:"CommandRecorder"})]}),"\n",(0,s.jsx)(n.li,{children:"System logic remains pure and testable (reads state, outputs commands)"}),"\n",(0,s.jsx)(n.li,{children:"Replaying a command log reproduces identical state without re-running systems"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example of correct system implementation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class AutomationSystem implements System {\n  tick(state: ReadonlyGameState, context: TickContext): void {\n    // \u2713 CORRECT: Read state, enqueue commands for next tick\n    const affordable = findAffordableUpgrades(state);\n    for (const upgrade of affordable) {\n      commandQueue.enqueue({\n        type: 'PURCHASE_UPGRADE',\n        priority: CommandPriority.AUTOMATION,\n        payload: { upgradeId: upgrade.id },\n        timestamp: performance.now(),\n        step: context.step + 1 // Stamp with the tick that will execute the command\n      });\n    }\n  }\n}\n\nclass ProductionSystem implements System {\n  tick(state: ReadonlyGameState, context: TickContext): void {\n    // \u2717 WRONG: Direct state mutation bypasses command queue\n    // resourceState.addAmount(\n    //   resourceState.requireIndex('energy'),\n    //   productionRate,\n    // );\n\n    // \u2713 CORRECT: Enqueue production command\n    commandQueue.enqueue({\n      type: 'APPLY_PRODUCTION',\n      priority: CommandPriority.SYSTEM,\n      payload: {\n        resources: calculateProduction(state, context.deltaMs)\n      },\n      timestamp: performance.now(),\n      step: context.step + 1 // Stamp with the tick that will execute the command\n    });\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Enforcement"}),": The runtime provides read-only state proxies to systems. Direct mutation of the top-level state surface throws an error in development mode. Nested objects returned from ",(0,s.jsx)(n.code,{children:"Map"}),"/",(0,s.jsx)(n.code,{children:"Set"})," accessors are ",(0,s.jsx)(n.strong,{children:"not yet wrapped"}),"; until that work lands, the example below should be interpreted as guarding only the first layer of state. A follow-up task will extend the proxy to decorate collection accessors so values are also read-only."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const proxyCache = new WeakMap<object, any>();\n\nfunction createReadOnlyProxy<T extends object>(target: T, path = 'state'): T {\n  if (!target || typeof target !== 'object') {\n    return target;\n  }\n\n  const cached = proxyCache.get(target);\n  if (cached) {\n    return cached;\n  }\n\n  const proxy = new Proxy(target, {\n    get(obj, prop) {\n      const value = (obj as any)[prop];\n\n      // Special handling for Map/Set methods - bind them to the target\n      if (typeof value === 'function' && (obj instanceof Map || obj instanceof Set)) {\n        return value.bind(obj);\n      }\n\n      // Wrap nested objects/collections in read-only proxies\n      if (value && typeof value === 'object') {\n        return createReadOnlyProxy(value, `${path}.${String(prop)}`);\n      }\n\n      return value;\n    },\n\n    set(obj, prop, value) {\n      if (process.env.NODE_ENV === 'development') {\n        throw new Error(\n          `Systems must not mutate state directly. ` +\n          `Attempted to set ${path}.${String(prop)} = ${value}. ` +\n          `Use commandQueue.enqueue() instead.`\n        );\n      }\n      return false;\n    },\n\n    deleteProperty(obj, prop) {\n      if (process.env.NODE_ENV === 'development') {\n        throw new Error(\n          `Systems must not mutate state directly. ` +\n          `Attempted to delete ${path}.${String(prop)}. ` +\n          `Use commandQueue.enqueue() instead.`\n        );\n      }\n      return false;\n    }\n  });\n\n  proxyCache.set(target, proxy);\n  return proxy as T;\n}\n\n// Usage in tick loop\nconst readOnlyState = createReadOnlyProxy(gameState);\nautomationSystem.tick(readOnlyState, context);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This proxy intercepts mutations at the ",(0,s.jsx)(n.strong,{children:"top level"})," and on ",(0,s.jsx)(n.strong,{children:"nested plain objects"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["The WeakMap cache ensures each underlying object maps to a single proxy instance, so identity checks (e.g., ",(0,s.jsx)(n.code,{children:"child.parent === parent"}),") still succeed in development builds even with cyclic graphs."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Top-level property mutations throw in development mode:\nreadOnlyState.resources.energy = 100; // Throws: set state.resources.energy\ndelete readOnlyState.resources; // Throws: delete state.resources\n\n// Nested plain object mutations also throw:\nreadOnlyState.config.setting = 'new'; // Throws: set state.config.setting (if config is a plain object)\n\n// Reading works normally at all depths:\nconst energy = readOnlyState.resources.energy; // OK\nconst entity = readOnlyState.entities.get('e1'); // OK - Map methods are bound correctly\nconst hasUpgrade = readOnlyState.unlocks.has('upgrade1'); // OK - Set methods work\n\n// LIMITATION: Values returned from Map/Set are NOT wrapped yet:\nreadOnlyState.entities.get('e1').health = 50; // Succeeds (entity object not wrapped)\nreadOnlyState.entities.set('e2', { health: 100 }); // Succeeds (Map.set allowed)\nreadOnlyState.unlocks.add('upgrade2'); // Succeeds (Set.add allowed)\n\n// A follow-up task will extend the proxy to wrap collection accessor results\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Note"}),": Proxy wrapping adds overhead (~10-20% for deep object access). This enforcement should be:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enabled"})," in development/test environments to catch violations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Disabled"})," in production (pass raw ",(0,s.jsx)(n.code,{children:"gameState"})," instead of proxy) for performance"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"431-system-queue-interaction-model",children:"4.3.1 System-Queue Interaction Model"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Decision"}),": Systems interact with the command queue ",(0,s.jsx)(n.strong,{children:"only by enqueueing commands"}),". They never need to be instrumented for replay."]}),"\n",(0,s.jsx)(n.p,{children:"This approach provides:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Replay Independence"}),": When replaying a command log, systems are ",(0,s.jsx)(n.strong,{children:"not executed"}),". Only commands are re-executed via the dispatcher. This means:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ProductionSystem.tick()"})," generates ",(0,s.jsx)(n.code,{children:"APPLY_PRODUCTION"})," commands during live play"]}),"\n",(0,s.jsxs)(n.li,{children:["During replay, those same ",(0,s.jsx)(n.code,{children:"APPLY_PRODUCTION"})," commands are executed from the log"]}),"\n",(0,s.jsx)(n.li,{children:"The production system itself never runs during replay"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Deterministic Command Generation"}),": Systems must be deterministic in their command generation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2713 CORRECT: Deterministic - same state always produces same commands\nclass ProductionSystem implements System {\n  tick(state: ReadonlyGameState, context: TickContext): void {\n    const production = calculateProduction(state, context.deltaMs);\n    if (production.energy > 0) {\n       commandQueue.enqueue({\n         type: 'APPLY_PRODUCTION',\n         priority: CommandPriority.SYSTEM,\n         payload: { energy: production.energy },\n         timestamp: performance.now(),\n         step: context.step + 1 // Executed on the next tick\n       });\n     }\n   }\n }\n\n// \u2717 WRONG: Non-deterministic - uses timestamp or random values\nclass BadSystem implements System {\n  tick(state: ReadonlyGameState, context: TickContext): void {\n    if (Math.random() > 0.5) { // Non-deterministic!\n      commandQueue.enqueue({ /* ... */ });\n    }\n  }\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recording During Live Play"}),": During normal play:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Tick N:\n  1. Execute queued commands (player inputs from previous tick)\n  2. ProductionSystem.tick() \u2192 enqueues APPLY_PRODUCTION for tick N+1\n  3. AutomationSystem.tick() \u2192 enqueues PURCHASE_UPGRADE for tick N+1\n  4. Recorder captures all executed commands from step 1\n\nTick N+1:\n  1. Execute queued commands (APPLY_PRODUCTION, PURCHASE_UPGRADE)\n     \u2192 Recorder captures these\n  2. Systems generate new commands for tick N+2\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Replay Execution"}),": During replay:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Tick N:\n  1. Execute recorded commands from log\n  2. Systems are NOT called (skip steps 2-4 from live play)\n  3. State mutations come purely from commands\n\nResult: Same final state as live play\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implication for System Design"}),": Systems become ",(0,s.jsx)(n.strong,{children:"decision engines"})," that observe state and emit commands. They do not execute game logic directly. Actual state changes happen exclusively in command handlers."]}),"\n",(0,s.jsx)(n.h3,{id:"45-command-dispatcher",children:"4.5 Command Dispatcher"}),"\n",(0,s.jsx)(n.p,{children:"The dispatcher routes commands to appropriate handlers based on command type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export interface ExecutionContext {\n  readonly step: number;\n  readonly timestamp: number;\n  readonly priority: CommandPriority; // Authorization level\n}\n\nexport type CommandHandler<T = unknown> = (\n  payload: T,\n  context: ExecutionContext\n) => void | Promise<void>;\n\nexport class CommandDispatcher {\n  private readonly handlers = new Map<string, CommandHandler>();\n\n  register<T>(type: string, handler: CommandHandler<T>): void {\n    this.handlers.set(type, handler);\n  }\n\n  getHandler(type: string): CommandHandler | undefined {\n    return this.handlers.get(type);\n  }\n\n  forEachHandler(callback: (type: string, handler: CommandHandler) => void): void {\n    for (const [type, handler] of this.handlers.entries()) {\n      callback(type, handler);\n    }\n  }\n\n  execute(command: Command): void {\n    const handler = this.handlers.get(command.type);\n    if (!handler) {\n      telemetry.recordError('UnknownCommandType', { type: command.type });\n      return;\n    }\n\n    // Build execution context using the command's stored step\n    // This ensures replay sees the same ctx.step as live execution\n    const context: ExecutionContext = {\n      step: command.step, // Use command's step, not currentStep\n      timestamp: command.timestamp,\n      priority: command.priority\n    };\n\n    try {\n      const result = handler(command.payload, context);\n      if (isPromiseLike(result)) {\n        result.catch((err) => {\n          telemetry.recordError('CommandExecutionFailed', {\n            type: command.type,\n            error: err instanceof Error ? err.message : String(err)\n          });\n        });\n      }\n    } catch (err) {\n      telemetry.recordError('CommandExecutionFailed', {\n        type: command.type,\n        error: err instanceof Error ? err.message : String(err)\n      });\n    }\n  }\n}\n\nfunction isPromiseLike<T>(value: unknown): value is PromiseLike<T> {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof (value as PromiseLike<T>).then === 'function'\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Handlers may return either ",(0,s.jsx)(n.code,{children:"void"})," or a ",(0,s.jsx)(n.code,{children:"Promise<void>"}),". The dispatcher treats promise rejections the same as synchronous exceptions so that telemetry captures failures consistently."]}),"\n",(0,s.jsx)(n.h3,{id:"46-resourcestate-integration",children:"4.6 ResourceState Integration"}),"\n",(0,s.jsxs)(n.p,{children:["Command handlers no longer mutate ",(0,s.jsx)(n.code,{children:"gameState.resources"})," directly. They depend on the ",(0,s.jsx)(n.code,{children:"ResourceState"})," fa\xe7ade exported from ",(0,s.jsx)(n.code,{children:"@idle-engine/core"})," (",(0,s.jsx)(n.code,{children:"createResourceState"}),", ",(0,s.jsx)(n.code,{children:"ResourceState"}),", ",(0,s.jsx)(n.code,{children:"ResourceStateSnapshot"}),"; see ",(0,s.jsx)(n.a,{href:"/Idle-Game-Engine/resource-state-storage-design#52-runtime-api-surface",children:"Resource State Storage Design \xa75.2"})," and \xa75.6). The fa\xe7ade centralises index lookups, dirty tracking, and telemetry so handlers follow a consistent pattern:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { type ResourceState } from '@idle-engine/core';\n\nconst resources: ResourceState = runtimeResources;\n\ndispatcher.register<CollectResourcePayload>(\n  'COLLECT_RESOURCE',\n  (payload, ctx) => {\n    const index = resources.requireIndex(payload.resourceId);\n    const applied = resources.addAmount(index, payload.amount);\n    if (applied !== payload.amount) {\n      telemetry.recordWarning('ResourceCollectClamped', {\n        command: 'COLLECT_RESOURCE',\n        resourceId: payload.resourceId,\n        requested: payload.amount,\n        applied,\n        step: ctx.step,\n      });\n    }\n  },\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Key invariants for handlers:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Index acquisition"}),": ",(0,s.jsx)(n.code,{children:"requireIndex(id)"})," throws after recording a ",(0,s.jsx)(n.code,{children:"ResourceUnknownId"})," telemetry event when handed an unknown id, preventing silent array misuse."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mutation helpers"}),": ",(0,s.jsx)(n.code,{children:"addAmount"}),", ",(0,s.jsx)(n.code,{children:"spendAmount"}),", ",(0,s.jsx)(n.code,{children:"setCapacity"}),", ",(0,s.jsx)(n.code,{children:"grantVisibility"}),", ",(0,s.jsx)(n.code,{children:"unlock"}),", ",(0,s.jsx)(n.code,{children:"applyIncome"}),", and ",(0,s.jsx)(n.code,{children:"applyExpense"})," clamp values, flip dirty bits, and emit telemetry (",(0,s.jsx)(n.code,{children:"ResourceSpendFailed"}),", ",(0,s.jsx)(n.code,{children:"ResourceCapacityInvalidInput"}),", ",(0,s.jsx)(n.code,{children:"ResourceAddAmountNegativeInput"}),", ",(0,s.jsx)(n.code,{children:"ResourceDirtyToleranceSaturated"}),") when callers violate invariants. Failed spends return ",(0,s.jsx)(n.code,{children:"false"})," and leave balances untouched; pass a ",(0,s.jsx)(n.code,{children:"ResourceSpendAttemptContext"})," so telemetry ties failures back to the originating command or system."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dirty propagation"}),": Successful mutations mark indices dirty. The fa\xe7ade maintains ",(0,s.jsx)(n.code,{children:"dirtyIndexScratch"}),", ",(0,s.jsx)(n.code,{children:"dirtyIndexPositions"}),", and per-resource tolerances so publish snaps only copy the union of previous/current dirty sets (\xa75.6)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["After ",(0,s.jsx)(n.code,{children:"CommandDispatcher.execute"})," drains the tick, the runtime coordinates the publish/reset sequence with the fa\xe7ade:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Finalize"}),": Once systems finish queuing per-second rates (for example, ",(0,s.jsx)(n.code,{children:"createProductionSystem({ applyViaFinalizeTick: true })"}),"), call ",(0,s.jsx)(n.code,{children:"resourceState.finalizeTick(context.deltaMs)"})," so accumulated income/expense rolls into balances and ",(0,s.jsx)(n.code,{children:"netPerSecond"})," is recomputed deterministically (\xa75.2)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Snapshot"}),": Capture ",(0,s.jsx)(n.code,{children:"resourceState.snapshot({ mode: 'publish' })"}),"; the result is immutable-by-contract and exposes the active publish buffers (ids, amounts, capacities, per-second rates, ",(0,s.jsx)(n.code,{children:"tickDelta"}),", flags, tolerance, and ",(0,s.jsx)(n.code,{children:"dirtyIndices"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transport"}),": Feed the snapshot into ",(0,s.jsx)(n.code,{children:"buildResourcePublishTransport(snapshot, pool, { mode: 'share'|'transfer', tick })"})," or use ",(0,s.jsx)(n.code,{children:"createResourcePublishTransport(resourceState, pool, options)"}),". The helper allocates slabs from ",(0,s.jsx)(n.code,{children:"TransportBufferPool"}),", copies only the dirty prefix, and returns ",(0,s.jsx)(n.code,{children:"{ transport, transferables, release }"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Publish/Reset"}),": Post ",(0,s.jsx)(n.code,{children:"transport"})," to the shell worker (optionally transferring buffers). After the shell consumes the frame, call ",(0,s.jsx)(n.code,{children:"resourceState.resetPerTickAccumulators()"})," to zero per-second totals; tests may use ",(0,s.jsx)(n.code,{children:"forceClearDirtyState()"})," when they need a full reset without publishing."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The cross-module flow looks like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 CommandDispatcher.execute() \u2502\n\u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u2502 ctx.step / ctx.priority\n \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Command handler             \u2502\n\u2502 - requireIndex(id)          \u2502\n\u2502 - add/spend/set             \u2502\n\u2502 - optional spend context    \u2502\n\u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u2502 ResourceState facade\n \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ResourceState               \u2502\n\u2502 - clamps + telemetry        \u2502\n\u2502 - marks dirty indices       \u2502\n\u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u2502 snapshot({ mode: 'publish' })\n \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 buildResourcePublishTransport\u2502\n\u2502 + TransportBufferPool       \u2502\n\u2514\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u2502 postMessage / transferables\n \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Shell UI consumes deltas    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Telemetry guards remain active in both live play and replay. When replay executes a command log, handlers still call into the same ",(0,s.jsx)(n.code,{children:"ResourceState"})," instance; failed invariants produce identical telemetry, and the publish pipeline stays deterministic because dirty tracking is data-driven rather than frame-order dependent."]}),"\n",(0,s.jsx)(n.h2,{id:"5-command-types-initial-set",children:"5. Command Types (Initial Set)"}),"\n",(0,s.jsx)(n.p,{children:"For the prototype milestone, we define commands for core interactions:"}),"\n",(0,s.jsx)(n.h3,{id:"51-resource-commands",children:"5.1 Resource Commands"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Player purchases a generator\ninterface PurchaseGeneratorPayload {\n  generatorId: string;\n  count: number;\n}\n\n// Automation toggles a generator\ninterface ToggleGeneratorPayload {\n  generatorId: string;\n  enabled: boolean;\n}\n\n// Manual resource collection\ninterface CollectResourcePayload {\n  resourceId: string;\n  amount: number;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"52-prestige-commands",children:"5.2 Prestige Commands"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Player initiates prestige reset\ninterface PrestigeResetPayload {\n  layer: number;\n  confirmationToken?: string; // Prevents accidental resets\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"53-system-commands",children:"5.3 System Commands"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Engine applies offline catch-up adjustments\ninterface OfflineCatchupPayload {\n  elapsedMs: number;\n  resourceDeltas: Record<string, number>;\n}\n\n// Migration applied during save load\ninterface ApplyMigrationPayload {\n  fromVersion: string;\n  toVersion: string;\n  transformations: MigrationStep[];\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"6-priority-resolution",children:"6. Priority Resolution"}),"\n",(0,s.jsx)(n.p,{children:"When multiple commands are enqueued during a single frame:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System commands"})," (priority 0) execute first, ensuring migrations and resets complete before other mutations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Player commands"})," (priority 1) execute next, giving user input precedence over automation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automation commands"})," (priority 2) execute last, filling gaps not covered by player actions"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Within the same priority tier, commands execute in timestamp order (FIFO)."}),"\n",(0,s.jsx)(n.h3,{id:"example-scenario",children:"Example Scenario"}),"\n",(0,s.jsx)(n.p,{children:"Frame receives:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:['Player clicks "Buy Generator" at ',(0,s.jsx)(n.code,{children:"t=1000.5ms"})," (PLAYER priority)"]}),"\n",(0,s.jsxs)(n.li,{children:['Automation system queues "Auto-buy upgrade" at ',(0,s.jsx)(n.code,{children:"t=1000.8ms"})," (AUTOMATION priority)"]}),"\n",(0,s.jsxs)(n.li,{children:["Engine detects save version mismatch, queues migration at ",(0,s.jsx)(n.code,{children:"t=1001.0ms"})," (SYSTEM priority)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Execution order:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Migration (SYSTEM, t=1001.0)"}),"\n",(0,s.jsx)(n.li,{children:"Buy Generator (PLAYER, t=1000.5)"}),"\n",(0,s.jsx)(n.li,{children:"Auto-buy upgrade (AUTOMATION, t=1000.8)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"7-integration-with-presentation-layer",children:"7. Integration with Presentation Layer"}),"\n",(0,s.jsx)(n.h3,{id:"71-worker-bridge-api",children:"7.1 Worker Bridge API"}),"\n",(0,s.jsx)(n.p,{children:"The Worker bridge provides a type-safe command interface for the presentation layer:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export enum CommandSource {\n  PLAYER = 'PLAYER',       // User-initiated actions (clicks, keyboard)\n  AUTOMATION = 'AUTOMATION', // Automated systems within runtime\n  SYSTEM = 'SYSTEM'         // Engine-level operations\n}\n\nexport interface WorkerBridge {\n  // Send command from presentation layer (always uses PLAYER source)\n  sendCommand<T = unknown>(type: string, payload: T): void;\n\n  // Subscribe to state updates from runtime\n  onStateUpdate(callback: (state: GameState) => void): void;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The bridge implementation wraps commands with metadata and posts to the Worker:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export class WorkerBridgeImpl implements WorkerBridge {\n  private stateUpdateCallbacks: Array<(state: GameState) => void> = [];\n\n  constructor(private readonly worker: Worker) {\n    // Single message handler dispatches to all subscribers\n    this.worker.onmessage = (event) => {\n      if (event.data.type === 'STATE_UPDATE') {\n        for (const callback of this.stateUpdateCallbacks) {\n          callback(event.data.state);\n        }\n      }\n      // Other message types can be added here without collision\n    };\n  }\n\n  sendCommand<T>(type: string, payload: T): void {\n    this.worker.postMessage({\n      type: 'COMMAND',\n      source: CommandSource.PLAYER, // Always PLAYER from UI\n      command: {\n        type,\n        payload,\n        timestamp: performance.now()\n        // step will be stamped by Worker runtime when enqueuing\n      }\n    });\n  }\n\n  onStateUpdate(callback: (state: GameState) => void): void {\n    this.stateUpdateCallbacks.push(callback);\n  }\n\n  offStateUpdate(callback: (state: GameState) => void): void {\n    const index = this.stateUpdateCallbacks.indexOf(callback);\n    if (index !== -1) {\n      this.stateUpdateCallbacks.splice(index, 1);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"72-runtime-command-reception",children:"7.2 Runtime Command Reception"}),"\n",(0,s.jsxs)(n.p,{children:["The Worker runtime receives messages from the main thread and ",(0,s.jsx)(n.strong,{children:"must treat all external messages as PLAYER priority"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const runtimeClock = createMonotonicClock();\n\n// Worker message handler - CRITICAL SECURITY BOUNDARY\nself.onmessage = (event) => {\n  if (event.data.type === 'COMMAND') {\n    // SECURITY: All commands from main thread (postMessage) are PLAYER priority.\n    // The Worker never trusts caller-provided metadata (source, timestamp, etc).\n    commandQueue.enqueue({\n      ...event.data.command,\n      priority: CommandPriority.PLAYER, // Always PLAYER from external source\n      timestamp: runtimeClock.now(), // Stamp inside the Worker to prevent tampering\n      step: nextExecutableStep // Stamp with the tick that will execute the command\n    });\n  }\n};\n\nfunction createMonotonicClock() {\n  let last = 0;\n  return {\n    now(): number {\n      const raw = performance.now();\n      last = raw > last ? raw : last + 0.0001;\n      return last;\n    }\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Internal Command Enqueueing"})," (within Worker):"]}),"\n",(0,s.jsxs)(n.p,{children:["Systems and engine code running ",(0,s.jsx)(n.strong,{children:"inside the Worker"})," can enqueue with elevated priorities:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// ProductionSystem (runs inside Worker)\nclass ProductionSystem implements System {\n  tick(state: ReadonlyGameState, context: TickContext): void {\n    const production = calculateProduction(state, context.deltaMs);\n\n    // Direct enqueue with SYSTEM priority (safe - code runs in Worker)\n    commandQueue.enqueue({\n      type: 'APPLY_PRODUCTION',\n      priority: CommandPriority.SYSTEM, // OK - internal code\n      payload: { resources: production },\n      timestamp: performance.now(),\n      step: context.step + 1 // Executed next tick\n    });\n  }\n}\n\n// Prestige reset (engine code inside Worker)\nfunction executePrestigeReset(currentStep: number, layer: number) {\n  commandQueue.enqueue({\n    type: 'PRESTIGE_RESET',\n    priority: CommandPriority.SYSTEM, // OK - internal code\n    payload: { layer },\n    timestamp: performance.now(),\n    step: currentStep + 1 // Executed next tick\n  });\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Security Architecture"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Trust Boundary"}),": The Worker's ",(0,s.jsx)(n.code,{children:"self.onmessage"})," handler acts as the security boundary.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Untrusted"}),": Any message from the main thread (UI, dev tools, injected scripts)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Trusted"}),": Code executing within the Worker context."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Priority & Timestamp Assignment"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Messages from ",(0,s.jsx)(n.code,{children:"postMessage()"})," always become PLAYER priority and receive a Worker-stamped monotonic timestamp."]}),"\n",(0,s.jsxs)(n.li,{children:["Internal ",(0,s.jsx)(n.code,{children:"commandQueue.enqueue()"})," calls (trusted code) keep the requested priority and can supply custom ordering metadata."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Attack Prevention"}),": Compromised UI code cannot escalate permissions."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2717 Attack attempt (from compromised UI):\nworker.postMessage({\n  type: 'COMMAND',\n  source: 'SYSTEM', // Attacker tries to escalate\n  command: { type: 'GRANT_RESOURCES', payload: { energy: 9999999 } }\n});\n\n// \u2713 Runtime handles safely:\n// - Ignores event.data.source and event.data.command.timestamp\n// - Forces priority = PLAYER\n// - Replaces timestamp with Worker-owned monotonic clock\n// - Command executes with normal player permissions\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authorization via Priority"}),": Command handlers receive ",(0,s.jsx)(n.code,{children:"context.priority"})," and reject work outside their allowed tier."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const resources: ResourceState = runtimeResources; // Created via createResourceState(...)\n\n// System-only commands check priority\nconst grantResourcesHandler = (\n  payload: GrantResourcesPayload,\n  ctx: ExecutionContext\n) => {\n  if (ctx.priority !== CommandPriority.SYSTEM) {\n    telemetry.recordWarning('UnauthorizedSystemCommand', {\n      payload,\n      attemptedPriority: ctx.priority\n    });\n    return; // Reject - only system commands allowed\n  }\n\n  const index = resources.requireIndex(payload.resourceId);\n  resources.addAmount(index, payload.amount); // Marks dirty + clamps internally\n};\n\n// Most commands accept any priority (SYSTEM, PLAYER, or AUTOMATION)\nconst purchaseGeneratorHandler = (\n  payload: PurchaseGeneratorPayload,\n  ctx: ExecutionContext\n) => {\n  const generator = registry.getGenerator(payload.generatorId);\n  const totalCost = generator.cost * payload.count;\n  const energyIndex = resources.requireIndex('energy'); // Sample pack purchases spend energy\n\n  const spendSucceeded = resources.spendAmount(energyIndex, totalCost, {\n    commandId: 'PURCHASE_GENERATOR',\n    systemId: ctx.priority === CommandPriority.AUTOMATION ? 'auto-buy' : undefined\n  });\n\n  if (!spendSucceeded) {\n    telemetry.recordWarning('InsufficientResources', {\n      generatorId: payload.generatorId,\n      cost: totalCost,\n      priority: ctx.priority\n    });\n    return; // Command rejected, no state mutation\n  }\n\n  generator.owned += payload.count;\n};\n\n// Some commands restrict based on priority\nconst prestigeResetHandler = (\n  payload: PrestigeResetPayload,\n  ctx: ExecutionContext\n) => {\n  if (ctx.priority === CommandPriority.AUTOMATION) {\n    telemetry.recordWarning('AutomationPrestigeBlocked', { payload });\n    return; // Require explicit player confirmation\n  }\n\n  executePrestigeReset(ctx.step, payload.layer);\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Priority Authorization Levels"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CommandPriority.SYSTEM"})," (0): Full authority\u2014migrations, admin tools, engine operations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CommandPriority.PLAYER"})," (1): User actions\u2014purchases, prestige, manual triggers."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CommandPriority.AUTOMATION"})," (2): Automation flows\u2014purchases allowed, destructive operations restricted."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Handler Authorization Patterns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No restrictions"})," (purchases, resource collection): Accept any priority."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Player-or-System only"})," (prestige, destructive actions): Block AUTOMATION."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System-only"})," (migrations, debug commands): Require SYSTEM priority."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Security Note"}),": The ",(0,s.jsx)(n.code,{children:"CommandSource"})," enum exists for documentation purposes, but the Worker ",(0,s.jsx)(n.strong,{children:"never trusts the source field from external messages"}),". All ",(0,s.jsx)(n.code,{children:"postMessage()"})," commands are treated as PLAYER priority, regardless of what the sender claims. Only code running inside the Worker can enqueue SYSTEM or AUTOMATION commands."]}),"\n",(0,s.jsx)(n.h4,{id:"721-purchase-evaluator-pattern-existing-implementation",children:"7.2.1 Purchase Evaluator Pattern (Existing Implementation)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": This subsection documents the ",(0,s.jsx)(n.strong,{children:"existing purchase evaluator pattern"})," as shipped in PR #303 (",(0,s.jsx)(n.code,{children:"packages/core/src/progression-coordinator.ts"}),"). This is retroactive documentation of production code."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Separation of Quote vs. Application"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["The purchase handler pattern separates ",(0,s.jsx)(n.strong,{children:"cost calculation"})," (quote) from ",(0,s.jsx)(n.strong,{children:"purchase application"})," (state mutation). This separation enables:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"UI to display accurate costs before purchase"}),"\n",(0,s.jsx)(n.li,{children:"Command handlers to validate affordability before mutating state"}),"\n",(0,s.jsx)(n.li,{children:"Consistent cost calculation between preview and execution"}),"\n",(0,s.jsx)(n.li,{children:"Testing cost formulas independently from state mutation"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purchase Evaluator Interfaces"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["Defined in ",(0,s.jsx)(n.code,{children:"@idle-engine/core"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface GeneratorPurchaseEvaluator {\n  getPurchaseQuote(generatorId: string, count: number): GeneratorPurchaseQuote | undefined;\n  applyPurchase(generatorId: string, count: number): void;\n}\n\ninterface UpgradePurchaseEvaluator {\n  getPurchaseQuote(upgradeId: string): UpgradePurchaseQuote | undefined;\n  applyPurchase(upgradeId: string): void;\n}\n\ntype GeneratorPurchaseQuote = {\n  generatorId: string;\n  costs: readonly { resourceId: string; amount: number }[];\n};\n\ntype UpgradePurchaseQuote = {\n  upgradeId: string;\n  status: 'locked' | 'available' | 'purchased';\n  costs: readonly { resourceId: string; amount: number }[];\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Evaluator Implementation"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["The progression coordinator (",(0,s.jsx)(n.code,{children:"packages/core/src/progression-coordinator.ts"}),") provides concrete implementations:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class ContentGeneratorEvaluator implements GeneratorPurchaseEvaluator {\n  getPurchaseQuote(generatorId: string, count: number): GeneratorPurchaseQuote | undefined {\n    const record = this.coordinator.getGeneratorRecord(generatorId);\n    if (!record?.state.isUnlocked || !record?.state.isVisible) {\n      return undefined; // Cannot purchase locked/hidden generators\n    }\n\n    // Compute total cost by summing individual purchase costs\n    let totalCost = 0;\n    for (let offset = 0; offset < count; offset++) {\n      const purchaseLevel = record.state.owned + offset;\n      const cost = this.coordinator.computeGeneratorCost(generatorId, purchaseLevel);\n      if (cost === undefined) return undefined;\n      totalCost += cost;\n    }\n\n    return {\n      generatorId,\n      costs: [{ resourceId: record.definition.purchase.currencyId, amount: totalCost }]\n    };\n  }\n\n  applyPurchase(generatorId: string, count: number): void {\n    this.coordinator.incrementGeneratorOwned(generatorId, count);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Command Handler Integration"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Purchase command handlers delegate to evaluators:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function registerResourceCommandHandlers(options: {\n  dispatcher: CommandDispatcher;\n  resources: ResourceState;\n  generatorPurchases: GeneratorPurchaseEvaluator;\n  upgradePurchases?: UpgradePurchaseEvaluator;\n}): void {\n  dispatcher.register('PURCHASE_GENERATOR', (payload, ctx) => {\n    // Get quote from evaluator\n    const quote = options.generatorPurchases.getPurchaseQuote(\n      payload.generatorId,\n      payload.count\n    );\n\n    if (!quote) {\n      telemetry.recordWarning('GeneratorPurchaseQuoteUnavailable', { payload });\n      return; // Quote failed (locked, invalid, etc.)\n    }\n\n    // Validate affordability by attempting to spend all costs\n    for (const cost of quote.costs) {\n      const index = options.resources.requireIndex(cost.resourceId);\n      const spendSucceeded = options.resources.spendAmount(index, cost.amount, {\n        commandId: 'PURCHASE_GENERATOR',\n        systemId: ctx.priority === CommandPriority.AUTOMATION ? 'auto-buy' : undefined\n      });\n\n      if (!spendSucceeded) {\n        telemetry.recordWarning('InsufficientResources', { payload, cost });\n        return; // Insufficient resources, no state mutation\n      }\n    }\n\n    // Apply purchase (increment owned count)\n    options.generatorPurchases.applyPurchase(payload.generatorId, payload.count);\n  });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["Evaluators return ",(0,s.jsx)(n.code,{children:"undefined"})," when quotes cannot be generated:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Generator is locked or hidden"}),"\n",(0,s.jsxs)(n.li,{children:["Purchase would exceed ",(0,s.jsx)(n.code,{children:"maxLevel"})]}),"\n",(0,s.jsxs)(n.li,{children:["Bulk purchase count exceeds ",(0,s.jsx)(n.code,{children:"maxBulk"})]}),"\n",(0,s.jsx)(n.li,{children:"Cost formula evaluation fails (non-finite result)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Command handlers treat ",(0,s.jsx)(n.code,{children:"undefined"})," quotes as validation failures and no-op without mutating state."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Integration Points"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Progression Coordinator"}),": Creates evaluator instances and provides them to command handlers (",(0,s.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:151-160"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Progression Snapshot"}),": Snapshot builder calls evaluators to populate ",(0,s.jsx)(n.code,{children:"costs"})," arrays in UI views (",(0,s.jsx)(n.code,{children:"packages/core/src/progression.ts:220-251"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Command Handlers"}),": Resource command handlers delegate validation and application to evaluators (",(0,s.jsx)(n.code,{children:"packages/core/src/resource-command-handlers.ts"}),")"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implementation Reference"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Generator evaluator: ",(0,s.jsx)(n.code,{children:"packages/core/src/progression-coordinator.ts"})]}),"\n",(0,s.jsxs)(n.li,{children:["Upgrade evaluator: ",(0,s.jsx)(n.code,{children:"packages/core/src/progression-coordinator.ts"})]}),"\n",(0,s.jsxs)(n.li,{children:["Command handler registration: ",(0,s.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:151-160"})]}),"\n",(0,s.jsxs)(n.li,{children:["Evaluator interfaces: ",(0,s.jsx)(n.code,{children:"packages/core/src/progression.ts"})," (type exports)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Design Rationale"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Separating quote from application provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Determinism"}),": Cost calculation is pure (same inputs \u2192 same outputs)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testability"}),": Evaluators can be tested independently from command queue"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"UI accuracy"}),": Presentation layer displays exact costs that will be charged"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extensibility"}),": Future evaluators can override cost calculation without changing handlers"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"73-usage-in-react-components",children:"7.3 Usage in React Components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// In React component\nimport { useWorkerBridge } from '@idle-engine/shell-web';\n\nfunction GeneratorButton({ id, cost }: GeneratorProps) {\n  const bridge = useWorkerBridge();\n\n  const handlePurchase = () => {\n    bridge.sendCommand('PURCHASE_GENERATOR', {\n      generatorId: id,\n      count: 1\n    });\n  };\n\n  return <button onClick={handlePurchase}>Buy Reactor ({cost} energy)</button>;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"74-automation-system-integration",children:"7.4 Automation System Integration"}),"\n",(0,s.jsxs)(n.p,{children:["Automation systems run ",(0,s.jsx)(n.strong,{children:"inside the Worker"})," and can enqueue commands directly:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Inside Worker - Automation System\nclass AutoBuySystem implements System {\n  tick(state: ReadonlyGameState, context: TickContext): void {\n    const affordable = findAffordableUpgrades(state);\n\n    for (const upgrade of affordable) {\n      commandQueue.enqueue({\n        type: 'PURCHASE_UPGRADE',\n        priority: CommandPriority.AUTOMATION, // Direct priority assignment\n        payload: { upgradeId: upgrade.id },\n        timestamp: performance.now(),\n        step: context.step + 1 // Executed next tick\n      });\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This architecture ensures:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["UI commands always get ",(0,s.jsx)(n.code,{children:"PLAYER"})," priority via the bridge"]}),"\n",(0,s.jsx)(n.li,{children:"Automation systems can only enqueue from within the Worker runtime"}),"\n",(0,s.jsx)(n.li,{children:"System commands are reserved for engine-level operations (migrations, resets)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"8-command-recording--replay",children:"8. Command Recording & Replay"}),"\n",(0,s.jsx)(n.p,{children:"For debugging and testing, the runtime can record all executed commands."}),"\n",(0,s.jsx)(n.h3,{id:"81-recorder-snapshot-lifecycle",children:"8.1 Recorder Snapshot Lifecycle"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Decision"}),": The recorder captures its state snapshot at ",(0,s.jsx)(n.strong,{children:"construction time"}),", before any commands are recorded."]}),"\n",(0,s.jsx)(n.p,{children:"This design ensures:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Snapshot Timing"}),": The snapshot represents the ",(0,s.jsx)(n.strong,{children:"exact"})," state from which the first recorded command will execute"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Correct usage - snapshot taken before any mutations\nconst initialState = createGameState();\nconst recorder = new CommandRecorder(initialState); // Snapshot captured here\n\n// Now safe to mutate state via commands\nrecorder.record(buyGeneratorCommand); // Record first\ndispatcher.execute(buyGeneratorCommand); // Then execute\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Lifecycle Guarantees"}),":"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Construction"}),": ",(0,s.jsx)(n.code,{children:"new CommandRecorder(state)"})," performs ",(0,s.jsx)(n.code,{children:"deepFreeze(cloneDeep(state))"})," immediately and snapshots the active RNG seed (via ",(0,s.jsx)(n.code,{children:"getCurrentRNGSeed()"})," or an explicit override)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Recording"}),": ",(0,s.jsx)(n.code,{children:"record(cmd)"})," appends to internal array, does not touch snapshot"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Export"}),": ",(0,s.jsx)(n.code,{children:"export()"})," returns frozen log containing the original snapshot + recorded commands"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Replay"}),": ",(0,s.jsx)(n.code,{children:"replay(log)"})," restores ",(0,s.jsx)(n.code,{children:"log.startState"}),", then executes ",(0,s.jsx)(n.code,{children:"log.commands"})," in order"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usage Patterns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Pattern A: Session Recording (typical use case)"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// At game load/start\nconst gameState = await loadSaveOrCreateNew();\nconst sessionRecorder = new CommandRecorder(gameState); // Snapshot at session start\n\n// During play - record commands then execute them\nfunction executeAndRecord(cmd: Command) {\n  sessionRecorder.record(cmd); // Record first\n  dispatcher.execute(cmd);     // Then execute\n}\n\n// On crash/bug report\nconst log = sessionRecorder.export(); // Contains all commands from session start\nsendToServer(log);\n\n// Replaying a log (separate replay-only dispatcher to avoid recording)\nfunction replayBugReport(log: CommandLog) {\n  const replayDispatcher = new CommandDispatcher();\n  // Copy handlers from main dispatcher\n  mainDispatcher.forEachHandler((type, handler) => {\n    replayDispatcher.register(type, handler);\n  });\n\n  const replayRecorder = new CommandRecorder(log.startState);\n  replayRecorder.replay(log, replayDispatcher);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Pattern B: Deterministic Testing"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Test setup\nconst testState = { resources: { energy: 100 }, generators: {} };\nconst recorder = new CommandRecorder(testState); // Known initial state\n\n// Execute test scenario\nconst commands = [\n  buyGeneratorCommand,\n  waitCommand,\n  collectResourceCommand\n];\n\nfor (const cmd of commands) {\n  recorder.record(cmd);\n  dispatcher.execute(cmd);\n}\n\n// Verify replay matches\nconst log = recorder.export();\nconst replayState = await replayLog(log);\nexpect(replayState).toEqual(currentState);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Pattern C: Sub-session Recording"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Record only a specific interaction, not full session\nfunction recordUserFlow(startState: GameState) {\n  const recorder = new CommandRecorder(startState); // Snapshot before flow\n\n  // User completes prestige flow\n  executePrestigeCommands();\n\n  return recorder.export(); // Just the prestige commands\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Anti-patterns (will cause replay mismatch)"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2717 WRONG: Mutating state before creating recorder\nconst state = createGameState();\nstate.resources.energy = 50; // Mutation\nconst recorder = new CommandRecorder(state); // Snapshot includes mutation\n// Later commands assume energy=50, but original state was different\n\n// \u2717 WRONG: Reusing recorder after state reset\nconst recorder = new CommandRecorder(initialState);\nrecorder.record(cmd1);\ngameState = resetToInitial(); // State reset\nrecorder.record(cmd2); // cmd2 assumes reset state, but snapshot is pre-reset\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"// \u2713 CORRECT: Reinitialize recorder after reset\nconst recorder = new CommandRecorder(initialState);\nrecorder.record(cmd1);"}),"\n",(0,s.jsx)(n.p,{children:"gameState = resetToInitial();\nrecorder.clear(gameState); // Refresh snapshot so new commands replay correctly\nrecorder.record(cmd2);"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\n`clear(nextState)` always clones and freezes the new baseline before recording resumes, preventing stale snapshots from leaking across sessions.\n\n> **Seed overrides**: Tests or tooling that drive a specific PRNG stream can provide `new CommandRecorder(state, { seed })` or `recorder.clear(nextState, { seed })`. When omitted, the recorder falls back to the runtime's `getCurrentRNGSeed()` helper.\n\n5. **Tooling Implications**:\n   - **Dev Tools**: Recorder starts when dev panel opens, captures state at that moment\n   - **CI Tests**: Each test case creates fresh recorder with known fixture state\n   - **Bug Reports**: Session recorder created at game initialization, runs for entire session\n   - **A/B Testing**: Strategy simulator creates recorder per simulation run\n\n### 8.2 Implementation\n\nTo avoid ambiguity when we wire this into the runtime, we will introduce a concrete alias alongside the queue implementation:\n\n```typescript\nexport type StateSnapshot = DeepReadonly<GameState>;\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"StateSnapshot"})," represents the exact shape produced by ",(0,s.jsx)(n.code,{children:"structuredClone(gameState)"}),"\u2014all fields are recursively read-only and restricted to structured-clone-friendly types. The alias will live in the shared runtime typings so both the recorder and replay utilities consume the same definition. If additional serialization constraints emerge (e.g., stripping out non-cloneable dev-only fields), the alias should be updated to wrap an explicit ",(0,s.jsx)(n.code,{children:"SerializableGameState"})," interface, but the contract remains: snapshots must be safe to clone, freeze, and ship across worker boundaries."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export interface CommandLog {\n  readonly version: string;\n  readonly startState: StateSnapshot;\n  readonly commands: readonly Command[];\n  readonly metadata: {\n    readonly recordedAt: number;\n    readonly seed?: number; // Active RNG seed captured at record time\n    readonly lastStep: number; // Highest step observed while recording (-1 when nothing executed)\n  };\n}\n\nexport interface RuntimeReplayContext {\n  readonly commandQueue: CommandQueue;\n  getCurrentStep?(): number;\n  getNextExecutableStep?(): number;\n  setCurrentStep?(step: number): void;\n  setNextExecutableStep?(step: number): void;\n}\n\n// The runtime exposes the current deterministic PRNG seed via `getCurrentRNGSeed()`.\n// Tests or tooling can override the captured value by supplying `{ seed }` to the\n// recorder constructor or `clear()` helper.\n\n// metadata.lastStep allows the runtime to realign its current/next step counters\n// after replay so that subsequent ticks tick from the same position as the\n// original session.\n\nexport class CommandRecorder {\n  private readonly recorded: Command[] = [];\n  private startState: StateSnapshot; // Stored as cloneable, plain data\n  private rngSeed: number | undefined;\n  private lastRecordedStep = -1;\n\n  constructor(currentState: GameState, options?: { seed?: number }) {\n    // Clone state immediately (cloneable, not frozen)\n    this.startState = cloneDeep(currentState);\n    // Freeze the clone to prevent accidental mutation\n    deepFreezeInPlace(this.startState);\n    // Capture the RNG seed so replay can restore identical randomness\n    this.rngSeed = options?.seed ?? getCurrentRNGSeed?.();\n  }\n\n  record(command: Command): void {\n    const snapshot = cloneDeep(command);   // Defensively copy the command\n    deepFreezeInPlace(snapshot);           // Freeze to catch accidental mutation in dev\n    this.recorded.push(snapshot);\n    this.lastRecordedStep = Math.max(this.lastRecordedStep, command.step);\n  }\n\n  export(): CommandLog {\n    const lastStep = this.lastRecordedStep;\n\n    // Return defensive copy - clone the snapshot again for export\n    const exportedLog = {\n      version: '0.1.0',\n      startState: cloneDeep(this.startState), // Fresh clone (unfrozen)\n      commands: this.recorded.map(cloneDeep), // New clones so log remains isolated\n      metadata: {\n        recordedAt: Date.now(),\n        seed: this.rngSeed,\n        lastStep\n      }\n    };\n\n    // Freeze the exported log to prevent mutation\n    deepFreezeInPlace(exportedLog);\n    return exportedLog as CommandLog;\n  }\n\n  // runtimeContext is optional; when omitted replay runs against ephemeral queue/state\n  replay(log: CommandLog, dispatcher: CommandDispatcher, runtimeContext?: RuntimeReplayContext): void {\n    // Clone the snapshot to get a mutable working copy\n    const mutableState = cloneDeep(log.startState);\n\n    // Restore to initial state\n    restoreState(mutableState);\n\n    // Restore RNG seed if present (for deterministic random handlers)\n    if (log.metadata.seed !== undefined) {\n      setRNGSeed(log.metadata.seed);\n    }\n\n    // Sandbox command enqueueing so replay cannot mutate the live queue, while\n    // still verifying that every follow-up enqueue is present in the recorded log.\n    const queue =\n      runtimeContext?.commandQueue ??\n      new CommandQueue(); // Isolated queue for replay when no runtime context is supplied\n\n    if (queue.size > 0) {\n      telemetry.recordError('ReplayQueueNotEmpty', { pending: queue.size });\n      throw new Error('Command queue must be empty before replay begins.');\n    }\n    const sandboxedEnqueues: Command[] = [];\n    const originalEnqueue = queue.enqueue.bind(queue);\n\n    const recordedFinalStep = log.metadata.lastStep ?? -1;\n    const derivedFinalStep =\n      log.commands.length > 0\n        ? log.commands.reduce((max, cmd) => Math.max(max, cmd.step), -1)\n        : -1;\n    const finalStep = recordedFinalStep >= 0 ? recordedFinalStep : derivedFinalStep;\n    const previousStep = runtimeContext?.getCurrentStep?.();\n    const previousNextStep = runtimeContext?.getNextExecutableStep?.();\n    let replayFailed = true;\n\n    // Track which future commands have already been matched to handler enqueues.\n    const matchedFutureCommandIndices = new Set<number>();\n\n    (queue as any).enqueue = (cmd: Command) => {\n      const snapshot = cloneDeep(cmd);\n      deepFreezeInPlace(snapshot);\n      sandboxedEnqueues.push(snapshot);\n    };\n\n    try {\n      for (let i = 0; i < log.commands.length; i++) {\n        const cmd = log.commands[i];\n\n        const context: ExecutionContext = {\n          step: cmd.step, // Use stored step, NOT an incrementing counter\n          timestamp: cmd.timestamp,\n          priority: cmd.priority\n        };\n\n        const handler = dispatcher.getHandler(cmd.type);\n        if (!handler) {\n          telemetry.recordError('ReplayUnknownCommandType', {\n            type: cmd.type,\n            step: cmd.step\n          });\n        } else {\n          try {\n            handler(cmd.payload, context);\n          } catch (err) {\n            telemetry.recordError('ReplayExecutionFailed', {\n              type: cmd.type,\n              step: cmd.step,\n              error: err instanceof Error ? err.message : String(err)\n            });\n          }\n        }\n\n        if (sandboxedEnqueues.length > 0) {\n          for (const queued of sandboxedEnqueues) {\n            const matchIndex = findMatchingFutureCommandIndex(\n              log.commands,\n              queued,\n              i + 1,\n              matchedFutureCommandIndices\n            );\n\n            if (matchIndex === -1) {\n              telemetry.recordError('ReplayMissingFollowupCommand', {\n                type: queued.type,\n                step: queued.step\n              });\n              throw new Error(\n                'Replay log is missing a command that was enqueued during handler execution.'\n              );\n            }\n\n            matchedFutureCommandIndices.add(matchIndex);\n          }\n\n          sandboxedEnqueues.length = 0;\n        }\n      }\n\n      replayFailed = false;\n    } finally {\n      (queue as any).enqueue = originalEnqueue;\n      if (replayFailed) {\n        if (previousStep !== undefined) {\n          runtimeContext?.setCurrentStep?.(previousStep);\n        }\n        if (previousNextStep !== undefined) {\n          runtimeContext?.setNextExecutableStep?.(previousNextStep);\n        }\n      } else if (finalStep >= 0 && runtimeContext) {\n        runtimeContext.setCurrentStep?.(finalStep + 1);\n        runtimeContext.setNextExecutableStep?.(finalStep + 1);\n      }\n    }\n  }\n\n  clear(nextState: GameState, options?: { seed?: number }): void {\n    this.recorded.length = 0;\n    this.startState = cloneDeep(nextState);\n    deepFreezeInPlace(this.startState);\n    this.rngSeed = options?.seed ?? getCurrentRNGSeed?.();\n    this.lastRecordedStep = -1;\n  }\n}\n\nWhen a replay runs without a `RuntimeReplayContext`, the recorder provisions a throwaway `CommandQueue` so that handler enqueues are still sandboxed and validated without touching the live runtime state. Tooling and tests can therefore replay logs in isolation, while embedding runtimes can opt into sharing their real queue by supplying the context.\n\n// Recording always stores frozen clones so later mutations (payload pooling,\n// handler-side adjustments, dev tools poking) cannot corrupt the captured\n// history. Exporting clones the array again, keeping each log immutable and\n// isolated from future recordings.\n\ndeclare const getCurrentRNGSeed:\n  | (() => number | undefined)\n  | undefined; // Provided by RNG module; may be undefined in tests\n\n// Utility functions\nfunction cloneDeep<T>(obj: T): T {\n  return structuredClone(obj); // Native deep clone (Node 17+, all modern browsers)\n}\n\n/**\n * Restore RNG seed for deterministic replay.\n * Handlers that use randomness must use this seeded RNG, not Math.random().\n */\nfunction setRNGSeed(seed: number): void {\n  // Implementation depends on RNG library (e.g., seedrandom, mulberry32)\n  // Example with seedrandom:\n  // Math.random = seedrandom(seed.toString());\n\n  // Or with custom PRNG:\n  rngState = seed;\n}\n\nfunction seededRandom(): number {\n  // Deterministic PRNG (e.g., mulberry32)\n  rngState = (rngState + 0x6D2B79F5) | 0;\n  let t = Math.imul(rngState ^ (rngState >>> 15), 1 | rngState);\n  t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\n  return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n}\n\n/**\n * Locate the first future command in the log that matches the queued command.\n * Replay asserts deterministic timestamps so handlers that stamp commands must be pure.\n */\nfunction findMatchingFutureCommandIndex(\n  commands: readonly Command[],\n  candidate: Command,\n  startIndex: number,\n  claimedIndices: Set<number>\n): number {\n  for (let i = startIndex; i < commands.length; i++) {\n    if (claimedIndices.has(i)) {\n      continue;\n    }\n    if (commandsEqual(commands[i], candidate)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction commandsEqual(a: Command, b: Command): boolean {\n  return (\n    a.type === b.type &&\n    a.priority === b.priority &&\n    a.step === b.step &&\n    a.timestamp === b.timestamp &&\n    payloadsMatch(a.payload, b.payload)\n  );\n}\n\nfunction payloadsMatch(left: unknown, right: unknown, seen = new WeakMap<any, any>()): boolean {\n  if (Object.is(left, right)) {\n    return true;\n  }\n\n  if (typeof left !== typeof right) {\n    return false;\n  }\n\n  if (!left || !right || typeof left !== 'object') {\n    return left === right;\n  }\n\n  const existing = seen.get(left);\n  if (existing) {\n    return existing === right;\n  }\n  seen.set(left, right);\n\n  if (left instanceof Map && right instanceof Map) {\n    if (left.size !== right.size) {\n      return false;\n    }\n    const rightEntries = Array.from(right.entries());\n    return Array.from(left.entries()).every(([lk, lv], index) => {\n      const [rk, rv] = rightEntries[index];\n      return payloadsMatch(lk, rk, seen) && payloadsMatch(lv, rv, seen);\n    });\n  }\n\n  if (left instanceof Set && right instanceof Set) {\n    if (left.size !== right.size) {\n      return false;\n    }\n    const rightValues = Array.from(right.values());\n    return Array.from(left.values()).every((lv, index) =>\n      payloadsMatch(lv, rightValues[index], seen)\n    );\n  }\n\n  if (Array.isArray(left) && Array.isArray(right)) {\n    if (left.length !== right.length) {\n      return false;\n    }\n    for (let i = 0; i < left.length; i++) {\n      if (!payloadsMatch(left[i], right[i], seen)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (isArrayBufferViewLike(left) && isArrayBufferViewLike(right)) {\n    if (left.byteLength !== right.byteLength) {\n      return false;\n    }\n    const leftBytes = getArrayBufferViewBytes(left);   // unwraps immutable proxies\n    const rightBytes = getArrayBufferViewBytes(right); // and compares raw bytes\n    for (let i = 0; i < leftBytes.length; i++) {\n      if (leftBytes[i] !== rightBytes[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (left instanceof Date && right instanceof Date) {\n    return left.getTime() === right.getTime();\n  }\n\n  const leftKeys = Object.keys(left as Record<string, unknown>);\n  const rightKeys = Object.keys(right as Record<string, unknown>);\n  if (leftKeys.length !== rightKeys.length) {\n    return false;\n  }\n\n  for (const key of leftKeys) {\n    if (!Object.prototype.hasOwnProperty.call(right, key)) {\n      return false;\n    }\n    if (!payloadsMatch(\n      (left as Record<string, unknown>)[key],\n      (right as Record<string, unknown>)[key],\n      seen\n    )) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// payloadsMatch walks the payload graph, respecting Map/Set order and\n// accounting for shared references via the WeakMap. ArrayBuffer/DataView proxies\n// produced by deepFreezeInPlace go through getArrayBufferViewBytes so byte\n// mismatches are still detected. This avoids relying on generic deep-equality\n// helpers that ignore structured-clone-only types.\n\n/**\n * Freeze an object in-place, making plain objects/arrays immutable.\n *\n * IMPORTANT LIMITATIONS:\n * - Object.freeze() does NOT prevent Map.set/delete/clear or Set.add/delete/clear\n * - TypedArrays cannot be frozen (throws TypeError)\n * - This provides protection against accidental mutation, not malicious tampering\n *\n * The recorder relies on:\n * 1. Cloning to isolate snapshots (primary defense)\n * 2. Freezing plain objects to catch accidental mutations in dev\n * 3. Discipline to not mutate Map/Set/TypedArray in snapshots\n */\nfunction deepFreezeInPlace<T>(obj: T): T {\n  const seen = new WeakSet<object>();\n\n  function freezeRecursive(value: any): void {\n    if (!value || typeof value !== 'object') {\n      return; // Primitives don't need freezing\n    }\n\n    if (seen.has(value)) {\n      return; // Already processed (prevents cycles)\n    }\n\n    seen.add(value);\n\n    // Skip TypedArrays - Object.freeze throws on them\n    if (ArrayBuffer.isView(value)) {\n      // TypedArrays (Uint8Array, etc.) cannot be frozen\n      // Rely on cloning for isolation\n      return;\n    }\n\n    // Freeze the object/array itself\n    // NOTE: This does NOT prevent Map/Set mutations!\n    Object.freeze(value);\n\n    // Handle Map - freeze keys and values (but Map itself remains mutable)\n    if (value instanceof Map) {\n      for (const [k, v] of value.entries()) {\n        freezeRecursive(k);\n        freezeRecursive(v);\n      }\n    }\n    // Handle Set - freeze items (but Set itself remains mutable)\n    else if (value instanceof Set) {\n      for (const item of value.values()) {\n        freezeRecursive(item);\n      }\n    }\n    // Handle Arrays and plain objects\n    else {\n      for (const prop of Object.getOwnPropertyNames(value)) {\n        freezeRecursive(value[prop]);\n      }\n    }\n  }\n\n  freezeRecursive(obj);\n  return obj;\n}\n\n/**\n * Restore game state from a snapshot.\n * The snapshot is cloned to ensure the original remains immutable.\n *\n * IMPORTANT: This function mutates existing gameState containers in place so any\n * references held by systems (e.g., const entities = gameState.entities) remain\n * valid after replay. Keys that no longer exist in the snapshot are removed,\n * and Maps/Sets/Arrays/objects are reconciled in place instead of being replaced.\n*/\nfunction restoreState(snapshot: StateSnapshot): void {\n  const mutableSnapshot = cloneDeep(snapshot); // Preserves graph aliasing\n  reconcileValue(gameState, mutableSnapshot, new WeakMap());\n}\n\nfunction reconcileValue(current: any, next: any, seen: WeakMap<object, any>): any {\n  if (!next || typeof next !== 'object') {\n    return next;\n  }\n\n  if (seen.has(next)) {\n    return seen.get(next);\n  }\n\n  if (next instanceof Map) {\n    const map = current instanceof Map ? current : new Map();\n    seen.set(next, map);\n\n    const existingEntries =\n      current instanceof Map ? Array.from(current.entries()) : [];\n    const matchedEntryIndices = new Set<number>();\n\n    map.clear();\n    for (const [key, value] of next.entries()) {\n      const existingEntry = findMatchingMapEntry(\n        existingEntries,\n        key,\n        matchedEntryIndices\n      );\n      const resolvedKey =\n        existingEntry !== undefined\n          ? existingEntry[0]\n          : reconcileValue(undefined, key, seen);\n      const resolvedValue = reconcileValue(\n        existingEntry?.[1],\n        value,\n        seen\n      );\n      map.set(resolvedKey, resolvedValue);\n    }\n    return map;\n  }\n\n  if (next instanceof Set) {\n    const set = current instanceof Set ? current : new Set();\n    seen.set(next, set);\n\n    const existingItems = current instanceof Set ? Array.from(current.values()) : [];\n    const matchedItemIndices = new Set<number>();\n\n    set.clear();\n    for (const item of next.values()) {\n      const existingItem = findMatchingSetItem(existingItems, item, matchedItemIndices);\n      const resolvedItem = reconcileValue(existingItem ?? undefined, item, seen);\n      set.add(resolvedItem);\n    }\n    return set;\n  }\n\n  if (Array.isArray(next)) {\n    const array = Array.isArray(current) ? current : [];\n    seen.set(next, array);\n    array.length = next.length;\n    for (let i = 0; i < next.length; i++) {\n      array[i] = reconcileValue(array[i], next[i], seen);\n    }\n    return array;\n  }\n\n  if (ArrayBuffer.isView(next)) {\n    const ctor = next.constructor as {\n      new(buffer: ArrayBufferLike): typeof next;\n    };\n    return new ctor(next);\n  }\n\n  // Note: The production implementation also treats immutable proxy snapshots\n  // generated by `deepFreezeInPlace` as ArrayBuffer views. It keeps a cache in\n  // the `seen` WeakMap so duplicate typed-array/DataView references in the\n  // snapshot resolve back to the exact same view instance, even when the proxy\n  // wrappers do not expose `.buffer`, `.length`, or other brand-checked accessors.\n  // When those accessors throw, the runtime falls back to copying byte data but\n  // still reuses the resolved view for every subsequent reference.\n\n  if (next instanceof Date) {\n    return new Date(next.getTime());\n  }\n\n  if (isPlainObject(next)) {\n    const target = isPlainObject(current) ? current : {};\n    seen.set(next, target);\n\n    for (const key of Object.keys(target)) {\n      if (!(key in next)) {\n        delete target[key];\n      }\n    }\n\n    for (const [key, value] of Object.entries(next)) {\n      target[key] = reconcileValue(target[key], value, seen);\n    }\n\n    return target;\n  }\n\n  // Fall back to structuredClone for rare structured types (RegExp, URL, etc.)\n  const clone = structuredClone(next);\n  if (typeof clone === 'object' && clone !== null) {\n    seen.set(next, clone);\n  }\n  return clone;\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, any> {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || proto === null;\n}\n\nfunction findMatchingMapEntry(\n  entries: Array<[any, any]>,\n  candidateKey: any,\n  matchedIndices: Set<number>\n): [any, any] | undefined {\n  for (let i = 0; i < entries.length; i++) {\n    if (matchedIndices.has(i)) {\n      continue;\n    }\n    const [existingKey] = entries[i];\n    if (\n      Object.is(existingKey, candidateKey) ||\n      payloadsMatch(existingKey, candidateKey)\n    ) {\n      matchedIndices.add(i);\n      return entries[i];\n    }\n  }\n  return undefined;\n}\n\nfunction findMatchingSetItem(\n  items: any[],\n  candidate: any,\n  matchedIndices: Set<number>\n): any | undefined {\n  for (let i = 0; i < items.length; i++) {\n    if (matchedIndices.has(i)) {\n      continue;\n    }\n    const existing = items[i];\n    if (Object.is(existing, candidate) || payloadsMatch(existing, candidate)) {\n      matchedIndices.add(i);\n      return existing;\n    }\n  }\n  return undefined;\n}\n\n"})}),"\n",(0,s.jsx)(n.h4,{id:"supporting-utilities",children:"Supporting Utilities"}),"\n",(0,s.jsx)(n.p,{children:"Several helper modules are assumed in the pseudocode above. They must exist (or be stubbed) before the queue work ships:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"telemetry"})," facade"]}),": Provides ",(0,s.jsx)(n.code,{children:"recordError(event, data)"}),", ",(0,s.jsx)(n.code,{children:"recordWarning(event, data)"}),", ",(0,s.jsx)(n.code,{children:"recordProgress(event, data)"}),", and ",(0,s.jsx)(n.code,{children:"recordTick()"}),"; all methods must be fire-and-forget and safe in worker, browser, and Node test environments. If a provided facade throws, the default wrapper logs the failure via ",(0,s.jsx)(n.code,{children:"console.error"})," to avoid cascading crashes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monotonic clock"}),": ",(0,s.jsx)(n.code,{children:"createMonotonicClock()"})," wraps ",(0,s.jsx)(n.code,{children:"performance.now()"})," but guarantees strictly increasing values even if the host clock stalls. In Node, import ",(0,s.jsx)(n.code,{children:"performance"})," from ",(0,s.jsx)(n.code,{children:"perf_hooks"})," so replay/tests run without polyfills."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deterministic RNG hooks"}),": ",(0,s.jsx)(n.code,{children:"getCurrentRNGSeed(): number | undefined"}),", ",(0,s.jsx)(n.code,{children:"setRNGSeed(seed: number): void"}),", and ",(0,s.jsx)(n.code,{children:"seededRandom(): number"})," live in the runtime RNG module. Command handlers that rely on randomness must consume ",(0,s.jsx)(n.code,{children:"seededRandom()"}),"; direct ",(0,s.jsx)(n.code,{children:"Math.random()"})," usage is prohibited once the queue lands."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"structuredClone"})," availability"]}),": Browser runtimes already expose it; Node tests must run on a version that includes the API or ship a ponyfill with equivalent semantics."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The reconciliation logic deliberately keeps previously shared references alive. For example, if a system cached ",(0,s.jsx)(n.code,{children:"const entities = gameState.entities"}),", that Map instance survives replay; each entry is reconciled in place so cached entity objects continue to reference the same containers after restoration. The ",(0,s.jsx)(n.code,{children:"WeakMap"})," registry ensures every object from the snapshot maps back to exactly one runtime object, so cycles and cross-links are recreated faithfully. This protects long-lived references inside the runtime while still guaranteeing the restored state matches the recorded snapshot exactly."]}),"\n",(0,s.jsx)(n.p,{children:"The replay sandbox guarantees that log-driven execution never leaks additional\ncommands into the live runtime. Any handler that attempts to enqueue during\nreplay indicates the log is missing an entry; the method emits telemetry and\nthrows immediately so the bad capture cannot advance unnoticed."}),"\n",(0,s.jsxs)(n.p,{children:["When a ",(0,s.jsx)(n.code,{children:"RuntimeReplayContext"})," is supplied, the recorder snapshots the current\n",(0,s.jsx)(n.code,{children:"currentStep"}),"/",(0,s.jsx)(n.code,{children:"nextExecutableStep"})," values, runs the replay, and then sets both\ncounters to ",(0,s.jsx)(n.code,{children:"log.metadata.lastStep + 1"})," so the live runtime resumes from the\ncorrect tick. If the replay aborts early, the original counter values are\nrestored to avoid leaving the runtime in a mismatched state."]}),"\n",(0,s.jsx)(n.h3,{id:"83-deterministic-replay-guarantees",children:"8.3 Deterministic Replay Guarantees"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Critical Design Decisions"}),": The replay implementation addresses three determinism requirements:"]}),"\n",(0,s.jsx)(n.h4,{id:"1-step-counter-preservation",children:"1. Step Counter Preservation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Commands must preserve the execution tick they target. Multiple commands executed within the same tick must all see the same ",(0,s.jsx)(n.code,{children:"ctx.step"})," value, both during live play and replay."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example Failure"})," (incorrect approach with auto-increment):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Handler that gates behavior per step\n// resources: ResourceState captured from runtime setup\nconst applyProductionHandler = (payload, ctx: ExecutionContext) => {\n  // Only apply once per step (prevent double-application)\n  if (lastProductionStep === ctx.step) return;\n  lastProductionStep = ctx.step;\n\n  const energyIndex = resources.requireIndex('energy');\n  resources.addAmount(energyIndex, payload.amount);\n};\n\n// Live play tick 100: cmd1.step=100, cmd2.step=100, cmd3.step=100\n// All three commands see ctx.step=100 (same tick)\n\n// Replay with auto-increment: cmd1\u2192ctx.step=0, cmd2\u2192ctx.step=1, cmd3\u2192ctx.step=2\n// Each command sees different step! Handler logic diverges\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Each ",(0,s.jsx)(n.code,{children:"Command"})," includes a ",(0,s.jsx)(n.code,{children:"step"})," field storing the simulation step that will execute it"]}),"\n",(0,s.jsxs)(n.li,{children:["During live play: systems stamp ",(0,s.jsx)(n.code,{children:"context.step + 1"})," and the Worker stamps ",(0,s.jsx)(n.code,{children:"nextExecutableStep"})]}),"\n",(0,s.jsxs)(n.li,{children:["During live execution: ",(0,s.jsx)(n.code,{children:"CommandDispatcher.execute()"})," feeds ",(0,s.jsx)(n.code,{children:"cmd.step"})," into the handler context"]}),"\n",(0,s.jsxs)(n.li,{children:["During replay: ",(0,s.jsx)(n.code,{children:"CommandRecorder.replay()"})," uses ",(0,s.jsx)(n.code,{children:"cmd.step"})," directly for ",(0,s.jsx)(n.code,{children:"ctx.step"})]}),"\n",(0,s.jsxs)(n.li,{children:["This ensures all commands executed on tick N see ",(0,s.jsx)(n.code,{children:"ctx.step = N"})," in both live play and replay"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"2-recording-loop-prevention",children:"2. Recording Loop Prevention"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Recommended pattern ",(0,s.jsx)(n.code,{children:"dispatcher.on('commandExecuted', (cmd) => recorder.record(cmd))"})," causes every replayed command to be recorded again because the subscription remains active during replay."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example Failure"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Setup (live play)\ndispatcher.on('commandExecuted', (cmd) => sessionRecorder.record(cmd));\n\n// Export log with 100 commands\nconst log = sessionRecorder.export(); // commands: [cmd1, cmd2, ..., cmd100]\n\n// Replay with same dispatcher\nsessionRecorder.replay(log, dispatcher);\n// Replays cmd1 \u2192 dispatcher fires 'commandExecuted' \u2192 recorder.record(cmd1) AGAIN\n// Result: sessionRecorder.recorded now has 200 commands (100 original + 100 duplicates)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CommandRecorder.replay()"})," calls handlers ",(0,s.jsx)(n.strong,{children:"directly"})," via ",(0,s.jsx)(n.code,{children:"dispatcher.getHandler()"}),", bypassing event system"]}),"\n",(0,s.jsxs)(n.li,{children:["Replay temporarily swaps ",(0,s.jsx)(n.code,{children:"commandQueue.enqueue"})," with a sandbox that records attempted follow-up commands; each queued command is matched against the remaining log entries so the tool can surface telemetry and fail fast when the capture is incomplete or divergent"]}),"\n",(0,s.jsxs)(n.li,{children:["When no runtime context is provided, replay still captures follow-up enqueues by routing them through a fresh, isolated ",(0,s.jsx)(n.code,{children:"CommandQueue"}),", so tests and tooling remain decoupled from the live runtime"]}),"\n",(0,s.jsxs)(n.li,{children:["Missing handlers are surfaced via ",(0,s.jsx)(n.code,{children:"telemetry.recordError('ReplayUnknownCommandType', \u2026)"})," so replay drift cannot go unnoticed"]}),"\n",(0,s.jsx)(n.li,{children:"Alternatively: use separate replay-only dispatcher with no recording subscriptions"}),"\n",(0,s.jsx)(n.li,{children:"Documentation updated to show both patterns"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"3-rng-seed-restoration",children:"3. RNG Seed Restoration"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Without capturing and restoring the active RNG seed, handlers that rely on randomness diverge between live play and replay."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example Failure"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Handler with random drop chance\nconst enemyDropHandler = (payload, ctx) => {\n  if (Math.random() < 0.1) { // 10% drop chance\n    gameState.inventory.push({ item: 'rare_gem' });\n  }\n};\n\n// Live play (seed=42): Math.random() = 0.05 \u2192 drop succeeds\n// Replay (seed not restored): Math.random() = 0.87 \u2192 drop fails\n// Result: Different final state\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CommandRecorder"})," snapshots the current RNG seed at construction/export time (or accepts an explicit override) so ",(0,s.jsx)(n.code,{children:"log.metadata.seed"})," is always populated"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CommandRecorder.replay()"})," checks ",(0,s.jsx)(n.code,{children:"log.metadata.seed"})," and calls ",(0,s.jsx)(n.code,{children:"setRNGSeed(seed)"})," before executing commands"]}),"\n",(0,s.jsxs)(n.li,{children:["Handlers ",(0,s.jsx)(n.strong,{children:"must"})," use ",(0,s.jsx)(n.code,{children:"seededRandom()"})," instead of ",(0,s.jsx)(n.code,{children:"Math.random()"})," for determinism"]}),"\n",(0,s.jsx)(n.li,{children:"Alternative: restrict handlers to pure deterministic logic only (no randomness)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"84-freezeclonerestore-lifecycle",children:"8.4 Freeze/Clone/Restore Lifecycle"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Insight"}),': We separate "freezing for safety" from "cloning for replay". ',(0,s.jsx)(n.code,{children:"deepFreezeInPlace()"})," wraps Maps/Sets/TypedArrays in guard proxies that throw on mutation while still presenting structured-clone-compatible views, so snapshots stay immutable yet cloneable."]}),"\n",(0,s.jsx)(n.h4,{id:"lifecycle-stages",children:"Lifecycle Stages"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Recording Start (Constructor)"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"constructor(currentState: GameState, options?: { seed?: number }) {\n  this.startState = cloneDeep(currentState); // Clone to isolate from live state\n  deepFreezeInPlace(this.startState);        // Wrap in immutable guard proxies\n  this.rngSeed = options?.seed ?? getCurrentRNGSeed?.();\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clone first"}),": ",(0,s.jsx)(n.code,{children:"structuredClone()"})," creates independent copy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Freeze second"}),": ",(0,s.jsx)(n.code,{children:"deepFreezeInPlace()"})," guards all nested collections/arrays"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": ",(0,s.jsx)(n.code,{children:"this.startState"})," is frozen but still cloneable through the guard proxies"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Export (Creating Command Log)"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export(): CommandLog {\n  const exportedLog = {\n    startState: cloneDeep(this.startState), // Clone the frozen snapshot\n    commands: [...this.recorded],\n    metadata: {\n      recordedAt: Date.now(),\n      seed: this.rngSeed\n    }\n  };\n\n  deepFreezeInPlace(exportedLog); // Freeze the exported log via guard proxies\n  return exportedLog;\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clone"}),": ",(0,s.jsx)(n.code,{children:"structuredClone()"})," clones the wrapped snapshots without mutating the live state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Freeze"}),": Guard proxies reject external mutation attempts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": Multiple exports are independent, immutable snapshots"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Replay (Restoring State)"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"replay(log: CommandLog, dispatcher: CommandDispatcher): void {\n  const mutableState = cloneDeep(log.startState); // Clone frozen snapshot\n  restoreState(mutableState);                     // Apply to game state\n\n  // Re-execute commands using their original step values\n  for (const cmd of log.commands) {\n    const handler = dispatcher.getHandler(cmd.type);\n    if (!handler) {\n      telemetry.recordError('ReplayUnknownCommandType', {\n        type: cmd.type,\n        step: cmd.step\n      });\n      continue;\n    }\n\n    handler(cmd.payload, {\n      step: cmd.step, // Use stored step from command\n      timestamp: cmd.timestamp,\n      priority: cmd.priority\n    });\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clone"}),": Create mutable working copy from frozen snapshot"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Restore"}),": Copy into live ",(0,s.jsx)(n.code,{children:"gameState"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Execute"}),": Commands mutate the restored state using their original step values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": Replay produces identical final state as original session"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"why-this-works",children:"Why This Works"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cloning is the Primary Defense"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"structuredClone()"})," creates completely independent copies"]}),"\n",(0,s.jsx)(n.li,{children:"Mutating a clone never affects the original"}),"\n",(0,s.jsx)(n.li,{children:"Each snapshot lives in its own memory space"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Freezing is Secondary Protection"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"deepFreezeInPlace()"})," walks the snapshot and returns a read-only graph"]}),"\n",(0,s.jsxs)(n.li,{children:["Plain objects/arrays are cloned and ",(0,s.jsx)(n.code,{children:"Object.freeze()"})," is applied"]}),"\n",(0,s.jsxs)(n.li,{children:["Map/Set/Date/TypedArray instances are wrapped in proxies whose mutators (",(0,s.jsx)(n.code,{children:"set"}),", ",(0,s.jsx)(n.code,{children:"add"}),", ",(0,s.jsx)(n.code,{children:"setFullYear"}),", ",(0,s.jsx)(n.code,{children:"copyWithin"}),", ",(0,s.jsx)(n.code,{children:"subarray"}),", etc.) throw ",(0,s.jsx)(n.code,{children:"TypeError"})]}),"\n",(0,s.jsxs)(n.li,{children:["Typed array ",(0,s.jsx)(n.code,{children:"buffer"})," accessors surface immutable buffer snapshots that only hand out cloned copies, and standalone ",(0,s.jsx)(n.code,{children:"ArrayBuffer"}),"/",(0,s.jsx)(n.code,{children:"SharedArrayBuffer"})," payloads are wrapped in the same facades so the live runtime memory is never directly exposed. The ",(0,s.jsx)(n.code,{children:"ImmutableTypedArraySnapshot"})," TypeScript surface removes mutating helpers and narrows ",(0,s.jsx)(n.code,{children:".buffer"})," to those immutable facades so call sites must explicitly request writable copies before mutating."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RegExp"})," payloads are rehydrated via ",(0,s.jsx)(n.code,{children:"new RegExp(source, flags)"})," so ",(0,s.jsx)(n.code,{children:".exec()"}),"/",(0,s.jsx)(n.code,{children:".test()"})," continue to behave like native instances without sharing mutable references"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Immutable Collections Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const payload = deepFreezeInPlace({\n  map: new Map([['a', { value: 1 }]]),\n  set: new Set([1, 2]),\n  date: new Date('2025-01-01T00:00:00.000Z'),\n  typed: new Uint8Array([5, 6]),\n});\n\n// Mutations throw in development/test builds\nexpect(() => payload.map.set('b', 2)).toThrow(TypeError);\nexpect(() => (payload.map.get('a') as { value: number }).value = 2).toThrow(TypeError);\nexpect(() => payload.set.add(3)).toThrow(TypeError);\nexpect(() => payload.date.setFullYear(2030)).toThrow(TypeError);\nexpect(() => {\n  payload.typed[0] = 9;\n}).toThrow(TypeError);\nexpect(() => payload.typed.set([7], 1)).toThrow(TypeError);\n\n// Derived views remain immutable\nconst subView = payload.typed.subarray(0, 1);\nexpect(() => {\n  subView[0] = 42;\n}).toThrow(TypeError);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Buffer Snapshot Facade"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const command = deepFreezeInPlace({\n  buffer: new ArrayBuffer(4),\n});\n\nconst immutable = command.buffer; // \u2192 ImmutableArrayBufferSnapshot\n\n// Read accessors always return fresh copies\nconst copy = immutable.toUint8Array();\ncopy[0] = 99; // Safe - mutating the copy leaves the snapshot intact\n\n// Attempting to obtain a writable view requires opting into a copy first\nconst runtimeBuffer = immutable.toArrayBuffer(); // New ArrayBuffer instance\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Shared memory snapshots use the same pattern via ",(0,s.jsx)(n.code,{children:"ImmutableSharedArrayBufferSnapshot"}),", ensuring readers must copy before mutating while preserving the original contents for deterministic replay."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Defense Strategy"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isolation via cloning"}),": Snapshots are independent (always works)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Immutable snapshots"}),": ",(0,s.jsx)(n.code,{children:"deepFreezeInPlace()"})," always returns read-only graphs whose mutation attempts surface as ",(0,s.jsx)(n.code,{children:"TypeError"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deterministic APIs"}),": ArrayBuffer snapshots require explicit copy helpers, producing identical behavior in development and production"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Clone-Freeze-Clone Pattern"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Live State \u2192 Clone \u2192 Freeze \u2192 Store (recorder.startState)\n                                  \u2193\n                               Clone \u2192 Freeze \u2192 Export (log)\n                                  \u2193\n                               Clone \u2192 Restore \u2192 Replay (mutable state)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Each step maintains:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isolation"}),": Clones are independent (via ",(0,s.jsx)(n.code,{children:"structuredClone()"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Development immutability"}),": ",(0,s.jsx)(n.code,{children:"deepFreezeInPlace()"})," injects read-only guards for Map/Set/Date/TypedArray during dev/test to surface accidental mutations early"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Production cloneability"}),": Release builds omit the proxy layer, keeping snapshots plain-data and ",(0,s.jsx)(n.code,{children:"structuredClone()"})," compatible for recording/replay"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"State Serialization Constraints"}),":"]}),"\n",(0,s.jsxs)(n.p,{children:["For deterministic replay to work, game state must be ",(0,s.jsxs)(n.strong,{children:["cloneable via ",(0,s.jsx)(n.code,{children:"structuredClone()"})]}),". Freezing provides additional safety for plain objects/arrays only."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Supported Types"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plain objects and arrays"})," (cloneable + freezable)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primitives"})," (string, number, boolean, null, undefined)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Date objects"})," (cloneable + mutation-guarded proxies in development)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Map and Set collections"})," (cloneable + mutation-guarded proxies in development)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Typed arrays"})," (Uint8Array, etc.) (cloneable + mutation-guarded proxies for values and subviews in development)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ArrayBuffer / SharedArrayBuffer"})," (snapshots expose immutable facades that provide explicit copy helpers without leaking the live runtime buffers)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RegExp"})," (cloned with ",(0,s.jsx)(n.code,{children:"source"}),"/",(0,s.jsx)(n.code,{children:"flags"})," and ",(0,s.jsx)(n.code,{children:"lastIndex"})," preserved so replay stays deterministic)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cyclic references"})," (handled by ",(0,s.jsx)(n.code,{children:"structuredClone()"})," and ",(0,s.jsx)(n.code,{children:"deepFreezeInPlace()"}),")"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Unsupported Types"})," (will cause cloning failures):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Functions (behavior lost during clone)"}),"\n",(0,s.jsx)(n.li,{children:"DOM nodes (not cloneable)"}),"\n",(0,s.jsx)(n.li,{children:"WeakMap/WeakSet (not cloneable)"}),"\n",(0,s.jsx)(n.li,{children:"Symbols as property keys (not cloned)"}),"\n",(0,s.jsx)(n.li,{children:"Class instances with private fields (lost during clone)"}),"\n",(0,s.jsx)(n.li,{children:"Proxies (throws DataCloneError)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Best Practices"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// \u2713 GOOD: Plain data structures\ninterface GameState {\n  resources: Record<string, number>;\n  generators: Map<string, GeneratorState>;\n  unlocks: Set<string>;\n  timestamp: Date;\n}\n\n// \u2717 AVOID: Functions and class instances\ninterface BadGameState {\n  calculateProduction: () => number; // Lost during clone\n  ui: HTMLElement; // Not serializable\n  cache: WeakMap<object, any>; // Not cloneable\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cyclic State Handling"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Cycles are safe for freezing (WeakMap caches preserve referential identity)\nconst parent = { children: [] };\nconst child = { parent };\nparent.children.push(child);\n\ndeepFreezeInPlace(parent); // Works correctly with cycle tracking\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Map/Set/TypedArray Handling"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const state = deepFreezeInPlace({\n  items: new Map([['a', { value: 1 }]]),\n  ids: new Set(['x', 'y']),\n  buffer: new Uint8Array([1, 2, 3]),\n});\n\nexpect(() => state.items.set('b', 2)).toThrow(TypeError);\nexpect(() => state.ids.add('z')).toThrow(TypeError);\nexpect(() => {\n  state.buffer[0] = 99;\n}).toThrow(TypeError);\nexpect(() => state.buffer.set([7], 1)).toThrow(TypeError);\n\nconst sub = state.buffer.subarray(0, 1);\nexpect(() => {\n  sub[0] = 42;\n}).toThrow(TypeError);\n\n// Nested data remains deeply frozen\nexpect(() => (state.items.get('a') as { value: number }).value = 2).toThrow(TypeError);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important"}),": Development and test builds surface incorrect mutations immediately via the proxy layer. Production builds still rely on cloning for isolation (the snapshot handed to the queue is a unique copy), but skip proxy creation to stay within the tick budget."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Each ",(0,s.jsx)(n.code,{children:"export()"})," clones the frozen snapshot before serialisation"]}),"\n",(0,s.jsxs)(n.li,{children:["Each ",(0,s.jsx)(n.code,{children:"replay()"})," clones the stored snapshot before mutating anything"]}),"\n",(0,s.jsxs)(n.li,{children:["Proxy guards block escape hatches such as ",(0,s.jsx)(n.code,{children:"valueOf()"})," so callers cannot peel back the immutable wrappers and reach the mutable backing instances"]}),"\n",(0,s.jsx)(n.li,{children:"Mutations always target a clone, never the source snapshot"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This enables:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deterministic testing"}),": Record player session, replay in CI to verify no regressions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bug reproduction"}),": Export command log from user session, replay locally to debug"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Balance tuning"}),": Simulate strategies by crafting command sequences"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"9-performance-considerations",children:"9. Performance Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"91-queue-capacity-limits",children:"9.1 Queue Capacity Limits"}),"\n",(0,s.jsx)(n.p,{children:"To prevent memory leaks from runaway automation or attack scenarios:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const MAX_QUEUE_SIZE = 10000; // Configurable per deployment\n\nenqueue(command: Command): void {\n  if (this.size >= MAX_QUEUE_SIZE) {\n    telemetry.recordWarning('CommandQueueOverflow', {\n      size: this.size,\n      maxSize: MAX_QUEUE_SIZE,\n      priority: command.priority\n    });\n    // Only evict commands at priorities <= the incoming request\n    const dropped = this.dropLowestPriorityUpTo(command.priority);\n    if (!dropped) {\n      telemetry.recordWarning('CommandRejected', {\n        type: command.type,\n        priority: command.priority,\n        timestamp: command.timestamp\n      });\n      return;\n    }\n  }\n  // ... proceed with enqueue\n}\n\nprivate dropLowestPriorityUpTo(maxPriority: CommandPriority): boolean {\n  for (const priority of [...CommandQueue.PRIORITY_ORDER].reverse()) {\n    if (priority < maxPriority) {\n      continue;\n    }\n    const queue = this.queues.get(priority);\n    if (!queue || queue.length === 0) {\n      continue;\n    }\n\n    const dropped = queue.shift(); // Remove oldest command in lowest-priority lane\n    if (dropped) {\n      this.totalSize--;\n    }\n    telemetry.recordWarning('CommandDropped', {\n      type: dropped!.command.type,\n      priority,\n      timestamp: dropped!.command.timestamp\n    });\n    return true;\n  }\n  return false;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This strategy removes the oldest command from the lowest-priority lane at or\nbelow the incoming priority, preserving deterministic behavior while keeping\nhigher-priority queues intact. If no eligible command can be evicted the\nincoming enqueue is rejected and surfaced via ",(0,s.jsx)(n.code,{children:"CommandRejected"})," telemetry, which\nlets orchestration layers detect starvation scenarios. Each eviction still emits\n",(0,s.jsx)(n.code,{children:"CommandDropped"})," with enough metadata to trace automation or attack patterns\nthat saturate the queue. Because the queue maintains a running ",(0,s.jsx)(n.code,{children:"totalSize"}),"\ncounter (see Section 4.2), the overflow check stays O(1) regardless of how many\ncommands are currently buffered."]}),"\n",(0,s.jsx)(n.h3,{id:"92-batch-processing-optimization",children:"9.2 Batch Processing Optimization"}),"\n",(0,s.jsx)(n.p,{children:"When replaying large command logs (e.g., 12-hour offline catch-up):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Process commands in batches to allow instrumentation\nconst BATCH_SIZE = 1000;\n\nfor (let i = 0; i < log.commands.length; i += BATCH_SIZE) {\n  const batch = log.commands.slice(i, i + BATCH_SIZE);\n  for (const cmd of batch) {\n    dispatcher.execute(cmd); // Use dispatcher to ensure consistent execution\n  }\n  telemetry.recordProgress('CommandReplay', { processed: i });\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"93-memory-footprint",children:"9.3 Memory Footprint"}),"\n",(0,s.jsx)(n.p,{children:"Typical command memory profile:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Command object: ~80 bytes (type string, priority enum, timestamp number, payload reference)"}),"\n",(0,s.jsx)(n.li,{children:"Average payload: ~200 bytes (resource IDs, counts, flags)"}),"\n",(0,s.jsx)(n.li,{children:"10,000 queued commands \u2248 2.8 MB (within 5 MB runtime budget)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"10-error-handling",children:"10. Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"101-invalid-command-rejection",children:"10.1 Invalid Command Rejection"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"execute(command: Command): void {\n  const handler = this.handlers.get(command.type);\n\n  if (!handler) {\n    telemetry.recordError('UnknownCommandType', { type: command.type });\n    return; // Fail silently to avoid breaking tick loop\n  }\n\n  const executionContext = {\n    step: command.step, // Use command's step for deterministic replay\n    timestamp: command.timestamp,\n    priority: command.priority\n  };\n\n  try {\n    handler(command.payload, executionContext);\n  } catch (err) {\n    telemetry.recordError('CommandExecutionFailed', {\n      type: command.type,\n      error: err instanceof Error ? err.message : String(err)\n    });\n    // Continue processing remaining commands\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"102-validation-before-enqueue",children:"10.2 Validation Before Enqueue"}),"\n",(0,s.jsxs)(n.p,{children:["The presentation layer performs optimistic validation before sending commands. UI code works against the latest ",(0,s.jsx)(n.code,{children:"ResourceStateSnapshot"})," rebuilt from the worker's ",(0,s.jsx)(n.code,{children:"ResourcePublishTransport"})," payload:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// In React hook\nconst resourceIndexById = useMemo(() => {\n  return new Map(resources.ids.map((id, index) => [id, index]));\n}, [resources.ids]);\n\nconst canAffordGenerator = (cost: number) => {\n  const energyIndex = resourceIndexById.get('energy');\n  return energyIndex !== undefined && resources.amounts[energyIndex] >= cost;\n};\n\nconst buyGenerator = (payload: PurchaseGeneratorPayload) => {\n  const generator = registry.getGenerator(payload.generatorId);\n  const totalCost = generator.cost * payload.count;\n\n  if (!canAffordGenerator(totalCost)) {\n    showError('Insufficient resources');\n    return; // Don't enqueue invalid command\n  }\n\n  workerBridge.sendCommand('PURCHASE_GENERATOR', payload);\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"The runtime performs authoritative validation during execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// In command handler\nconst purchaseGeneratorHandler: CommandHandler<PurchaseGeneratorPayload> = (\n  payload,\n  ctx,\n) => {\n  const generator = registry.getGenerator(payload.generatorId);\n  const totalCost = generator.cost * payload.count;\n  const energyIndex = resources.requireIndex('energy');\n\n  const spendSucceeded = resources.spendAmount(energyIndex, totalCost, {\n    commandId: 'PURCHASE_GENERATOR',\n    systemId:\n      ctx.priority === CommandPriority.AUTOMATION ? 'auto-buy' : undefined,\n  });\n\n  if (!spendSucceeded) {\n    telemetry.recordWarning('InsufficientResources', {\n      generatorId: payload.generatorId,\n      cost: totalCost,\n      priority: ctx.priority,\n      step: ctx.step,\n    });\n    return; // Command rejected, no state mutation\n  }\n\n  generator.owned += payload.count;\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"11-testing-strategy",children:"11. Testing Strategy"}),"\n",(0,s.jsx)(n.h3,{id:"111-unit-tests",children:"11.1 Unit Tests"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"describe('CommandQueue', () => {\n  it('executes commands in priority order', () => {\n    queue.enqueue({\n      type: 'AUTO',\n      priority: CommandPriority.AUTOMATION,\n      payload: {},\n      timestamp: 100,\n      step: 0\n    });\n    queue.enqueue({\n      type: 'PLAYER',\n      priority: CommandPriority.PLAYER,\n      payload: {},\n      timestamp: 100,\n      step: 0\n    });\n    queue.enqueue({\n      type: 'SYSTEM',\n      priority: CommandPriority.SYSTEM,\n      payload: {},\n      timestamp: 100,\n      step: 0\n    });\n\n    const commands = queue.dequeueAll();\n    expect(commands[0].type).toBe('SYSTEM');\n    expect(commands[1].type).toBe('PLAYER');\n    expect(commands[2].type).toBe('AUTO');\n  });\n\n  it('maintains FIFO order within same priority', () => {\n    queue.enqueue({\n      type: 'CMD1',\n      priority: CommandPriority.PLAYER,\n      payload: {},\n      timestamp: 100,\n      step: 0\n    });\n    queue.enqueue({\n      type: 'CMD2',\n      priority: CommandPriority.PLAYER,\n      payload: {},\n      timestamp: 200,\n      step: 0\n    });\n\n    const commands = queue.dequeueAll();\n    expect(commands[0].timestamp).toBe(100);\n    expect(commands[1].timestamp).toBe(200);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"112-integration-tests",children:"11.2 Integration Tests"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"describe('Command Execution', () => {\n  it('applies resource mutations correctly', () => {\n    const state = createTestState({ energy: 100 });\n    const dispatcher = createDispatcher(state);\n\n    dispatcher.execute({\n      type: 'PURCHASE_GENERATOR',\n      payload: { generatorId: 'reactor', count: 1 },\n      priority: CommandPriority.PLAYER,\n      timestamp: 0,\n      step: 0\n    });\n\n    expect(state.resources.energy).toBe(90); // Cost 10\n    expect(state.generators.reactor.owned).toBe(1);\n  });\n\n  it('rejects invalid commands gracefully', () => {\n    const state = createTestState({ energy: 5 });\n    const dispatcher = createDispatcher(state);\n\n    dispatcher.execute({\n      type: 'PURCHASE_GENERATOR',\n      payload: { generatorId: 'reactor', count: 1 }, // Cost 10, insufficient\n      priority: CommandPriority.PLAYER,\n      timestamp: 0,\n      step: 0\n    });\n\n    expect(state.resources.energy).toBe(5); // No mutation\n    expect(state.generators.reactor.owned).toBe(0);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"113-replay-tests",children:"11.3 Replay Tests"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"describe('Command Replay', () => {\n  it('reproduces identical state from command log', () => {\n    const initialState = createInitialState();\n    const recorder = new CommandRecorder(initialState); // Snapshot at start\n\n    // Simulate player session (mutates initialState)\n    const dispatcher = createDispatcher(initialState);\n    runSimulation(initialState, recorder, dispatcher);\n    const finalStateOriginal = cloneDeep(initialState);\n\n    // Export and replay\n    const log = recorder.export();\n    const replayDispatcher = createDispatcher();\n    recorder.replay(log, replayDispatcher);\n    const replayedState = replayDispatcher.getState();\n\n    expect(replayedState).toEqual(finalStateOriginal);\n  });\n\n  it('exported logs are immutable', () => {\n    const initialState = createInitialState();\n    const recorder = new CommandRecorder(initialState);\n\n    recorder.record({\n      type: 'TEST_CMD',\n      priority: CommandPriority.PLAYER,\n      payload: { value: 1 },\n      timestamp: 0,\n      step: 0\n    });\n\n    const log1 = recorder.export();\n\n    // Record more commands after export\n    recorder.record({\n      type: 'TEST_CMD_2',\n      priority: CommandPriority.PLAYER,\n      payload: { value: 2 },\n      timestamp: 1,\n      step: 1\n    });\n\n    const log2 = recorder.export();\n\n    // First export should be unaffected\n    expect(log1.commands.length).toBe(1);\n    expect(log2.commands.length).toBe(2);\n\n    // Logs should be frozen\n    expect(() => {\n      (log1 as any).commands.push({ /* ... */ });\n    }).toThrow();\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"12-implementation-plan",children:"12. Implementation Plan"}),"\n",(0,s.jsx)(n.p,{children:"The command queue implementation follows this sequence (aligned with Phase 1 - Runtime Skeleton):"}),"\n",(0,s.jsx)(n.h3,{id:"121-week-1-tasks",children:"12.1 Week 1 Tasks"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"CommandQueue"})," data structure with priority lanes"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"CommandDispatcher"})," with handler registration"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Add command types and payload interfaces for resource operations"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Write unit tests for queue ordering and priority resolution (",(0,s.jsx)(n.code,{children:"packages/core/src/command-queue.test.ts:553"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"122-week-2-tasks",children:"12.2 Week 2 Tasks"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Integrate command queue into tick loop (update ",(0,s.jsx)(n.code,{children:"IdleEngineRuntime"}),")"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement command handlers for purchase/toggle operations"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Add Worker bridge message handler for incoming commands"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Write integration tests for end-to-end command flow (",(0,s.jsx)(n.code,{children:"packages/core/src/index.test.ts:193"}),", ",(0,s.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.test.ts:136"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"123-week-3-tasks",children:"12.3 Week 3 Tasks"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"CommandRecorder"})," for debugging/replay"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Add validation layer with error handling"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement queue capacity limits and overflow handling"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Document command API contracts for content modules"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"13-success-criteria",children:"13. Success Criteria"}),"\n",(0,s.jsx)(n.p,{children:"The command queue is complete when:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Determinism"}),": Replaying a command log produces identical final state (verified by property tests)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Priority"}),": Commands execute in correct priority order across 1000+ enqueued commands (benchmark)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Command processing overhead stays under 5% of the tick budget at 60 ticks/sec (profiled)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration"}),": React shell can enqueue commands, runtime executes them, state updates reflected in UI (E2E test)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Observability"}),": Command queue depth and execution metrics exposed via diagnostics interface"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"14-future-enhancements-post-prototype",children:"14. Future Enhancements (Post-Prototype)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conditional Commands"}),': Commands that execute only when predicates are met (e.g., "buy when resource >= threshold")']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Macro Commands"}),": Composite commands for complex multi-step actions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Sync"}),": Serialize command stream for multiplayer synchronization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rollback"}),": Store command checkpoints for efficient undo/redo"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compression"}),": Delta-encode command logs for reduced storage/bandwidth"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"15-resolved-decisions",children:"15. Resolved Decisions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automation throttling"}),": No per-tick throttle in the initial release. We rely on ",(0,s.jsx)(n.code,{children:"MAX_QUEUE_SIZE"}),", per-priority depth telemetry, and ",(0,s.jsx)(n.code,{children:"CommandQueueOverflow"}),"/",(0,s.jsx)(n.code,{children:"CommandDropped"})," signals to surface runaway automation. If telemetry shows chronic starvation, we will introduce targeted throttles as a follow-up enhancement."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Command conflicts"}),": Handlers must revalidate state at execution time and gracefully no-op when their preconditions are invalidated (emitting ",(0,s.jsx)(n.code,{children:"telemetry.recordWarning('CommandConflict', \u2026)"}),"). Destructive operations such as prestige reset must flush or invalidate dependent state via their handlers; the queue itself remains FIFO and does not perform speculative reordering."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiple RNG streams"}),": Yes. Each subsystem that owns an independent PRNG must register with the runtime RNG module so the recorder can capture and restore every active seed. The RNG helper will expose ",(0,s.jsx)(n.code,{children:"registerRNGStream(id, getSeed, setSeed)"})," to supplement the existing global seed capture."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"16-references",children:"16. References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://gameprogrammingpatterns.com/command.html",children:"Game Programming Patterns: Command"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://gameprogrammingpatterns.com/event-queue.html",children:"Game Programming Patterns: Event Queue"})}),"\n",(0,s.jsx)(n.li,{children:"Idle Engine Design Document (Section 9.1 - Tick Pseudocode)"}),"\n",(0,s.jsx)(n.li,{children:"Implementation Plan (Section 4 - Runtime Core Tasks)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"appendix-a--2025-10-11-update-summary",children:"Appendix A \u2013 2025-10-11 Update Summary"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Added accumulator diagnostics coverage for clamp debt, deterministic drain, and fractional cadence precision (",(0,s.jsx)(n.code,{children:"packages/core/src/index.test.ts:336"}),", ",(0,s.jsx)(n.code,{children:"packages/core/src/index.test.ts:370"}),", ",(0,s.jsx)(n.code,{children:"packages/core/src/index.test.ts:480"}),"). See ",(0,s.jsx)(n.code,{children:"docs/tick-accumulator-coverage-design.md"})," \xa7\xa75.1\u20135.3 for the scenarios and backlog expectations\u2014the diagnostics metadata must surface the remaining accumulator debt while queue counters stay at zero so devtools timelines remain reliable."]}),"\n",(0,s.jsxs)(n.li,{children:["Documented system execution order, error handling, and deferred enqueue behaviour via new runtime tests; exceptions now log ",(0,s.jsx)(n.code,{children:"SystemExecutionFailed"})," telemetry instead of stopping the tick (",(0,s.jsx)(n.code,{children:"packages/core/src/index.ts:120"}),", ",(0,s.jsx)(n.code,{children:"packages/core/src/index.test.ts:210"}),", ",(0,s.jsx)(n.code,{children:"packages/core/src/index.test.ts:252"}),", ",(0,s.jsx)(n.code,{children:"packages/core/src/index.test.ts:293"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Strengthened priority guarantees by mixing command priorities inside runtime ticks and capturing queue boundary scenarios (",(0,s.jsx)(n.code,{children:"packages/core/src/index.test.ts:327"}),", ",(0,s.jsx)(n.code,{children:"packages/core/src/command-queue.test.ts:553"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Validated monotonic clock behaviour within the worker bridge when the host clock stalls (",(0,s.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.test.ts:136"}),")."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},7678:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(9430);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);