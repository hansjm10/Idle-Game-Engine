"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[3368],{7678:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>t});var r=n(9430);const i={},d=r.createContext(i);function l(e){const s=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(d.Provider,{value:s},e.children)}},8949:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"issue-808-design","title":"shell-desktop: coalesce/backpressure sim frames over IPC (Issue 808)","description":"Document Control","source":"@site/../../docs/issue-808-design.md","sourceDirName":".","slug":"/issue-808-design","permalink":"/Idle-Game-Engine/issue-808-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/issue-808-design.md","tags":[],"version":"current","sidebarPosition":99,"frontMatter":{"title":"shell-desktop: coalesce/backpressure sim frames over IPC (Issue 808)","sidebar_position":99}}');var i=n(5270),d=n(7678);const l={title:"shell-desktop: coalesce/backpressure sim frames over IPC (Issue 808)",sidebar_position:99},t="shell-desktop: coalesce/backpressure sim frames over IPC (Issue 808)",a={},o=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"6.2.1 Define the contract: <code>idle-engine:frame</code> is latest-snapshot",id:"621-define-the-contract-idle-engineframe-is-latest-snapshot",level:4},{value:"6.2.2 Coalesce as early as possible: worker emits only the last frame",id:"622-coalesce-as-early-as-possible-worker-emits-only-the-last-frame",level:4},{value:"6.2.3 Defense-in-depth: main forwards at most one frame per worker message",id:"623-defense-in-depth-main-forwards-at-most-one-frame-per-worker-message",level:4},{value:"6.2.4 Optional: explicit renderer ACK backpressure",id:"624-optional-explicit-renderer-ack-backpressure",level:4},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Open Questions",id:"13-open-questions",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function c(e){const s={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"shell-desktop-coalescebackpressure-sim-frames-over-ipc-issue-808",children:"shell-desktop: coalesce/backpressure sim frames over IPC (Issue 808)"})}),"\n",(0,i.jsx)(s.h2,{id:"document-control",children:"Document Control"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Title"}),": Treat ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," as a latest-snapshot stream (coalesce sim frames over IPC)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Authors"}),": Codex (AI)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Reviewers"}),": @hansjm10"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Status"}),": Draft"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Last Updated"}),": 2026-01-23"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Related Issues"}),": ",(0,i.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/808",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/808"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,i.jsxs)(s.p,{children:["The desktop sim worker can generate multiple ",(0,i.jsx)(s.code,{children:"RenderCommandBuffer"})," snapshots during a single main-process tick when it catches up (fixed-step sim with ",(0,i.jsx)(s.code,{children:"deltaMs > stepSizeMs"}),", bounded by ",(0,i.jsx)(s.code,{children:"maxStepsPerFrame"}),"). The renderer only ever uses the most recent snapshot, but the main process currently forwards every intermediate snapshot over Electron IPC, wasting CPU/IPC bandwidth and creating latency spikes during catch-up bursts. This design defines ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," as a latest-snapshot stream, coalesces frames as early as possible (worker -> main), and adds defense-in-depth (main forwards at most one frame per worker message). Optional ACK-based backpressure is included as a follow-up if profiling shows IPC backlog."]}),"\n",(0,i.jsx)(s.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Background"}),": ",(0,i.jsx)(s.code,{children:"@idle-engine/shell-desktop"})," runs the deterministic runtime in a Node ",(0,i.jsx)(s.code,{children:"Worker"})," (",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"}),"). The main process ticks the worker and forwards ",(0,i.jsx)(s.code,{children:"RenderCommandBuffer"})," frames to the renderer via ",(0,i.jsx)(s.code,{children:"IPC_CHANNELS.frame"})," (",(0,i.jsx)(s.code,{children:"idle-engine:frame"}),"). The renderer stores ",(0,i.jsx)(s.code,{children:"latestRcb"})," and renders on ",(0,i.jsx)(s.code,{children:"requestAnimationFrame"})," (",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/renderer/index.ts"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Problem"}),": The worker emits ",(0,i.jsx)(s.code,{children:"{ kind: 'frames', frames: RenderCommandBuffer[], nextStep }"}),", and the main process forwards ",(0,i.jsx)(s.em,{children:"each"})," element of ",(0,i.jsx)(s.code,{children:"frames"})," via IPC (",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"}),"). During catch-up, ",(0,i.jsx)(s.code,{children:"frames.length"})," can be > 1, but the renderer drops intermediates and uses only the last snapshot\u2014so those IPC sends are pure overhead."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Forces"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Keep the sim deterministic: dropping intermediate render snapshots must not affect sim state progression."}),"\n",(0,i.jsx)(s.li,{children:"Preserve renderer behavior: consumers should only rely on receiving \u201cthe newest available snapshot,\u201d not every sim step."}),"\n",(0,i.jsx)(s.li,{children:"Maintain responsiveness under stalls/jank: bound work and avoid bursty IPC traffic."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Goals"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Ensure the renderer receives ",(0,i.jsx)(s.strong,{children:"\u2264 1"})," ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," event per worker tick message, and it is the highest-step frame."]}),"\n",(0,i.jsxs)(s.li,{children:["Do not emit ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," for empty frame batches (",(0,i.jsx)(s.code,{children:"frames: []"}),")."]}),"\n",(0,i.jsx)(s.li,{children:"Make IPC cost scale with renderer consumption (display rate / snapshot cadence) instead of sim catch-up bursts."}),"\n",(0,i.jsxs)(s.li,{children:["Provide lightweight observability for dropped intermediates (e.g., ",(0,i.jsx)(s.code,{children:"droppedFrames"})," counters between worker and main)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Non-Goals"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Rendering interpolation between sim steps."}),"\n",(0,i.jsx)(s.li,{children:"Recording/streaming every sim step for capture/replay (would require a separate dev-only channel or file sink)."}),"\n",(0,i.jsxs)(s.li,{children:["Changing core runtime stepping semantics (",(0,i.jsx)(s.code,{children:"maxStepsPerFrame"}),", accumulator behavior) in ",(0,i.jsx)(s.code,{children:"@idle-engine/core"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Primary Stakeholders"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Desktop shell maintainers (",(0,i.jsx)(s.code,{children:"packages/shell-desktop"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Renderer consumers of ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," (desktop renderer and any future inspectors)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Agent Roles"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Docs Agent"}),": Maintain this design doc; track open questions and decisions."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Shell Implementation Agent"}),": Implement worker/main coalescing and (optional) ACK backpressure."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Test Agent"}),": Update/add Vitest coverage for coalescing and empty batches."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Affected Packages/Services"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})," (worker outbound message shape)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})," (coalescing + forwarding behavior)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim/sim-runtime.ts"})," (optional: avoid allocating frame arrays)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"}),", ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.test.ts"})," (tests)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Compatibility Considerations"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"idle-engine:frame"})," payload type remains ",(0,i.jsx)(s.code,{children:"RenderCommandBuffer"})," (",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/ipc.ts"}),")."]}),"\n",(0,i.jsx)(s.li,{children:"Semantics change: intermediate frames may be dropped; consumers must treat the channel as \u201clatest snapshot\u201d not \u201cevery step.\u201d"}),"\n",(0,i.jsxs)(s.li,{children:["The worker \u2194 main message protocol is internal to ",(0,i.jsx)(s.code,{children:"@idle-engine/shell-desktop"})," and can be migrated in lockstep; during transition, main should tolerate ",(0,i.jsx)(s.code,{children:"{ kind: 'frames' }"})," batches defensively."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,i.jsx)(s.p,{children:"Data flow today:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"main.ts tick loop\n  -> worker.postMessage({ kind: 'tick', deltaMs })\n  -> sim-worker.ts calls SimRuntime.tick(deltaMs)\n    -> IdleEngineRuntime.tick(deltaMs) may run N fixed steps (N <= maxStepsPerFrame)\n    -> demo \"frame-producer\" system produces a RenderCommandBuffer each step\n  -> sim-worker.ts emits { kind: 'frames', frames: [frame0..frameN-1], nextStep }\n  -> main.ts forwards every element in frames via IPC_CHANNELS.frame\n  -> renderer receives multiple idle-engine:frame events and keeps only the last (latestRcb)\n"})}),"\n",(0,i.jsx)(s.p,{children:"Key characteristics:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["In ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim/sim-runtime.ts"}),", ",(0,i.jsx)(s.code,{children:"frame-producer"})," pushes one frame per executed sim step into a queue, and ",(0,i.jsx)(s.code,{children:"tick()"})," returns ",(0,i.jsx)(s.code,{children:"frames: Array.from(frameQueue)"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["In ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"}),", the worker message handler does:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"nextStep = message.nextStep"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"for (const frame of message.frames) mainWindow.webContents.send(IPC_CHANNELS.frame, frame)"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["In ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/renderer/index.ts"}),", ",(0,i.jsx)(s.code,{children:"onFrame"})," assigns ",(0,i.jsx)(s.code,{children:"latestRcb = frame"})," and rendering is driven by ",(0,i.jsx)(s.code,{children:"requestAnimationFrame"}),", so intermediate frames are overwritten before they can be displayed."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,i.jsx)(s.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Narrative"}),": Treat ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," as a latest-snapshot stream. Coalesce intermediate frames in the producer chain so that at most one snapshot crosses each boundary (worker \u2192 main, main \u2192 renderer). Keep ",(0,i.jsx)(s.code,{children:"nextStep"})," updates intact so command stamping remains correct. If needed later, add explicit ACK-based backpressure so main never has more than one in-flight frame to the renderer."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Diagram"}),":"]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"Worker tick (may run N sim steps)\n  -> produces N internal snapshots\n  -> coalesce to last snapshot (highest step)\n  -> main forwards at most 1 snapshot per worker message\n  -> renderer stores latest snapshot and renders on rAF\n"})}),"\n",(0,i.jsx)(s.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,i.jsxs)(s.h4,{id:"621-define-the-contract-idle-engineframe-is-latest-snapshot",children:["6.2.1 Define the contract: ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," is latest-snapshot"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," channel delivers a complete snapshot representing the most recent available sim state."]}),"\n",(0,i.jsx)(s.li,{children:"Intermediate sim-step snapshots may be dropped."}),"\n",(0,i.jsx)(s.li,{children:"Consumers must not assume they will receive a frame for every sim step."}),"\n",(0,i.jsxs)(s.li,{children:["If frames arrive out of order, the highest ",(0,i.jsx)(s.code,{children:"frame.frame.step"})," wins; older steps are ignored."]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"622-coalesce-as-early-as-possible-worker-emits-only-the-last-frame",children:"6.2.2 Coalesce as early as possible: worker emits only the last frame"}),"\n",(0,i.jsx)(s.p,{children:"Update the sim worker outbound message protocol to avoid sending arrays of frames across the worker boundary:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"New outbound message shape (worker \u2192 main)"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"{ kind: 'frame', frame?: RenderCommandBuffer, nextStep: number, droppedFrames: number }"})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"frame"})," is omitted when no frames were produced."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"droppedFrames"})," is ",(0,i.jsx)(s.code,{children:"max(0, producedFrames - (frame ? 1 : 0))"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Implementation notes:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The worker should still update ",(0,i.jsx)(s.code,{children:"nextStep"})," every tick message, even when ",(0,i.jsx)(s.code,{children:"frame"})," is omitted, because ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})," uses ",(0,i.jsx)(s.code,{children:"nextStep"})," to stamp control-event commands."]}),"\n",(0,i.jsxs)(s.li,{children:["To compute ",(0,i.jsx)(s.code,{children:"droppedFrames"})," without allocating arrays, ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim/sim-runtime.ts"})," can be refactored to track:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"latestFrame: RenderCommandBuffer | undefined"})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"producedFrames: number"}),"\nand return ",(0,i.jsx)(s.code,{children:"{ frame: latestFrame, nextStep, droppedFrames: Math.max(0, producedFrames - (latestFrame ? 1 : 0)) }"}),"."]}),"\n",(0,i.jsx)(s.li,{children:"This is optional for correctness; it primarily reduces allocation and clone cost inside the worker."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"623-defense-in-depth-main-forwards-at-most-one-frame-per-worker-message",children:"6.2.3 Defense-in-depth: main forwards at most one frame per worker message"}),"\n",(0,i.jsxs)(s.p,{children:["Even if the worker still sends ",(0,i.jsx)(s.code,{children:"{ kind: 'frames', frames: [...] }"})," during a migration window, the main process should coalesce:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["If ",(0,i.jsx)(s.code,{children:"frames.length === 0"}),": do not call ",(0,i.jsx)(s.code,{children:"webContents.send(IPC_CHANNELS.frame, ...)"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["Otherwise: forward only ",(0,i.jsx)(s.code,{children:"frames.at(-1)"})," (the highest-step frame, assuming ordered generation)."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["For the new ",(0,i.jsx)(s.code,{children:"{ kind: 'frame' }"})," message:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["If ",(0,i.jsx)(s.code,{children:"frame"})," is present: forward it."]}),"\n",(0,i.jsxs)(s.li,{children:["If ",(0,i.jsx)(s.code,{children:"frame"})," is absent: do nothing (but still update ",(0,i.jsx)(s.code,{children:"nextStep"}),")."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Optional robustness:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Track ",(0,i.jsx)(s.code,{children:"lastForwardedStep"})," in the main process and ignore frames where ",(0,i.jsx)(s.code,{children:"frame.frame.step <= lastForwardedStep"})," to guard against out-of-order delivery or duplicate messages."]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"624-optional-explicit-renderer-ack-backpressure",children:"6.2.4 Optional: explicit renderer ACK backpressure"}),"\n",(0,i.jsxs)(s.p,{children:["If profiling shows IPC backlog (e.g., renderer event queue or ",(0,i.jsx)(s.code,{children:"webContents.send"})," contention), introduce a simple ACK:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Add IPC channels:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"idle-engine:frame"})," (existing): main \u2192 renderer, payload ",(0,i.jsx)(s.code,{children:"RenderCommandBuffer"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"idle-engine:frame-ack"})," (new): renderer \u2192 main, payload ",(0,i.jsx)(s.code,{children:"{ step: number }"})," (or empty)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Main process behavior:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Maintain ",(0,i.jsx)(s.code,{children:"inFlight: boolean"})," and ",(0,i.jsx)(s.code,{children:"pendingLatest: RenderCommandBuffer | undefined"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["When a new frame arrives:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["If not in flight: send immediately and set ",(0,i.jsx)(s.code,{children:"inFlight = true"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["If in flight: replace ",(0,i.jsx)(s.code,{children:"pendingLatest"})," with the newest frame (drop older pending frames)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["On ACK:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["If ",(0,i.jsx)(s.code,{children:"pendingLatest"})," exists: send it and keep ",(0,i.jsx)(s.code,{children:"inFlight = true"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["Else: set ",(0,i.jsx)(s.code,{children:"inFlight = false"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This makes \u201cframes delivered\u201d scale with renderer consumption and prevents unbounded in-flight snapshots."}),"\n",(0,i.jsx)(s.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Deployment"}),": Standard workspace build; no migration scripts. Worker/main/renderer changes ship together in ",(0,i.jsx)(s.code,{children:"@idle-engine/shell-desktop"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Telemetry & Observability"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Dev-only counters in main: ",(0,i.jsx)(s.code,{children:"framesReceived"}),", ",(0,i.jsx)(s.code,{children:"framesForwarded"}),", ",(0,i.jsx)(s.code,{children:"framesDropped"})," (from ",(0,i.jsx)(s.code,{children:"droppedFrames"}),")."]}),"\n",(0,i.jsx)(s.li,{children:"Optionally display counters in the renderer debug text output (if desired)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Security & Compliance"}),": No new external inputs; frame payload remains structured-cloneable data already sent over IPC."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,i.jsx)(s.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Issue Title"}),(0,i.jsx)(s.th,{children:"Scope Summary"}),(0,i.jsx)(s.th,{children:"Proposed Assignee/Agent"}),(0,i.jsx)(s.th,{children:"Dependencies"}),(0,i.jsx)(s.th,{children:"Acceptance Criteria"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"feat(shell-desktop): coalesce frames forwarded to renderer"})}),(0,i.jsx)(s.td,{children:"Forward only the highest-step frame per worker message; skip empty batches"}),(0,i.jsx)(s.td,{children:"Shell Implementation Agent"}),(0,i.jsx)(s.td,{children:"None"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"idle-engine:frame"})," is emitted \u2264 1 time per ",(0,i.jsx)(s.code,{children:"{ kind:'frames' }"})," message; empty batches emit none"]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"feat(shell-desktop): emit latest frame from sim worker"})}),(0,i.jsxs)(s.td,{children:["Change worker outbound protocol to ",(0,i.jsx)(s.code,{children:"{ kind:'frame', frame?, droppedFrames, nextStep }"})]}),(0,i.jsx)(s.td,{children:"Shell Implementation Agent"}),(0,i.jsx)(s.td,{children:"Coalescing in main (recommended)"}),(0,i.jsxs)(s.td,{children:["Worker no longer posts frame arrays; ",(0,i.jsx)(s.code,{children:"droppedFrames"})," is correct; ",(0,i.jsx)(s.code,{children:"nextStep"})," updates preserved"]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"test(shell-desktop): cover coalescing + empty batch"})}),(0,i.jsxs)(s.td,{children:["Update ",(0,i.jsx)(s.code,{children:"main.test.ts"})," and ",(0,i.jsx)(s.code,{children:"sim-worker.test.ts"})," for new behavior"]}),(0,i.jsx)(s.td,{children:"Test Agent"}),(0,i.jsx)(s.td,{children:"Implementation merged or mocked"}),(0,i.jsx)(s.td,{children:"Tests assert only last frame forwarded; empty batch sends nothing"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"feat(shell-desktop): optional frame ACK backpressure"})}),(0,i.jsxs)(s.td,{children:["Add ",(0,i.jsx)(s.code,{children:"frame-ack"})," channel + gating if needed"]}),(0,i.jsx)(s.td,{children:"Shell Implementation Agent"}),(0,i.jsx)(s.td,{children:"Profiling data / decision"}),(0,i.jsx)(s.td,{children:"Main never has >1 in-flight frame; pending frames coalesce to newest"})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Phase 1"}),": Implement main-process coalescing (defense-in-depth) + update tests."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Phase 2"}),": Switch sim worker to emit latest-frame messages (+ optional sim-runtime allocation reduction) + update tests."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Phase 3 (Optional)"}),": Add ACK backpressure if IPC backlog is still observable in profiling."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Hand-off Package"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Worker protocol: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})]}),"\n",(0,i.jsxs)(s.li,{children:["Frame forwarding: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})]}),"\n",(0,i.jsxs)(s.li,{children:["Renderer consumption: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/renderer/index.ts"})]}),"\n",(0,i.jsxs)(s.li,{children:["IPC contract: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/ipc.ts"})," / ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/preload.cts"})]}),"\n",(0,i.jsxs)(s.li,{children:["Tests: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"}),", ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.test.ts"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Communication Cadence"}),": One review after Phase 1; a second review if ACK backpressure is introduced."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Context Packets"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Issue 808: ",(0,i.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/808",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/808"})]}),"\n",(0,i.jsxs)(s.li,{children:["Shell desktop main: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})]}),"\n",(0,i.jsxs)(s.li,{children:["Worker: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Prompting & Constraints"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Keep ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," payload type as ",(0,i.jsx)(s.code,{children:"RenderCommandBuffer"})," (no renderer-contract change required)."]}),"\n",(0,i.jsxs)(s.li,{children:["Preserve deterministic stamping for control events (",(0,i.jsx)(s.code,{children:"step = nextStep"}),", ",(0,i.jsx)(s.code,{children:"timestamp = nextStep * stepSizeMs"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:["Preserve type-only imports/exports (",(0,i.jsx)(s.code,{children:"import type"})," / ",(0,i.jsx)(s.code,{children:"export type"}),")."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Safety Rails"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Do not introduce per-frame console logging on hot paths unless it is dev-only and rate-limited."}),"\n",(0,i.jsxs)(s.li,{children:["Do not edit generated ",(0,i.jsx)(s.code,{children:"dist/**"})," outputs by hand."]}),"\n",(0,i.jsx)(s.li,{children:"Ensure coalescing logic never forwards older-step frames over newer-step frames."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Validation Hooks"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"pnpm test --filter @idle-engine/shell-desktop"})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"pnpm lint --filter @idle-engine/shell-desktop"})," (if types change)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Keep forwarding every frame"}),": Simple but wastes CPU/IPC bandwidth and creates latency spikes under catch-up."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Coalesce only in the renderer"}),": Renderer already keeps only the latest, but does not reduce main-process IPC traffic or worker->main structured clone overhead."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Switch sim to render-interpolated frames"}),": Higher UX quality but requires substantial runtime/renderer changes and is out of scope for issue-808."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Backpressure only (ACK) without coalescing"}),": Prevents in-flight growth but still sends unnecessary intermediate frames within a tick burst; coalescing first yields the biggest win."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Unit / Integration"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Update ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"})," to:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Emit ",(0,i.jsx)(s.code,{children:"{ kind: 'frames', frames: [A, B], nextStep }"})," from the worker and assert ",(0,i.jsx)(s.strong,{children:"only"})," ",(0,i.jsx)(s.code,{children:"B"})," is forwarded via ",(0,i.jsx)(s.code,{children:"IPC_CHANNELS.frame"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["Emit ",(0,i.jsx)(s.code,{children:"{ kind: 'frames', frames: [], nextStep }"})," and assert no ",(0,i.jsx)(s.code,{children:"IPC_CHANNELS.frame"})," send occurs."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Update ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.test.ts"})," to match the worker outbound protocol (either still ",(0,i.jsx)(s.code,{children:"frames"})," during Phase 1, or ",(0,i.jsx)(s.code,{children:"frame"})," in Phase 2)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Performance"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Manual verification: induce a large ",(0,i.jsx)(s.code,{children:"deltaMs"})," (e.g., by pausing the process or clamping clock) and confirm renderer receives one frame per tick message and IPC does not spike proportional to ",(0,i.jsx)(s.code,{children:"maxStepsPerFrame"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Tooling / A11y"}),": N/A."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Risk"}),": Some consumer assumes per-step frame delivery and breaks when frames are dropped.",(0,i.jsx)(s.br,{}),"\n",(0,i.jsx)(s.strong,{children:"Mitigation"}),": Explicitly document ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," as latest-snapshot; if per-step capture is needed, add a separate dev-only channel."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Risk"}),": Main/worker protocol changes cause mismatches during partial updates.",(0,i.jsx)(s.br,{}),"\n",(0,i.jsx)(s.strong,{children:"Mitigation"}),": Implement defense-in-depth in main to support both ",(0,i.jsx)(s.code,{children:"{ kind:'frames' }"})," and ",(0,i.jsx)(s.code,{children:"{ kind:'frame' }"})," shapes for a short transition window."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Risk"}),": ACK backpressure introduces deadlocks if ACK is not emitted.",(0,i.jsx)(s.br,{}),"\n",(0,i.jsx)(s.strong,{children:"Mitigation"}),": Make ACK optional and only gate when enabled; consider a timeout fallback or \u201csend newest after X ms\u201d if ACK is adopted."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Milestones"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Merge Phase 1 coalescing + tests."}),"\n",(0,i.jsx)(s.li,{children:"Merge Phase 2 worker protocol update + tests."}),"\n",(0,i.jsx)(s.li,{children:"Consider Phase 3 ACK backpressure based on profiling."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Migration Strategy"}),": None (internal protocol within the desktop shell; renderer payload unchanged)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Communication"}),": Note in the PR description that ",(0,i.jsx)(s.code,{children:"idle-engine:frame"})," is now a latest-snapshot stream and intermediate sim-step snapshots may be dropped."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"13-open-questions",children:"13. Open Questions"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Do we need ACK backpressure now, or is per-message coalescing sufficient for observed workloads?"}),"\n",(0,i.jsxs)(s.li,{children:["Should ",(0,i.jsx)(s.code,{children:"droppedFrames"})," be surfaced to the renderer/UI (debug overlay), or kept as main-process-only diagnostics?"]}),"\n",(0,i.jsxs)(s.li,{children:["Should main enforce a monotonic step guarantee (",(0,i.jsx)(s.code,{children:"lastForwardedStep"}),") or rely on message ordering assumptions?"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"If later needed, add a separate dev-only \u201call-steps\u201d frame channel for capture/replay tooling."}),"\n",(0,i.jsx)(s.li,{children:"Explore render interpolation/extrapolation for smoother visuals under catch-up (separate feature)."}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"15-references",children:"15. References"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Issue 808: ",(0,i.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/808",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/808"})]}),"\n",(0,i.jsxs)(s.li,{children:["Worker emits frames batches: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts:88"})]}),"\n",(0,i.jsxs)(s.li,{children:["Main forwards each frame today: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts:234"})]}),"\n",(0,i.jsxs)(s.li,{children:["Renderer keeps only latest: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/renderer/index.ts:64"})]}),"\n",(0,i.jsxs)(s.li,{children:["IPC channel identifiers: ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/ipc.ts:5"})]}),"\n",(0,i.jsxs)(s.li,{children:["Existing test that expects multiple forwards (to update): ",(0,i.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts:313"})]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"RenderCommandBuffer (RCB)"}),": A render snapshot payload consumed by renderers (",(0,i.jsx)(s.code,{children:"@idle-engine/renderer-contract"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Fixed-step sim"}),": The runtime advances in discrete steps of ",(0,i.jsx)(s.code,{children:"stepSizeMs"})," rather than variable timesteps."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Catch-up / backlog"}),": When a large ",(0,i.jsx)(s.code,{children:"deltaMs"})," requires multiple sim steps to run in a single tick."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Coalescing"}),": Collapsing multiple intermediate frames into a single \u201clatest\u201d frame for downstream consumers."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Backpressure (ACK)"}),": A mechanism to bound in-flight work by requiring consumers to acknowledge receipt/processing."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Date"}),(0,i.jsx)(s.th,{children:"Author"}),(0,i.jsx)(s.th,{children:"Change Summary"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"2026-01-23"}),(0,i.jsx)(s.td,{children:"Codex (AI)"}),(0,i.jsx)(s.td,{children:"Initial draft design doc for Issue 808"})]})})]})]})}function h(e={}){const{wrapper:s}={...(0,d.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);