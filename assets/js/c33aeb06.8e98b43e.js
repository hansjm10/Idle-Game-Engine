"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[3174],{6726:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"runtime-step-lifecycle","title":"Runtime Step Lifecycle Alignment","description":"This design document confirms implementation alignment with the command queue design specification. It cross-references runtime, systems, and UI sources to verify that commands are stamped consistently with the fixed-step lifecycle described in the runtime command queue design.","source":"@site/../../docs/runtime-step-lifecycle.md","sourceDirName":".","slug":"/runtime-step-lifecycle","permalink":"/Idle-Game-Engine/runtime-step-lifecycle","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/runtime-step-lifecycle.md","tags":[],"version":"current","frontMatter":{"title":"Runtime Step Lifecycle Alignment"},"sidebar":"developerSidebar","previous":{"title":"Idle Engine Design Document","permalink":"/Idle-Game-Engine/idle-engine-design"},"next":{"title":"Runtime Command Queue Design Document","permalink":"/Idle-Game-Engine/runtime-command-queue-design"}}');var t=i(5270),r=i(7678);const l={title:"Runtime Step Lifecycle Alignment"},d="Runtime Step Lifecycle Alignment",o={},c=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"IdleEngineRuntime (Worker)",id:"idleengineruntime-worker",level:4},{value:"Worker Bridge",id:"worker-bridge",level:4},{value:"Presentation Shell",id:"presentation-shell",level:4},{value:"Automation System Timestamps",id:"automation-system-timestamps",level:4},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"Diagnostics Timeline",id:"diagnostics-timeline",level:4},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Open Questions",id:"13-open-questions",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"runtime-step-lifecycle-alignment",children:"Runtime Step Lifecycle Alignment"})}),"\n",(0,t.jsx)(n.p,{children:"This design document confirms implementation alignment with the command queue design specification. It cross-references runtime, systems, and UI sources to verify that commands are stamped consistently with the fixed-step lifecycle described in the runtime command queue design."}),"\n",(0,t.jsx)(n.h2,{id:"document-control",children:"Document Control"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Title"}),": Runtime Step Lifecycle Alignment"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Authors"}),": N/A"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reviewers"}),": N/A"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Status"}),": Approved"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Last Updated"}),": 2025-12-21"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Related Issues"}),": N/A"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execution Mode"}),": Manual"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,t.jsx)(n.p,{children:"This document verifies that the Idle Engine runtime implementation correctly follows the fixed-step lifecycle and command stamping protocol defined in the runtime command queue design (docs/runtime-command-queue-design.md). It confirms that the IdleEngineRuntime worker, Worker Bridge, and Presentation Shell all maintain proper step synchronization for deterministic command execution."}),"\n",(0,t.jsx)(n.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Background"}),": The runtime command queue design specification defines a deterministic fixed-step execution model where all commands must be stamped with appropriate step numbers to ensure reproducible game state progression. This document serves as verification that the implementation matches the design."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem"}),": Without proper step lifecycle management across the runtime, worker bridge, and UI layers, command execution could become non-deterministic, breaking offline progression, debugging, and testing scenarios."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Forces"}),": The system must maintain strict determinism while coordinating between untrusted UI code (player commands) and trusted worker systems (automation), all while keeping the presentation layer synchronized with internal tick progression."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Goals"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Verify IdleEngineRuntime manages currentStep/nextExecutableStep as specified"}),"\n",(0,t.jsx)(n.li,{children:"Confirm Worker Bridge correctly stamps player commands"}),"\n",(0,t.jsx)(n.li,{children:"Validate Presentation Shell maintains proper lifecycle synchronization"}),"\n",(0,t.jsx)(n.li,{children:"Ensure automation system uses deterministic timestamps"}),"\n",(0,t.jsx)(n.li,{children:"Document diagnostics timeline integration"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Non-Goals"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Redesigning the step lifecycle (this is verification only)"}),"\n",(0,t.jsx)(n.li,{children:"Performance optimization of the tick loop"}),"\n",(0,t.jsx)(n.li,{children:"Adding new command sources or priorities"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Primary Stakeholders"}),": Runtime team, QA"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Agent Roles"}),": N/A (verification document)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Affected Packages/Services"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/core"})," (IdleEngineRuntime, automation system, diagnostics)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/shell-web"})," (Worker Bridge, Presentation Shell)"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compatibility Considerations"}),": Implementation must maintain backward compatibility with existing command queue behavior."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,t.jsx)(n.p,{children:"The implementation spans three key layers:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IdleEngineRuntime (Worker)"})," - Core tick loop and step management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Worker Bridge"})," - Security boundary and command stamping for UI commands"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Presentation Shell"})," - UI integration and state synchronization"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"All components implement the design specified in docs/runtime-command-queue-design.md \xa74.3."}),"\n",(0,t.jsx)(n.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,t.jsx)(n.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Narrative"}),": The runtime step lifecycle ensures deterministic command execution through a three-layer architecture. The IdleEngineRuntime manages authoritative step counters, the Worker Bridge acts as a security boundary for player commands, and the Presentation Shell provides UI integration without exposing internal state."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Diagram"}),": Refer to runtime-command-queue-design.md for system architecture diagrams."]}),"\n",(0,t.jsx)(n.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,t.jsx)(n.h4,{id:"idleengineruntime-worker",children:"IdleEngineRuntime (Worker)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"File"}),": ",(0,t.jsx)(n.code,{children:"packages/core/src/index.ts"})]}),"\n",(0,t.jsxs)(n.p,{children:["The runtime manages ",(0,t.jsx)(n.code,{children:"currentStep"})," / ",(0,t.jsx)(n.code,{children:"nextExecutableStep"})," exactly as described in the design:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The tick loop sets ",(0,t.jsx)(n.code,{children:"nextExecutableStep = currentStep"})," before capturing the queue batch"]}),"\n",(0,t.jsxs)(n.li,{children:["Advances to ",(0,t.jsx)(n.code,{children:"currentStep + 1"})," as soon as the batch is secured"]}),"\n",(0,t.jsxs)(n.li,{children:["Records a ",(0,t.jsx)(n.code,{children:"CommandStepMismatch"})," telemetry event if a queued command is stamped for a different tick"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"TickContext Integration"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"TickContext.step"})," surfaces the just-executed tick so internal systems stamp follow-up commands with ",(0,t.jsx)(n.code,{children:"context.step + 1"})]}),"\n",(0,t.jsx)(n.li,{children:"This aligns system enqueues with the next tick boundary automatically"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"worker-bridge",children:"Worker Bridge"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"File"}),": ",(0,t.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts"})]}),"\n",(0,t.jsx)(n.p,{children:"Acts as the security boundary for UI commands:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Incoming messages are always treated as ",(0,t.jsx)(n.code,{children:"PLAYER"})," priority"]}),"\n",(0,t.jsxs)(n.li,{children:["Commands are stamped with the Worker's monotonic clock plus the runtime's ",(0,t.jsx)(n.code,{children:"getNextExecutableStep()"})," value before entering the queue (per \xa77.2 of the command queue design)"]}),"\n",(0,t.jsx)(n.li,{children:"Systems running inside the Worker can enqueue with elevated priorities because they already execute within the trusted boundary"}),"\n",(0,t.jsx)(n.li,{children:"The Worker runs the simulation loop on a fixed interval, forwarding the current step back to the UI so presentation code can confirm progression without accessing internal counters directly"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"presentation-shell",children:"Presentation Shell"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Files"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/worker-bridge.ts"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/App.tsx"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The bridge exposes ",(0,t.jsx)(n.code,{children:"sendCommand"})," that mirrors the design's ",(0,t.jsx)(n.code,{children:"WorkerBridge"})," API (\xa77.1):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Wraps UI commands with ",(0,t.jsx)(n.code,{children:"CommandSource.PLAYER"})," and a UI-side timestamp"]}),"\n",(0,t.jsx)(n.li,{children:"Delegates actual step stamping to the Worker"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"App.tsx"})," consumes the bridge and reacts to state updates"]}),"\n",(0,t.jsx)(n.li,{children:"Keeps UI logic aligned with the Worker-driven tick lifecycle rather than assuming direct access to runtime internals"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"automation-system-timestamps",children:"Automation System Timestamps"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"File"}),": ",(0,t.jsx)(n.code,{children:"packages/core/src/automation-system.ts"})]}),"\n",(0,t.jsxs)(n.p,{children:["The automation system enqueues commands using deterministic timestamps derived from ",(0,t.jsx)(n.code,{children:"step * stepDurationMs"})," rather than wall-clock time (",(0,t.jsx)(n.code,{children:"Date.now()"})," or ",(0,t.jsx)(n.code,{children:"performance.now()"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reproducibility"}),": Offline progression and catch-up simulations produce consistent results across different execution environments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Debugging"}),": Command recorder logs can be reliably replayed to reproduce issues without timing-dependent variations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Testing"}),": Integration tests verify deterministic behavior by comparing command timestamps across multiple runs"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"enqueueAutomationCommand"})," function accepts ",(0,t.jsx)(n.code,{children:"stepDurationMs"})," as a parameter"]}),"\n",(0,t.jsxs)(n.li,{children:["Calculates ",(0,t.jsx)(n.code,{children:"timestamp = currentStep * stepDurationMs"})," before enqueueing"]}),"\n",(0,t.jsx)(n.li,{children:"Aligns with the runtime's fixed-step tick lifecycle"}),"\n",(0,t.jsx)(n.li,{children:"Ensures all automation commands use simulation time rather than real-world time"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,t.jsx)(n.h4,{id:"diagnostics-timeline",children:"Diagnostics Timeline"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Configuration"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Enable diagnostics by providing ",(0,t.jsx)(n.code,{children:"diagnostics: { timeline: { enabled: true } }"})," when constructing ",(0,t.jsx)(n.code,{children:"IdleEngineRuntime"})]}),"\n",(0,t.jsxs)(n.li,{children:["Or call ",(0,t.jsx)(n.code,{children:"runtime.enableDiagnostics({ enabled: true })"})," mid-session"]}),"\n",(0,t.jsx)(n.li,{children:"The controller resolves budgets from the runtime configuration so thresholds stay consistent across hosts"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Usage"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { formatLatestDiagnosticTimelineEntry } from '@idle-engine/core/devtools/diagnostics';\n\nconst diagnostics = runtime.readDiagnosticsDelta();\nconst formatted = formatLatestDiagnosticTimelineEntry(diagnostics);\nif (formatted) {\n  console.info(formatted.message, formatted.context.entry);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"File"}),": ",(0,t.jsx)(n.code,{children:"packages/core/src/devtools/diagnostics.ts"})]}),"\n",(0,t.jsxs)(n.p,{children:["The devtools helper ",(0,t.jsx)(n.code,{children:"formatLatestDiagnosticTimelineEntry()"})," converts the most recent timeline entry into a console-friendly message while preserving full metadata for inspection."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Telemetry Integration"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When the Prometheus telemetry adapter is active:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Slow ticks increment ",(0,t.jsx)(n.code,{children:"runtime_ticks_over_budget_total"})]}),"\n",(0,t.jsxs)(n.li,{children:["Slow systems increment ",(0,t.jsx)(n.code,{children:'runtime_system_slow_total{system_id="..."}'})]}),"\n",(0,t.jsx)(n.li,{children:"Counters align with runtime warning thresholds"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,t.jsx)(n.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,t.jsx)(n.p,{children:"N/A - This is a verification document confirming existing implementation."}),"\n",(0,t.jsx)(n.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,t.jsx)(n.p,{children:"N/A - Implementation already complete."}),"\n",(0,t.jsx)(n.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,t.jsx)(n.p,{children:"N/A - No active coordination required."}),"\n",(0,t.jsx)(n.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,t.jsx)(n.p,{children:"N/A - This is a verification document."}),"\n",(0,t.jsx)(n.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,t.jsx)(n.p,{children:"N/A - This document verifies existing implementation rather than proposing alternatives."}),"\n",(0,t.jsx)(n.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unit / Integration"}),": Existing test suites verify deterministic command execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance"}),": Diagnostics timeline tracks tick budget violations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tooling / A11y"}),": N/A"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Risk"}),": Step counter desynchronization between layers could break determinism."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Mitigation"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Worker Bridge always delegates step stamping to runtime's ",(0,t.jsx)(n.code,{children:"getNextExecutableStep()"})]}),"\n",(0,t.jsx)(n.li,{children:"UI has no direct access to internal step counters"}),"\n",(0,t.jsx)(n.li,{children:"Telemetry events track step mismatches"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,t.jsx)(n.p,{children:"N/A - Implementation already deployed."}),"\n",(0,t.jsx)(n.h2,{id:"13-open-questions",children:"13. Open Questions"}),"\n",(0,t.jsx)(n.p,{children:"None - Implementation matches design specification."}),"\n",(0,t.jsx)(n.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,t.jsx)(n.p,{children:"None identified."}),"\n",(0,t.jsx)(n.h2,{id:"15-references",children:"15. References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"docs/runtime-command-queue-design.md"})," - Primary design specification (\xa74.3, \xa77.1, \xa77.2)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/core/src/index.ts"})," - IdleEngineRuntime implementation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts"})," - Worker Bridge implementation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/worker-bridge.ts"})," - Presentation Shell bridge API"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/App.tsx"})," - UI integration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/core/src/automation-system.ts"})," - Automation timestamp handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/core/src/devtools/diagnostics.ts"})," - Diagnostics utilities"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Step"}),": A discrete simulation tick in the fixed-step execution model"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"currentStep"}),": The step number that was just executed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"nextExecutableStep"}),": The step number for which commands are currently being accepted"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TickContext"}),": Context object passed to systems during tick execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Worker Bridge"}),": Security boundary between untrusted UI and trusted runtime"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CommandStepMismatch"}),": Telemetry event indicating a command was stamped for the wrong tick"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Date"}),(0,t.jsx)(n.th,{children:"Author"}),(0,t.jsx)(n.th,{children:"Change Summary"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"2025-12-21"}),(0,t.jsx)(n.td,{children:"Claude Opus 4.5"}),(0,t.jsx)(n.td,{children:"Migrated to design document template format"})]})})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},7678:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var s=i(9430);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);