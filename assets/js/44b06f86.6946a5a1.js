"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[579],{7678:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(9430);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},9835:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"resource-state-storage-design","title":"Resource State Storage Design","description":"Issue: #7","source":"@site/../../docs/resource-state-storage-design.md","sourceDirName":".","slug":"/resource-state-storage-design","permalink":"/Idle-Game-Engine/resource-state-storage-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/resource-state-storage-design.md","tags":[],"version":"current","frontMatter":{},"sidebar":"developerSidebar","previous":{"title":"Tick Accumulator Edge Case Coverage","permalink":"/Idle-Game-Engine/tick-accumulator-coverage-design"},"next":{"title":"Diagnostic Timeline Instrumentation","permalink":"/Idle-Game-Engine/diagnostic-timeline-design"}}');var t=i(5270),r=i(7678);const o={},a="Resource State Storage Design",d={},c=[{value:"1. Overview",id:"1-overview",level:2},{value:"2. Goals",id:"2-goals",level:2},{value:"3. Non-Goals",id:"3-non-goals",level:2},{value:"4. Current State",id:"4-current-state",level:2},{value:"5. Proposed Solution",id:"5-proposed-solution",level:2},{value:"5.1 Data Layout",id:"51-data-layout",level:3},{value:"5.2 Runtime API Surface",id:"52-runtime-api-surface",level:3},{value:"5.3 Initialization &amp; Lifecycle",id:"53-initialization--lifecycle",level:3},{value:"5.4 Mutation Semantics",id:"54-mutation-semantics",level:3},{value:"5.5 Snapshot &amp; Persistence",id:"55-snapshot--persistence",level:3},{value:"Dual-Mode Progression Snapshot Support (Existing Implementation)",id:"dual-mode-progression-snapshot-support-existing-implementation",level:4},{value:"5.6 Integration Points",id:"56-integration-points",level:3},{value:"5.7 Implementation Plan",id:"57-implementation-plan",level:3},{value:"6. Testing Strategy",id:"6-testing-strategy",level:2},{value:"7. Risks &amp; Mitigations",id:"7-risks--mitigations",level:2},{value:"8. Decisions &amp; Clarifications",id:"8-decisions--clarifications",level:2},{value:"9. Acceptance Criteria",id:"9-acceptance-criteria",level:2}];function l(e){const n={blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"resource-state-storage-design",children:"Resource State Storage Design"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Issue:"})," #7",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Workstream:"})," Runtime Core",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Status:"})," Design",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.strong,{children:"Last Updated:"})," 2025-10-12"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["This document defines the struct-of-arrays resource storage that anchors the\nruntime state model described in ",(0,t.jsx)(n.code,{children:"docs/idle-engine-design.md"})," \xa79.2. The design\nfocuses on deterministic updates, cache-friendly iteration, and snapshot\nergonomics so downstream systems (production, upgrades, offline catch-up, UI\ndiffing) can evolve without revisiting the underlying layout."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"1-overview",children:"1. Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Issue #7 tracks the initial ",(0,t.jsx)(n.code,{children:"ResourceState"})," container responsible for storing\nall mutable resource quantities at runtime. The storage must support\ndeterministic mutation through commands and systems, efficient aggregation for\nper-frame calculations, and inexpensive snapshots for UI consumption and save\nserialization. A data-oriented, struct-of-arrays layout keeps iteration costs\nbounded as content packs scale and aligns with the performance strategy in\n",(0,t.jsx)(n.code,{children:"docs/idle-engine-design.md"})," \xa712."]}),"\n",(0,t.jsx)(n.h2,{id:"2-goals",children:"2. Goals"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deterministic mutations:"})," All adjustments flow through typed helpers that\nenforce caps, prevent negative balances, and emit telemetry on violations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Struct-of-arrays layout:"})," Store resource attributes in typed arrays to\nminimize cache misses during systems iteration and to simplify snapshotting."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stable indexing:"})," Provide a canonical resource index map shared by systems,\ncommand handlers, and serialization so lookups remain O(1)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Incremental deltas:"})," Track per-tick changes so the runtime can publish\nminimal deltas to the presentation shell and replay logs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistence-ready:"})," Expose immutable snapshots compatible with the existing\n",(0,t.jsx)(n.code,{children:"CommandRecorder"})," structured clone workflow for deterministic save/restore."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"3-non-goals",children:"3. Non-Goals"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Implementing generator logic, upgrade modifiers, or automation scheduling."}),"\n",(0,t.jsx)(n.li,{children:"Designing the content pipeline that emits resource/generator definitions."}),"\n",(0,t.jsx)(n.li,{children:"Persisting save data to disk (handled by the snapshot and migration workstream)."}),"\n",(0,t.jsx)(n.li,{children:"Rendering UI views or formatting resource values for presentation."}),"\n",(0,t.jsx)(n.li,{children:"Optimizing for multi-threaded mutation; the runtime remains single-threaded."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"4-current-state",children:"4. Current State"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/core"})," exposes ",(0,t.jsx)(n.code,{children:"setGameState"}),"/",(0,t.jsx)(n.code,{children:"getGameState"})," helpers\n(",(0,t.jsx)(n.code,{children:"packages/core/src/runtime-state.ts"}),") but lacks an opinionated resource\ncontainer."]}),"\n",(0,t.jsxs)(n.li,{children:["Commands targeting resources (",(0,t.jsx)(n.code,{children:"COLLECT_RESOURCE"}),", ",(0,t.jsx)(n.code,{children:"PURCHASE_GENERATOR"}),") are\ndefined but have no backing storage APIs."]}),"\n",(0,t.jsx)(n.li,{children:"No snapshot contract exists for resource quantities; UI and persistence cannot\nconsume structured deltas."}),"\n",(0,t.jsxs)(n.li,{children:["Prior design docs commit to struct-of-arrays (",(0,t.jsx)(n.code,{children:"docs/idle-engine-design.md"}),"\n\xa79.2) yet no implementation details exist."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"5-proposed-solution",children:"5. Proposed Solution"}),"\n",(0,t.jsx)(n.h3,{id:"51-data-layout",children:"5.1 Data Layout"}),"\n",(0,t.jsxs)(n.p,{children:["Introduce a ",(0,t.jsx)(n.code,{children:"ResourceStateBuffers"})," struct encapsulating the underlying\nArrayBuffers and typed arrays:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface ResourcePublishBuffers {\n  readonly amounts: Float64Array;\n  readonly capacities: Float64Array;\n  readonly incomePerSecond: Float64Array;\n  readonly expensePerSecond: Float64Array;\n  readonly netPerSecond: Float64Array;\n  readonly tickDelta: Float64Array;\n  readonly flags: Uint8Array;\n  readonly dirtyTolerance: Float64Array;\n  readonly dirtyIndices: Uint32Array;\n  dirtyCount: number;\n}\n\ninterface ResourceStateBuffers {\n  readonly ids: readonly string[];\n  readonly indexById: ImmutableMapSnapshot<string, number>;\n\n  // Live, mutating views\n  readonly amounts: Float64Array;\n  readonly capacities: Float64Array;\n  readonly incomePerSecond: Float64Array;\n  readonly expensePerSecond: Float64Array;\n  readonly netPerSecond: Float64Array;\n  readonly tickDelta: Float64Array;\n  readonly flags: Uint8Array;\n  readonly dirtyTolerance: Float64Array;\n\n  // Double-buffered publish views (ping-pong)\n  readonly publish: readonly [ResourcePublishBuffers, ResourcePublishBuffers];\n\n  readonly dirtyIndexScratch: Uint32Array;\n  readonly dirtyIndexPositions: Int32Array;\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ids"}),": canonical resource ordering derived from the active content pack."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"indexById"}),": ",(0,t.jsx)(n.code,{children:"ImmutableMapSnapshot"})," for O(1) lookup that throws on any attempt\nto mutate it post-initialization."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"amounts"}),": current balances (double precision for cumulative accuracy)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"capacities"}),": hard caps enforced on mutation; populated from definitions and\nupgrade modifiers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"incomePerSecond"})," / ",(0,t.jsx)(n.code,{children:"expensePerSecond"}),": running totals populated by systems\neach tick to support production diagnostics and UI stat panels. These values\nare mirrored into the publish buffers before ",(0,t.jsx)(n.code,{children:"resetPerTickAccumulators"})," clears\nthe live arrays so rate changes survive the publish/reset cycle."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"netPerSecond"}),": derived buffer updated at the end of each tick to avoid\nrecomputing ",(0,t.jsx)(n.code,{children:"income - expense"})," during reads."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tickDelta"}),": tracks the signed delta applied during the current tick, enabling\ncompact state diffs for the presentation layer and recorder."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"flags"}),": bit field storing boolean metadata. Bits are allocated as\n",(0,t.jsx)(n.code,{children:"VISIBLE = 1 << 0"}),", ",(0,t.jsx)(n.code,{children:"UNLOCKED = 1 << 1"}),", and ",(0,t.jsx)(n.code,{children:"DIRTY_THIS_TICK = 1 << 2"}),".\nMutation helpers set the dirty bit only when they apply a substantive change\n(amount, capacity, visibility, or net rates). Follow-up operations that restore\nparity with the published state clear the bit via ",(0,t.jsx)(n.code,{children:"unmarkIfClean"}),", keeping the\ndirty list minimal heading into publish."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dirtyTolerance"}),": per-resource tolerance ceiling (defaults to\n",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_CEILING"}),"). When a resource definition supplies\n",(0,t.jsx)(n.code,{children:"dirtyTolerance"}),", the factory writes the normalized value (clamped to\n",(0,t.jsx)(n.code,{children:">= DIRTY_EPSILON_ABSOLUTE"})," and ",(0,t.jsx)(n.code,{children:"<= DIRTY_EPSILON_OVERRIDE_MAX"}),") into this buffer\nand ",(0,t.jsx)(n.code,{children:"epsilonEquals"})," reads it instead of the default ceiling so prestige-scale\nresources can relax their tolerance without mutating global constants. The\nruntime treats these tolerances as immutable metadata outside initialization,\nhydration, or content reload flows, so dirty tracking deliberately ignores the\nfield during per-tick mutation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"publish"}),": pair of ",(0,t.jsx)(n.code,{children:"ResourcePublishBuffers"})," used in a ping-pong pattern. Each\nbuffer owns read-only copies of amounts, caps, per-second diagnostics,\ndeltas, flags, tolerance ceilings, and the filtered list of dirty indices that back the most\nrecent snapshot. ",(0,t.jsx)(n.code,{children:"snapshot({ mode: 'publish' })"})," writes into the inactive\npublish buffer and then flips the active pointer. Because only two publish\nbuffers exist, the previous snapshot (the one created immediately before the\ncurrent publish) remains isolated, but snapshots retained for more than one\npublish must deep-clone their data if they need to remain immutable. To keep\nclean resources aligned when buffers swap without replaying the entire buffer,\nthe publish path replays the prior frame's dirty indices into the inactive\nbuffer before applying the new tick's updates. The steps are:","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Zero ",(0,t.jsx)(n.code,{children:"targetPublish.tickDelta"})," only for indices recorded in either the\nprevious publish's dirty list or the current tick's scratch union\n(see \xa75.5) to avoid ",(0,t.jsx)(n.code,{children:"O(resourceCount)"})," work when the dirty set is small."]}),"\n",(0,t.jsxs)(n.li,{children:["Iterate the prefix of ",(0,t.jsx)(n.code,{children:"sourcePublish.dirtyIndices"})," up to\n",(0,t.jsx)(n.code,{children:"sourcePublish.dirtyCount"})," and copy the corresponding slots (amounts, caps,\nrates, flags, tolerance) from ",(0,t.jsx)(n.code,{children:"sourcePublish"})," into the inactive buffer so\neverything that moved last tick is already correct while leaving\n",(0,t.jsx)(n.code,{children:"tickDelta"})," at zero."]}),"\n",(0,t.jsxs)(n.li,{children:["Apply the current tick's dirty updates (see \xa75.5).\nResources that stay clean for two consecutive ticks never move, keeping the\ncopy cost proportional to the union of the previous and current dirty sets\ninstead of ",(0,t.jsx)(n.code,{children:"O(resourceCount)"}),". Each publish buffer maintains a mutable\n",(0,t.jsx)(n.code,{children:"dirtyCount"})," that records how much of its ",(0,t.jsx)(n.code,{children:"dirtyIndices"})," array is populated;\nthe snapshot path zeroes this value before repopulating the list for the\ncurrent tick."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dirtyIndexScratch"}),": reusable scratch space sized to ",(0,t.jsx)(n.code,{children:"resourceCount"}),". The data\nstructure stores a compact list of mutated indices during the tick without\nallocating new arrays."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dirtyIndexPositions"}),": ",(0,t.jsx)(n.code,{children:"Int32Array"})," mapping resource index \u2192 position inside\nthe scratch prefix (or ",(0,t.jsx)(n.code,{children:"-1"})," when absent). ",(0,t.jsx)(n.code,{children:"markDirty"})," and ",(0,t.jsx)(n.code,{children:"unmarkIfClean"}),"\nconsult this map to append and remove indices in O(1) while keeping the prefix\ndensely packed. During publish passes the map may temporarily hold the sentinel\nvalue ",(0,t.jsx)(n.code,{children:"-2"})," (",(0,t.jsx)(n.code,{children:"SCRATCH_VISITED"}),") while unioned loops are running; the loop restores\nthe entry to ",(0,t.jsx)(n.code,{children:"-1"})," before exiting so steady-state semantics remain unchanged."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"definitionDigest"}),": frozen record ",(0,t.jsx)(n.code,{children:"{ ids, version, hash }"})," cached alongside the\nimmutable id array so save systems can quickly confirm compatibility prior to\nhydration."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface ResourceDefinitionDigest {\n  readonly ids: readonly string[];\n  readonly version: number;\n  readonly hash: string;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["All live numeric buffers share a single ",(0,t.jsx)(n.code,{children:"ArrayBuffer"})," per numeric width to\nimprove serialization locality while keeping independent views disjoint. The\nFloat64 views (",(0,t.jsx)(n.code,{children:"amounts"}),", ",(0,t.jsx)(n.code,{children:"capacities"}),", ",(0,t.jsx)(n.code,{children:"incomePerSecond"}),", ",(0,t.jsx)(n.code,{children:"expensePerSecond"}),",\n",(0,t.jsx)(n.code,{children:"netPerSecond"}),", ",(0,t.jsx)(n.code,{children:"tickDelta"}),", ",(0,t.jsx)(n.code,{children:"dirtyTolerance"}),") are carved out of a backing buffer\nsized as ",(0,t.jsx)(n.code,{children:"Float64Array.BYTES_PER_ELEMENT * 7 * resourceCount"}),". Each publish\nbuffer owns its own Float64 ",(0,t.jsx)(n.code,{children:"ArrayBuffer"})," sized for the copied views (covering\nall seven slices) so the runtime can flip\nbetween ",(0,t.jsx)(n.code,{children:"publish[0]"})," and ",(0,t.jsx)(n.code,{children:"publish[1]"})," without invalidating previously issued\nsnapshots. Typed arrays are constructed with an offset stride where\n",(0,t.jsx)(n.code,{children:"stride = resourceCount * Float64Array.BYTES_PER_ELEMENT"}),"\n(",(0,t.jsx)(n.code,{children:"amounts"})," at offset ",(0,t.jsx)(n.code,{children:"0"}),", ",(0,t.jsx)(n.code,{children:"capacities"})," at ",(0,t.jsx)(n.code,{children:"1 * stride"}),", etc.). The scratch and\nposition maps use dedicated ",(0,t.jsx)(n.code,{children:"ArrayBuffer"}),"s, as do the Uint8 flag bits for both\nlive and publish views."]}),"\n",(0,t.jsxs)(n.p,{children:["Comparisons between live and publish buffers run through\n",(0,t.jsx)(n.code,{children:"epsilonEquals(a, b)"}),", which treats two values as equivalent when"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"const magnitude = Math.max(Math.abs(a), Math.abs(b));\nconst tolerance = Math.max(\n  DIRTY_EPSILON_ABSOLUTE,\n  Math.min(toleranceCeiling, DIRTY_EPSILON_RELATIVE * magnitude),\n);\nreturn Math.abs(a - b) <= tolerance;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Comparisons short-circuit when operands are already identical (including\nmatching ",(0,t.jsx)(n.code,{children:"Infinity"})," sentinels) so resources that return to their prior state do\nnot remain marked dirty after reconciliation."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"toleranceCeiling"})," resolves per resource from the mutable ",(0,t.jsx)(n.code,{children:"dirtyTolerance"}),"\nbuffer (defaulting to ",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_CEILING"})," but allowed to grow up to\n",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_OVERRIDE_MAX"}),"), ensuring the epsilon never exceeds the ceiling\nstored for that index."]}),"\n",(0,t.jsx)(n.p,{children:"Default constants:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_ABSOLUTE = 1e-9"})," collapses near-zero jitter."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_RELATIVE = 1e-9"})," scales tolerance in proportion to value size."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_CEILING = 1e-3"})," serves as the default per-resource ceiling."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_OVERRIDE_MAX = 5e-1"})," bounds definition-supplied overrides so they\ncan relax tolerance for prestige-scale resources without letting massive deltas\nslip through unchecked while still covering magnitude ranges up to\napproximately ",(0,t.jsx)(n.code,{children:"1e15"})," without keeping resources perpetually dirty."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If specific resources require looser tolerances (e.g., prestige currencies with\nhuge exponential growth), the content definition may optionally supply a\n",(0,t.jsx)(n.code,{children:"dirtyTolerance"})," override that the factory stores alongside the resource index;\n",(0,t.jsx)(n.code,{children:"epsilonEquals"})," then reads the per-resource ceiling (capped only by\n",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_OVERRIDE_MAX"}),"). Telemetry records the raw comparisons whenever the\noverride saturates so balancing can adjust the configuration before release.\nWhen this occurs the runtime emits ",(0,t.jsx)(n.code,{children:"ResourceDirtyToleranceSaturated"})," with\n",(0,t.jsx)(n.code,{children:"{ resourceId, field, difference, toleranceCeiling, relativeTolerance, magnitude }"}),"\nso analytics and balancing pipelines have the full context."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ImmutableMapSnapshot"})," is already provided by ",(0,t.jsx)(n.code,{children:"packages/core/src/immutable-snapshots.ts"}),"\nand proxies mutation methods so the lookup table cannot be altered after the\nstate is created."]}),"\n",(0,t.jsx)(n.h3,{id:"52-runtime-api-surface",children:"5.2 Runtime API Surface"}),"\n",(0,t.jsxs)(n.p,{children:["Expose a ",(0,t.jsx)(n.code,{children:"ResourceState"})," fa\xe7ade that owns the buffers internally while providing\nmutation and query helpers:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface ResourceState {\n  getIndex(id: string): number | undefined;\n  requireIndex(id: string): number;\n  getAmount(index: number): number;\n  getCapacity(index: number): number;\n  getNetPerSecond(index: number): number;\n  isUnlocked(index: number): boolean;\n  isVisible(index: number): boolean;\n  grantVisibility(index: number): void;\n  unlock(index: number): void;\n  setCapacity(index: number, capacity: number): number;\n  addAmount(index: number, amount: number): number;\n  spendAmount(\n    index: number,\n    amount: number,\n    context?: ResourceSpendAttemptContext,\n  ): boolean;\n  applyIncome(index: number, amountPerSecond: number): void;\n  applyExpense(index: number, amountPerSecond: number): void;\n  finalizeTick(deltaMs: number): void;\n  resetPerTickAccumulators(): void;\n  forceClearDirtyState(): void;\n  clearDirtyScratch(): void;\n  snapshot(options?: { mode?: 'publish' | 'recorder' }): ResourceStateSnapshot;\n  exportForSave(): SerializedResourceState;\n  getDefinitionDigest(): ResourceDefinitionDigest;\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The module retains the ",(0,t.jsx)(n.code,{children:"ResourceStateBuffers"})," reference inside a closure so\nexternal callers can only mutate state through the fa\xe7ade. Instrumentation or\ndiagnostics that need raw access live in the same module and never receive a\npublic reference to the mutable typed arrays."]}),"\n",(0,t.jsx)(n.li,{children:"Mutation helpers return the actual delta applied to support downstream\nbookkeeping."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"requireIndex(id)"})," wraps ",(0,t.jsx)(n.code,{children:"getIndex"})," with an invariant check that throws and\nemits telemetry when presented with an unknown id. Index-based helpers call\nan internal ",(0,t.jsx)(n.code,{children:"assertValidIndex(index)"})," guard so typed arrays never absorb\nsilent out-of-bounds writes.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A private ",(0,t.jsx)(n.code,{children:"markDirty(index: number)"})," helper ensures each index is tracked only\nonce per tick. It consults the ",(0,t.jsx)(n.code,{children:"DIRTY_THIS_TICK"})," bit and ",(0,t.jsx)(n.code,{children:"dirtyIndexPositions"}),"\nmap before pushing into the scratch prefix, then records the assigned slot so\nfuture checks stay O(1). Every entry in ",(0,t.jsx)(n.code,{children:"dirtyIndexPositions"})," is initialized to\n",(0,t.jsx)(n.code,{children:"-1"}),"; the first call to ",(0,t.jsx)(n.code,{children:"markDirty"})," writes the index into ",(0,t.jsx)(n.code,{children:"dirtyIndexScratch"}),"\nat position ",(0,t.jsx)(n.code,{children:"dirtyIndexCount"}),", persists that position inside the map, and\nincrements the count. The helper is invoked only after confirming the live\nstate and the active publish buffer fail ",(0,t.jsx)(n.code,{children:"epsilonEquals"})," for any tracked field\n(amount, capacity, income, expense, net, or flags). If a later mutation\nrestores parity and ",(0,t.jsx)(n.code,{children:"epsilonEquals"})," returns true again, ",(0,t.jsx)(n.code,{children:"unmarkIfClean(index)"}),"\nreads the stored slot, swaps the tail entry into place, updates both impacted\n",(0,t.jsx)(n.code,{children:"dirtyIndexPositions"})," entries (the restored index and the swapped tail), clears\nthe dirty bit, and writes ",(0,t.jsx)(n.code,{children:"-1"})," back into the map. The publish pass introduces a\nsecond sentinel (",(0,t.jsx)(n.code,{children:"SCRATCH_VISITED = -2"}),") while it performs unioned work over\nprevious/current dirty sets, then restores the map to ",(0,t.jsx)(n.code,{children:"-1"})," afterward. Zero-delta\nwork therefore never leaks into the publish pipeline and the scratch prefix\nalways remains densely packed without allocations."]}),"\n",(0,t.jsxs)(n.li,{children:["To prevent callers from skipping the epsilon/dirty bookkeeping, every fa\xe7ade\nhelper routes writes through ",(0,t.jsx)(n.code,{children:"updateFloatField(index, field, nextValue)"})," and\n",(0,t.jsx)(n.code,{children:"updateFlagField(index, mask, shouldSet)"})," utilities defined inside the module.\nThese helpers centralize the ",(0,t.jsx)(n.code,{children:"epsilonEquals"})," comparison, dirty bit toggling,\nand ",(0,t.jsx)(n.code,{children:"dirtyIndexPositions"})," maintenance so individual mutators cannot drift out\nof sync."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Internal maintenance code uses ",(0,t.jsx)(n.code,{children:"writeAmountDirect(index, amount)"})," to bypass\ncapacity clamping during save restore or migrations. The helper is not part of\nthe public fa\xe7ade and is only callable from privileged modules in the same\nfile so gameplay code must go through ",(0,t.jsx)(n.code,{children:"addAmount"}),". For tooling, the module\nexposes an opt-in escape hatch ",(0,t.jsx)(n.code,{children:"__unsafeWriteAmountDirect(state, index, amount)"}),"\nthat routes through the same helper; callers are expected to guard their inputs\nand remain confined to hydration/migration flows.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"finalizeTick(deltaMs)"})," converts accumulated per-second rates into a proposed\ndelta, clamps amounts to capacities/zero, recomputes ",(0,t.jsx)(n.code,{children:"netPerSecond"}),", and relies\non ",(0,t.jsx)(n.code,{children:"markDirty"})," + ",(0,t.jsx)(n.code,{children:"unmarkIfClean"})," to ensure only indices with meaningful\ndivergence remain dirty at the end of the tick (cancelling incomes/expenses do\nnot surface spurious deltas). The conversion uses\n",(0,t.jsx)(n.code,{children:"deltaSeconds = deltaMs / 1_000"}),", computes ",(0,t.jsx)(n.code,{children:"incomeDelta = incomePerSecond * deltaSeconds"}),", ",(0,t.jsx)(n.code,{children:"expenseDelta = expensePerSecond * deltaSeconds"}),",\nand derives a tentative ",(0,t.jsx)(n.code,{children:"appliedDelta = incomeDelta - expenseDelta"}),". After\nclamping the live amount into ",(0,t.jsx)(n.code,{children:"[0, capacity]"}),", we recompute the\n",(0,t.jsx)(n.code,{children:"actualDelta = clampedAmount - previousAmount"})," and calculate\n",(0,t.jsx)(n.code,{children:"nextTickDelta = tickDelta[index] + actualDelta"}),". When ",(0,t.jsx)(n.code,{children:"epsilonEquals(nextTickDelta, 0)"}),"\nsucceeds we reset ",(0,t.jsx)(n.code,{children:"tickDelta[index] = 0"}),"; otherwise we assign the computed\n",(0,t.jsx)(n.code,{children:"nextTickDelta"}),". We never clear an existing non-zero ",(0,t.jsx)(n.code,{children:"tickDelta"})," unless the\ncombined value reconciles to ~0 so earlier frame work (e.g., capacity adjustments\nor direct grants) survives the finalize pass. Dirty bookkeeping and telemetry\nalways use ",(0,t.jsx)(n.code,{children:"actualDelta"})," so resources that hit their cap/zero do not remain in\nthe dirty set indefinitely. Callers must pass a finite, non-negative ",(0,t.jsx)(n.code,{children:"deltaMs"}),";\notherwise telemetry emits ",(0,t.jsx)(n.code,{children:"ResourceFinalizeInvalidDelta"})," and the helper throws\nbefore mutating any buffers, preventing clock drift or ",(0,t.jsx)(n.code,{children:"NaN"})," propagation from\ncorrupting state."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"resetPerTickAccumulators()"})," clears the live ",(0,t.jsx)(n.code,{children:"incomePerSecond"}),",\n",(0,t.jsx)(n.code,{children:"expensePerSecond"}),", and ",(0,t.jsx)(n.code,{children:"tickDelta"})," arrays after publish while leaving the\npublish buffers untouched thanks to the ping-pong double buffering. It does\n",(0,t.jsx)(n.strong,{children:"not"})," zero ",(0,t.jsx)(n.code,{children:"netPerSecond"}),"; that value remains valid until the next\n",(0,t.jsx)(n.code,{children:"finalizeTick"})," so systems sampling immediately after publish observe the most\nrecent rates. The helper asserts that ",(0,t.jsx)(n.code,{children:"snapshot({ mode: 'publish' })"})," has already\nexecuted during the current tick (tracked via an internal boolean toggled by the\nsnapshot path); calling it out of order throws and logs telemetry because clearing\nthe accumulators before publish would erase the tick delta that the UI expects to\nconsume."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"clearDirtyScratch()"})," clears residual dirty metadata and associated flag bits\nafter authoritative calls to ",(0,t.jsx)(n.code,{children:"snapshot({ mode: 'publish' })"})," complete (the\nsnapshot path itself resets the scratch length to zero). For rare flows that\nintentionally skip publish (e.g. deterministic test harnesses comparing\nrecorder snapshots) the module exposes ",(0,t.jsx)(n.code,{children:"forceClearDirtyState()"})," which performs\nthe same scratch reset ",(0,t.jsx)(n.em,{children:"and"})," clears ",(0,t.jsx)(n.code,{children:"incomePerSecond"}),", ",(0,t.jsx)(n.code,{children:"expensePerSecond"}),", and\n",(0,t.jsx)(n.code,{children:"tickDelta"}),' under an internal "publish skipped" guard. Callers must invoke\n',(0,t.jsx)(n.code,{children:"forceClearDirtyState()"})," instead of ",(0,t.jsx)(n.code,{children:"resetPerTickAccumulators()"})," in that\nscenario so rate accumulators do not desynchronise. Production code relies on\n",(0,t.jsx)(n.code,{children:"snapshot({ mode: 'publish' })"})," instead of calling either helper directly."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"getDefinitionDigest()"})," returns the frozen ",(0,t.jsx)(n.code,{children:"{ ids, version, hash }"})," payload\nrecorded during initialization so save serializers can embed it and hydration\nroutines can check compatibility before replaying data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"snapshot(options)"})," defaults to ",(0,t.jsx)(n.code,{children:"{ mode: 'publish' }"}),". Callers opt into\nrecorder mode explicitly so accidental captures do not skip the publish reset."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The fa\xe7ade tracks the active length in a ",(0,t.jsx)(n.code,{children:"dirtyIndexCount"})," field; the valid\nportion of ",(0,t.jsx)(n.code,{children:"dirtyIndexScratch"})," lives in ",(0,t.jsx)(n.code,{children:"[0, dirtyIndexCount)"}),". Mutations append\nindices only when the dirty bit transitions from clear to set, guaranteeing that\neach index appears at most once per tick without extra allocations. Whenever\nthe list changes, ",(0,t.jsx)(n.code,{children:"dirtyIndexPositions"})," keeps the index \u2194 position mapping in\nsync so removals and parity-driven unmarks stay constant time even in the hot\npath."]}),"\n",(0,t.jsx)(n.h3,{id:"53-initialization--lifecycle",children:"5.3 Initialization & Lifecycle"}),"\n",(0,t.jsxs)(n.p,{children:["Provide a factory ",(0,t.jsx)(n.code,{children:"createResourceState(defs: readonly ResourceDefinition[])"}),"\nthat:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Validates incoming definitions without reordering so designer-authored order\nis preserved and surfaces deterministically in presentation. The content pack\ncompiler guarantees a stable array order; the factory verifies uniqueness by\ninserting ids into a ",(0,t.jsx)(n.code,{children:"Set"})," and throws on duplicates."]}),"\n",(0,t.jsxs)(n.li,{children:["Allocates typed arrays sized to the resource count. Initialization passes\neach definition through ",(0,t.jsx)(n.code,{children:"sanitizeInitialResourceValues"}),", which clamps\n",(0,t.jsx)(n.code,{children:"startAmount"})," into ",(0,t.jsx)(n.code,{children:"[0, capacity]"}),", rejects ",(0,t.jsx)(n.code,{children:"NaN"}),"/non-finite input with a\ntelemetry event and thrown error, and logs + clamps negative values to ",(0,t.jsx)(n.code,{children:"0"})," or\novershoot values down to the capacity. The sanitized amounts populate both\nthe live ",(0,t.jsx)(n.code,{children:"amounts"})," array and the mirrored publish buffers. Capacities default\nto ",(0,t.jsx)(n.code,{children:"Number.POSITIVE_INFINITY"})," when unspecified (and populate both publish\nviews) so the initial snapshot requires no additional copying. The retainers\ntrack the active publish buffer index (",(0,t.jsx)(n.code,{children:"0"})," at bootstrap) and mark the standby\nbuffer ready for the next tick, clearing each publish buffer's ",(0,t.jsx)(n.code,{children:"dirtyCount"})," to\n",(0,t.jsx)(n.code,{children:"0"}),". The save serializer treats ",(0,t.jsx)(n.code,{children:"Number.POSITIVE_INFINITY"})," as ",(0,t.jsx)(n.code,{children:"null"})," to avoid\nlossy JSON round-trips."]}),"\n",(0,t.jsxs)(n.li,{children:["Initializes ",(0,t.jsx)(n.code,{children:"flags"})," with ",(0,t.jsx)(n.code,{children:"VISIBLE | UNLOCKED"})," for starting resources and\nzero for locked ones."]}),"\n",(0,t.jsxs)(n.li,{children:["Populates ",(0,t.jsx)(n.code,{children:"dirtyTolerance[index]"})," with the sanitized tolerance from the\ndefinition (if provided) or ",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_CEILING"}),". Sanitization clamps the\ntolerance between ",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_ABSOLUTE"})," and ",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_OVERRIDE_MAX"}),", and\neach publish buffer stores the same scalar so comparison logic receives a\nper-resource ceiling regardless of which buffer is active. Overrides that land\nabove the default ceiling but within the max let prestige-scale resources relax\ntheir noise floor deterministically."]}),"\n",(0,t.jsxs)(n.li,{children:["Wraps ",(0,t.jsx)(n.code,{children:"ids"})," in ",(0,t.jsx)(n.code,{children:"Object.freeze"})," and converts the ",(0,t.jsx)(n.code,{children:"indexById"})," lookup table into\nan ",(0,t.jsx)(n.code,{children:"ImmutableMapSnapshot"})," via the existing ",(0,t.jsx)(n.code,{children:"enforceImmutable(...)"})," helper so\nany attempt to mutate it throws at runtime."]}),"\n",(0,t.jsxs)(n.li,{children:["Seeds the ",(0,t.jsx)(n.code,{children:"dirtyIndexScratch"})," array with a sentinel length counter of ",(0,t.jsx)(n.code,{children:"0"}),"\n(tracked separately inside the fa\xe7ade) and fills ",(0,t.jsx)(n.code,{children:"dirtyIndexPositions"})," with\n",(0,t.jsx)(n.code,{children:"-1"})," so the first mutation appends in-place without additional setup."]}),"\n",(0,t.jsxs)(n.li,{children:["Emits a ",(0,t.jsx)(n.code,{children:"ResourceDefinitionDigest"})," record ",(0,t.jsx)(n.code,{children:"{ ids, version, hash }"})," so save\nrestores can verify content compatibility before hydrating. When hydrating a\nsave the runtime invokes ",(0,t.jsx)(n.code,{children:"reconcileSaveAgainstDefinitions(savedIds, defs)"}),"\nwhich produces a mapping from save index \u2192 live index, reports removed/added\nids, and throws if a referenced id no longer exists. Mismatches surface\ntelemetry (",(0,t.jsx)(n.code,{children:"ResourceHydrationMismatch"}),") and fail fast instead of silently\ndropping data; future migrations can hook into this reconciliation step to map\nold ids onto new ones."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["On content reload or save restore, callers reuse the factory with definitions\nand then hydrate numeric buffers from persisted data. ",(0,t.jsx)(n.code,{children:"reconcileSaveAgainstDefinitions"}),"\ndrives the process: it verifies payload array lengths, produces a remapping from\nsave indices to live indices, and rejects any out-of-band data. Hydration iterates\nthe remapping, writes restored amount/capacity values and flag bits into both the\nlive and publish typed arrays, zeros ",(0,t.jsx)(n.code,{children:"incomePerSecond"}),", ",(0,t.jsx)(n.code,{children:"expensePerSecond"}),",\n",(0,t.jsx)(n.code,{children:"netPerSecond"}),", and ",(0,t.jsx)(n.code,{children:"tickDelta"})," in both views, and clears the dirty scratch counter\nso the next ",(0,t.jsx)(n.code,{children:"snapshot({ mode: 'publish' })"})," immediately reflects the restored state\nwithout forcing a full-tick recomputation. Until the first post-restore tick runs\nthe UI should expect rate diagnostics to read as zero; the follow-up finalize\nrecomputes rates deterministically. The runtime stores the ",(0,t.jsx)(n.code,{children:"ResourceState"})," inside\nthe broader game state object managed by ",(0,t.jsx)(n.code,{children:"setGameState(...)"}),"; systems recompute\nper-second rates on the very next tick using the hydrated amounts. Save restore and\nmigration utilities invoke the internal ",(0,t.jsx)(n.code,{children:"writeAmountDirect"})," helper during this\nprocess so they can place values that temporarily exceed caps before the relevant\nupgrades reapply. Immediately after hydration the engine reapplies content-defined\ncapacities/upgrades and only then schedules the next ",(0,t.jsx)(n.code,{children:"finalizeTick"}),". This ordering\nensures overshoot values survive long enough for upgrade modifiers to recreate the\nhigher caps; if no modifier reinstates a wider cap before finalize executes, the\nclamp (and corresponding telemetry) makes the data loss explicit to designers."]}),"\n",(0,t.jsx)(n.h3,{id:"54-mutation-semantics",children:"5.4 Mutation Semantics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Additions:"})," ",(0,t.jsx)(n.code,{children:"addAmount"})," increases ",(0,t.jsx)(n.code,{children:"amounts[index]"})," while always clamping to\ncapacity. Negative input throws to catch misuse; callers use ",(0,t.jsx)(n.code,{children:"spendAmount"})," for\ndecrements. If the applied delta resolves to zero (e.g. already at cap or the\ncaller adds ",(0,t.jsx)(n.code,{children:"0"}),"), the helper returns ",(0,t.jsx)(n.code,{children:"0"})," and avoids calling ",(0,t.jsx)(n.code,{children:"markDirty"}),". When\nthe applied delta is non-zero, it accumulates into ",(0,t.jsx)(n.code,{children:"tickDelta[index]"})," and\n",(0,t.jsx)(n.code,{children:"markDirty"})," tracks the index exactly once for the tick. Internal maintenance\nutilities (migrations, save restore) use a private ",(0,t.jsx)(n.code,{children:"writeAmountDirect"})," helper\nthat bypasses the clamp, never the public fa\xe7ade, so gameplay code cannot\naccidentally overshoot capacities."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Spending:"})," ",(0,t.jsx)(n.code,{children:"spendAmount"})," verifies ",(0,t.jsx)(n.code,{children:"amounts[index] >= amount"})," before\nsubtracting. It returns ",(0,t.jsx)(n.code,{children:"true/false"})," to signal insufficient resources and\nnever allows negative balances. Successful spends subtract from both\n",(0,t.jsx)(n.code,{children:"amounts[index]"})," and ",(0,t.jsx)(n.code,{children:"tickDelta[index]"}),", then call ",(0,t.jsx)(n.code,{children:"markDirty"}),". If the spend\nlater gets cancelled by a compensating ",(0,t.jsx)(n.code,{children:"addAmount"})," before publish, the helper\ncalls ",(0,t.jsx)(n.code,{children:"unmarkIfClean"})," once the live values satisfy ",(0,t.jsx)(n.code,{children:"epsilonEquals"})," with the\npublish buffer, dropping the index from the scratch list. When spending fails,\ntelemetry records a ",(0,t.jsx)(n.code,{children:"ResourceSpendFailed"})," event with the offending\ncommand/system id (when supplied via ",(0,t.jsx)(n.code,{children:"ResourceSpendAttemptContext"}),") and the guard throws if the caller attempts to subtract a\nnegative amount."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Per-second accumulation:"})," Systems call ",(0,t.jsx)(n.code,{children:"applyIncome"})," / ",(0,t.jsx)(n.code,{children:"applyExpense"}),"\nduring their tick. Inputs must be finite (",(0,t.jsx)(n.code,{children:"Number.isFinite"}),") and non-negative;\nattempts to submit negative, ",(0,t.jsx)(n.code,{children:"NaN"}),", or infinite rates log telemetry and throw.\nEach helper adds to (",(0,t.jsx)(n.code,{children:"+="}),") ",(0,t.jsx)(n.code,{children:"incomePerSecond[index]"})," and\n",(0,t.jsx)(n.code,{children:"expensePerSecond[index]"}),", allowing multiple systems to compose within a\nsingle frame. Helpers ignore zero-valued inputs and mark the resource dirty\nonly when the accumulator fails ",(0,t.jsx)(n.code,{children:"epsilonEquals"})," against the most recent\npublish buffer. If opposing calls cancel each other within the same tick,\n",(0,t.jsx)(n.code,{children:"unmarkIfClean"})," clears the dirty flag once the accumulators drift back inside\nthe epsilon band and the previously published buffer retains the prior rates."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Capacity updates:"})," ",(0,t.jsx)(n.code,{children:"setCapacity"})," validates the requested capacity (must be\n",(0,t.jsx)(n.code,{children:">= 0"}),", not ",(0,t.jsx)(n.code,{children:"NaN"}),"; ",(0,t.jsx)(n.code,{children:"Infinity"})," is permitted to represent uncapped resources)\nbefore writing into the buffer. Invalid values log telemetry and throw. On\nsuccess the helper clamps the current amount if it now exceeds the cap\n(recording that clamp as a delta in ",(0,t.jsx)(n.code,{children:"tickDelta"}),"), calls ",(0,t.jsx)(n.code,{children:"markDirty"}),", and\nreturns the applied cap so command handlers can publish diffs. The subsequent\npublish copies the new cap into the active publish buffer."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Visibility/unlock:"})," ",(0,t.jsx)(n.code,{children:"grantVisibility"})," and ",(0,t.jsx)(n.code,{children:"unlock"})," set bits inside the\nflag buffer and mark the resource dirty so the UI is notified."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Dirty tracking (flag bit ",(0,t.jsx)(n.code,{children:"0b100"}),") is cleared inside ",(0,t.jsx)(n.code,{children:"snapshot({ mode: 'publish' })"}),"\nonly after the live values and flag bits have been copied into the publish\nbuffers. The same loop clears the bit in both the live flag array (so subsequent\nmutations have to re-mark the resource) and the publish copy (by masking the bit\nbefore exposure). Clearing the bit at this point keeps the underlying live\nbuffers mutable while guaranteeing the published snapshot remains immutable."]}),"\n",(0,t.jsxs)(n.p,{children:["Every index-based helper calls ",(0,t.jsx)(n.code,{children:"assertValidIndex(index)"}),", which verifies\n",(0,t.jsx)(n.code,{children:"index >= 0 && index < resourceCount"}),", logs a ",(0,t.jsx)(n.code,{children:"ResourceIndexViolation"})," telemetry\nevent, and throws when the guard fails. Command handlers invoke ",(0,t.jsx)(n.code,{children:"requireIndex"}),"\nso the guard fires at lookup time rather than after a mutation attempt."]}),"\n",(0,t.jsx)(n.h3,{id:"55-snapshot--persistence",children:"5.5 Snapshot & Persistence"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"snapshot({ mode: 'publish' })"})," returns a ",(0,t.jsx)(n.em,{children:"read-only-by-contract"})," view\n(",(0,t.jsx)(n.code,{children:"ResourceStateSnapshot"}),") containing:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ids"})," (frozen array)."]}),"\n",(0,t.jsxs)(n.li,{children:["Direct references to the publish buffer's typed arrays. To keep cache-friendly\nhot reads intact we still hand out the live views, but the runtime installs a\nlightweight ",(0,t.jsx)(n.code,{children:"createImmutableTypedArrayView(...)"})," wrapper over each view in\nnon-production builds. The wrapper traps mutators, forwards safe reads, and\nthrows when a consumer attempts to write. Production builds may disable the\nguard by clearing ",(0,t.jsx)(n.code,{children:"SNAPSHOT_GUARDS"}),", but tests and development builds force it\non by default so accidental mutations cannot corrupt determinism. The flag now\nsupports three modes: ",(0,t.jsx)(n.code,{children:"'auto'"})," (default; enabled for ",(0,t.jsx)(n.code,{children:"NODE_ENV !== 'production'"}),"),\n",(0,t.jsx)(n.code,{children:"'force-on'"}),", and ",(0,t.jsx)(n.code,{children:"'force-off'"}),", giving automation harnesses explicit control.\nGuarded views share their backing buffer with the publish arrays so the check\ncosts a single proxy allocation per field rather than deep cloning; structured\ncloning paths use recorder mode instead."]}),"\n",(0,t.jsxs)(n.li,{children:["The typed arrays surface only to same-thread consumers. Cross-thread transport\nhappens through the ",(0,t.jsx)(n.code,{children:"ResourcePublishTransport"})," (see below); attempting to\n",(0,t.jsx)(n.code,{children:"postMessage"})," a ",(0,t.jsx)(n.code,{children:"ResourceStateSnapshot"})," is unsupported and intentionally\nundocumented in the runtime API."]}),"\n",(0,t.jsxs)(n.li,{children:["A compact list of dirty indices for the current tick. Consumers read the\nshared ",(0,t.jsx)(n.code,{children:"Uint32Array"})," prefix ",(0,t.jsx)(n.code,{children:"[0, dirtyCount)"})," and must ignore unused\ncapacity beyond that point; the array remains read-only by contract just\nlike the other typed views."]}),"\n",(0,t.jsxs)(n.li,{children:["Flag bits encoded as a read-only ",(0,t.jsx)(n.code,{children:"Uint8Array"})," snapshot sourced from\n",(0,t.jsx)(n.code,{children:"targetPublish.flags"}),".\nThe publish snapshot type is therefore:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface ResourceStateSnapshot {\n  readonly ids: readonly string[];\n  readonly amounts: Float64Array;\n  readonly capacities: Float64Array;\n  readonly incomePerSecond: Float64Array;\n  readonly expensePerSecond: Float64Array;\n  readonly netPerSecond: Float64Array;\n  readonly tickDelta: Float64Array;\n  readonly flags: Uint8Array;\n  readonly dirtyTolerance: Float64Array;\n  readonly dirtyIndices: Uint32Array;\n  readonly dirtyCount: number;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The TypeScript surface marks these arrays as ",(0,t.jsx)(n.code,{children:"readonly"})," to call out the contract.\nIn ",(0,t.jsx)(n.code,{children:"'auto'"}),"/",(0,t.jsx)(n.code,{children:"'force-on'"})," guard modes the runtime swaps each typed array reference\nfor the immutable proxy returned by ",(0,t.jsx)(n.code,{children:"createImmutableTypedArrayView(...)"}),", keeping\nthe same underlying buffer while disallowing writes in development and test\nenvironments. Recorder mode returns the same interface, but the arrays are\ndeep-cloned and own their backing buffers regardless of guard configuration so\nstructured cloning cannot observe shared state."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"snapshot({ mode: 'recorder' })"})," returns the same shape but clones its data\ninto ephemeral typed arrays owned by the recorder call site (amount, capacity,\nincome, expense, net, tick delta, flags, tolerance). This mode does not touch dirty\nbookkeeping, publish mirrors, or per-tick accumulators, allowing\npre/post-command captures without interfering with the presentation pipeline.\nThe full-clone approach is ",(0,t.jsx)(n.code,{children:"O(resourceCount)"})," per capture; for now we accept the\noverhead because command executions are infrequent in deterministic tests. If the\nworkload proves heavier, future work can explore reusing the inactive publish\nbuffer with reference counting or capturing only the dirty indices plus a shared\nfrozen baseline.\nRecorder-mode clones remain structured-clone friendly, so tooling can persist\nthem or ship them across worker boundaries without additional conversion."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"exportForSave()"})," returns a POJO suitable for persistence:"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface SerializedResourceState {\n  readonly ids: readonly string[];\n  readonly amounts: readonly number[];\n  readonly capacities: readonly (number | null)[];\n  readonly unlocked?: readonly boolean[];\n  readonly visible?: readonly boolean[];\n  readonly flags: readonly number[];\n}\n\ninterface ResourceSpendAttemptContext {\n  readonly commandId?: string;\n  readonly systemId?: string;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Offline catch-up consumes ",(0,t.jsx)(n.code,{children:"SerializedResourceState"}),", rehydrates the live typed\narrays, and continues deterministic execution. The save payload intentionally\nomits per-second income/expense data because they are tick-scoped diagnostics;\nthe runtime zeros those buffers (both live and publish views) on restore and\nregenerates fresh rates during the next tick."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"flags"})," mirrors the raw bit mask so future toggle bits survive round-trips even\nwhen older clients do not understand them. The optional ",(0,t.jsx)(n.code,{children:"unlocked"})," and\n",(0,t.jsx)(n.code,{children:"visible"})," arrays remain for ergonomic access in content tooling; when provided\nthey must stay in sync with the bit mask. ",(0,t.jsx)(n.code,{children:"reconcileSaveAgainstDefinitions"}),"\nvalidates that every array matches the ",(0,t.jsx)(n.code,{children:"ids.length"})," (",(0,t.jsx)(n.code,{children:"flags.length"})," must also\nmatch) and throws ",(0,t.jsx)(n.code,{children:"ResourceSaveLengthMismatch"})," when they do not; telemetry\ncaptures the offending metadata. During rehydration the module trusts ",(0,t.jsx)(n.code,{children:"flags"}),"\nas the single source of truth, rebuilding the convenience arrays from the mask\nso the emitted snapshot always reflects the authoritative bits."]}),"\n",(0,t.jsx)(n.h4,{id:"dual-mode-progression-snapshot-support-existing-implementation",children:"Dual-Mode Progression Snapshot Support (Existing Implementation)"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": This subsection documents ",(0,t.jsx)(n.strong,{children:"existing progression snapshot behavior"})," as shipped in PR #303 (",(0,t.jsx)(n.code,{children:"packages/core/src/progression.ts:138-214"}),"). This is retroactive documentation of production code."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"buildProgressionSnapshot()"})," function supports ",(0,t.jsx)(n.strong,{children:"dual-mode snapshot generation"}),", consuming either live ",(0,t.jsx)(n.code,{children:"ResourceState"})," or serialized ",(0,t.jsx)(n.code,{children:"SerializedResourceState"})," to build UI-ready ",(0,t.jsx)(n.code,{children:"ProgressionSnapshot"})," data. This enables both runtime snapshot publishing and save file preview."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Live State Mode"}),":"]}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"ProgressionAuthoritativeState.resources.state"})," contains a live ",(0,t.jsx)(n.code,{children:"ResourceState"})," instance:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const snapshot = state.snapshot({ mode: 'publish' });\n\nconst resourceView = {\n  id: resourceId,\n  displayName: metadata.get(resourceId)?.displayName ?? resourceId,\n  amount: snapshot.amounts[index],\n  capacity: snapshot.capacities[index],\n  isUnlocked: (snapshot.flags[index] & UNLOCKED_BIT) !== 0,\n  isVisible: (snapshot.flags[index] & VISIBLE_BIT) !== 0,\n  perTick: state.getNetPerSecond(index) * (stepDurationMs / 1000), // Live rate data\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Serialized State Mode"}),":"]}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"ProgressionAuthoritativeState.resources.serialized"})," contains ",(0,t.jsx)(n.code,{children:"SerializedResourceState"})," (during save preview or session restore):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const serialized = state.resources.serialized;\n\nconst resourceView = {\n  id: serialized.ids[index],\n  displayName: metadata.get(serialized.ids[index])?.displayName ?? serialized.ids[index],\n  amount: serialized.amounts[index],\n  capacity: serialized.capacities[index] ?? Infinity,\n  isUnlocked: serialized.unlocked?.[index] ?? false,\n  isVisible: serialized.visible?.[index] ?? false,\n  perTick: 0, // No rate data in serialized state\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Differences"}),":"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Aspect"}),(0,t.jsx)(n.th,{children:"Live State Mode"}),(0,t.jsx)(n.th,{children:"Serialized State Mode"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Data Source"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ResourceState.snapshot({ mode: 'publish' })"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"SerializedResourceState"})," from save file"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Rate Data"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"perTick"})," calculated from ",(0,t.jsx)(n.code,{children:"getNetPerSecond()"})]}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"perTick = 0"})," (rates not persisted)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Flag Access"})}),(0,t.jsxs)(n.td,{children:["Bit masks from ",(0,t.jsx)(n.code,{children:"snapshot.flags"})," typed array"]}),(0,t.jsxs)(n.td,{children:["Boolean arrays ",(0,t.jsx)(n.code,{children:"unlocked"}),"/",(0,t.jsx)(n.code,{children:"visible"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Capacity"})}),(0,t.jsx)(n.td,{children:"Live typed array value"}),(0,t.jsxs)(n.td,{children:["POJO number array with ",(0,t.jsx)(n.code,{children:"null"})," \u2192 ",(0,t.jsx)(n.code,{children:"Infinity"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Use Case"})}),(0,t.jsx)(n.td,{children:"Runtime worker snapshot publishing"}),(0,t.jsx)(n.td,{children:"Save file preview, session hydration"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),":"]}),"\n",(0,t.jsx)(n.p,{children:"The snapshot builder detects which mode to use by checking for live state first:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/progression.ts:146-211\nconst liveState = state.resources?.state;\nconst serializedState = state.resources?.serialized;\n\nif (liveState) {\n  // Live mode: use ResourceState snapshot\n  const snapshot = liveState.snapshot({ mode: 'publish' });\n  // Build resource views from typed arrays...\n} else if (serializedState) {\n  // Serialized mode: use save file data\n  // Build resource views from POJO arrays...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Rationale"}),":"]}),"\n",(0,t.jsx)(n.p,{children:"Dual-mode support enables:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Runtime publishing"}),": Worker emits progression snapshots every tick using live state"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Save preview"}),": UI can display save file contents without loading into live runtime"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Session restoration"}),": Initial snapshot after hydration uses serialized state before first tick"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistent UI contract"}),": Both modes produce identical ",(0,t.jsx)(n.code,{children:"ProgressionSnapshot"})," structure"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Integration"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Worker Runtime"}),": Calls ",(0,t.jsx)(n.code,{children:"buildProgressionSnapshot()"})," with live coordinator state after each tick (",(0,t.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:228-232"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Session Restore"}),": Initial snapshot uses serialized state from save file before coordinator rehydrates (",(0,t.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:652-798"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Save Preview"})," (future): Tooling can display save file contents by passing ",(0,t.jsx)(n.code,{children:"SerializedResourceState"})," directly"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implementation Reference"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Dual-mode snapshot builder: ",(0,t.jsx)(n.code,{children:"packages/core/src/progression.ts:138-214"})]}),"\n",(0,t.jsxs)(n.li,{children:["Live state path: ",(0,t.jsx)(n.code,{children:"packages/core/src/progression.ts:146-176"})]}),"\n",(0,t.jsxs)(n.li,{children:["Serialized state path: ",(0,t.jsx)(n.code,{children:"packages/core/src/progression.ts:178-211"})]}),"\n",(0,t.jsxs)(n.li,{children:["Integration in worker: ",(0,t.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:228-232"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Consumers should continue to respect the dirty index list when emitting deltas,\nand because the publish path zeros ",(0,t.jsx)(n.code,{children:"targetPublish.tickDelta"})," only for the\nexplicitly dirty candidates (step 1 below), a resource that resolves to clean\nstate never exposes a stale delta. Comparisons reuse the shared ",(0,t.jsx)(n.code,{children:"epsilonEquals"}),"\nhelper, meaning near-zero\ndifferences neither propagate into the publish buffer nor keep indices marked\ndirty."]}),"\n",(0,t.jsxs)(n.p,{children:["During ",(0,t.jsx)(n.code,{children:"snapshot({ mode: 'publish' })"})," the runtime selects the inactive publish\nbuffer (",(0,t.jsx)(n.code,{children:"targetPublish"}),") and records the current active buffer as\n",(0,t.jsx)(n.code,{children:"sourcePublish"}),". Rather than cloning the entire snapshot, the runtime reapplies\njust the slots that may have diverged while ",(0,t.jsx)(n.code,{children:"targetPublish"})," sat idle:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Visit the prior publish's dirty list and the current tick's scratch prefix\nin turn, zeroing ",(0,t.jsx)(n.code,{children:"targetPublish.tickDelta"})," for each unique index. We reuse\n",(0,t.jsx)(n.code,{children:"dirtyIndexPositions"})," to skip duplicates: before the pass we write a sentinel\n(",(0,t.jsx)(n.code,{children:"SCRATCH_VISITED = -2"}),") into ",(0,t.jsx)(n.code,{children:"dirtyIndexPositions[index]"})," for every index we\ntouch, and we skip further work whenever an index already equals that sentinel.\nAfter the pass the loop restores ",(0,t.jsx)(n.code,{children:"dirtyIndexPositions[index] = -1"}),", so the map\nis ready for the copy stage without allocating additional sets or arrays. No\nconcatenation or temporary buffers are required and the work remains\nproportional to the dirty set."]}),"\n",(0,t.jsxs)(n.li,{children:["Compute ",(0,t.jsx)(n.code,{children:"previousDirtyCount = sourcePublish.dirtyCount"})," and iterate the\nprefix ",(0,t.jsx)(n.code,{children:"sourcePublish.dirtyIndices[0..previousDirtyCount)"}),", copying the\ncorresponding amount/capacity/rate/flag entries from ",(0,t.jsx)(n.code,{children:"sourcePublish"})," into\n",(0,t.jsx)(n.code,{children:"targetPublish"})," while leaving their ",(0,t.jsx)(n.code,{children:"tickDelta"})," at zero. This guarantees the\ninactive buffer matches the authoritative snapshot for everything that\nchanged last tick."]}),"\n",(0,t.jsxs)(n.li,{children:["Reset ",(0,t.jsx)(n.code,{children:"targetPublish.dirtyCount = 0"})," and capture the current\n",(0,t.jsx)(n.code,{children:"dirtyIndexCount"})," into a local ",(0,t.jsx)(n.code,{children:"scratchCount"}),"; the scratch array contents\nremain intact until the loop finishes."]}),"\n",(0,t.jsxs)(n.li,{children:["Iterate the first ",(0,t.jsx)(n.code,{children:"scratchCount"})," entries in ",(0,t.jsx)(n.code,{children:"dirtyIndexScratch"}),", compare each\ncandidate against ",(0,t.jsx)(n.code,{children:"sourcePublish"})," using the epsilon test (\xa75.2), and write the\nlive values (amount, capacity, income, expense, net, tick delta, flags,\ntolerance) into ",(0,t.jsx)(n.code,{children:"targetPublish"})," when they diverge. ",(0,t.jsx)(n.code,{children:"dirtyTolerance"})," only changes\nduring initialization, hydration, or content reload flows; the tick loop never\nmutates it, so the comparison normally short-circuits unless a tooling action\nexplicitly updates the buffer. The flag copy masks out the engine-only\n",(0,t.jsx)(n.code,{children:"DIRTY_THIS_TICK"})," bit so consumers never observe internal bookkeeping. Slots that\nconverge leave the live ",(0,t.jsx)(n.code,{children:"tickDelta"})," untouched so recorder snapshots captured\nimmediately after publish still observe the accumulated delta; they simply skip\nthe dirty list. ",(0,t.jsx)(n.code,{children:"resetPerTickAccumulators()"})," (or ",(0,t.jsx)(n.code,{children:"forceClearDirtyState()"}),") remains\nresponsible for clearing the live accumulator once consumers finish reading it."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For each surviving index we write it into\n",(0,t.jsx)(n.code,{children:"targetPublish.dirtyIndices[targetPublish.dirtyCount++]"})," and mark\n",(0,t.jsx)(n.code,{children:"dirtyIndexPositions[index] = -1"})," so the next tick appends from a clean slate.\nAfter the loop the runtime flips ",(0,t.jsx)(n.code,{children:"activePublishIndex"}),", exposes the read-only\nviews, sets ",(0,t.jsx)(n.code,{children:"dirtyIndexCount = 0"}),", and walks both the ",(0,t.jsx)(n.code,{children:"previousDirtyCount"})," and\n",(0,t.jsx)(n.code,{children:"scratchCount"})," ranges to ensure every corresponding ",(0,t.jsx)(n.code,{children:"dirtyIndexPositions"})," entry\nis ",(0,t.jsx)(n.code,{children:"-1"})," (debug builds may also zero the scratch slots for readability). Because\nconsumers read from the now-active publish buffer only, later mutations operate\non the live arrays and the alternate publish buffer without affecting the\nsnapshot in circulation. ",(0,t.jsx)(n.code,{children:"clearDirtyScratch()"})," remains an escape hatch for test\nharnesses that need to force-reset live buffers without emitting a snapshot."]}),"\n",(0,t.jsx)(n.h3,{id:"56-integration-points",children:"5.6 Integration Points"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Command handlers:"})," ",(0,t.jsx)(n.code,{children:"COLLECT_RESOURCE"})," routes through ",(0,t.jsx)(n.code,{children:"addAmount"}),",\n",(0,t.jsx)(n.code,{children:"PURCHASE_GENERATOR"})," and future ",(0,t.jsx)(n.code,{children:"APPLY_MODIFIER"})," commands use ",(0,t.jsx)(n.code,{children:"spendAmount"}),"\nand ",(0,t.jsx)(n.code,{children:"setCapacity"}),". All handlers include resource ids to translate into indices\nvia ",(0,t.jsx)(n.code,{children:"requireIndex"}),", ensuring invalid content references surface as telemetry."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Systems:"})," Production, automation, and prestige systems receive the shared\n",(0,t.jsx)(n.code,{children:"ResourceState"})," instance on registration. Each system operates on indices\nrather than ids for tight loops; helper utilities resolve ids only during\ninitialization."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Telemetry:"})," The resource module records events via the existing\n",(0,t.jsx)(n.code,{children:"telemetry"})," facade (",(0,t.jsx)(n.code,{children:"TelemetryEventData"}),") for invalid operations, capacity\nclamping, overflow detection, and comparisons that saturate a resource's dirty\ntolerance ceiling. Metrics aggregate per-second income/expense totals for\ndiagnostics dashboards."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Presentation bridge:"})," When publishing state to the UI, the runtime emits\neither the full snapshot (initial load) or a delta referencing dirty indices\nwith updated ",(0,t.jsx)(n.code,{children:"amount"}),", ",(0,t.jsx)(n.code,{children:"capacity"}),", per-second rates, ",(0,t.jsx)(n.code,{children:"netPerSecond"}),", and\n",(0,t.jsx)(n.code,{children:"visibility"})," flags. Before calling ",(0,t.jsx)(n.code,{children:"worker.postMessage"})," the bridge converts\nthe immutable typed-array views into a ",(0,t.jsx)(n.code,{children:"ResourcePublishTransport"})," built from\na pooled set of transferable slabs sized exactly to ",(0,t.jsx)(n.code,{children:"dirtyCount"}),". Each field\nis copied with a tight ",(0,t.jsx)(n.code,{children:"Float64Array"}),"/",(0,t.jsx)(n.code,{children:"Uint8Array"})," whose length equals the\nnumber of dirty indices, meaning the transport cost grows with the delta\nrather than ",(0,t.jsx)(n.code,{children:"resourceCount"}),". Slabs come from a ",(0,t.jsx)(n.code,{children:"TransportBufferPool"})," so the\nruntime reuses ",(0,t.jsx)(n.code,{children:"ArrayBuffer"}),"s across frames; the pool guarantees buffers are\ndetached only after the worker acknowledges receipt.\nThe transport contract is versioned (",(0,t.jsx)(n.code,{children:"version: 2"}),") and self-describing:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"type TransportComponent =\n  | 'amounts'\n  | 'capacities'\n  | 'incomePerSecond'\n  | 'expensePerSecond'\n  | 'netPerSecond'\n  | 'tickDelta'\n  | 'flags'\n  | 'dirtyTolerance';\n\ninterface TransportBufferDescriptor {\n  readonly component: TransportComponent;\n  readonly ctor: 'Float64Array' | 'Uint8Array';\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: number;\n  readonly length: number;\n}\n\ninterface ResourcePublishTransport {\n  readonly version: 2;\n  readonly ids: readonly string[];\n  readonly dirtyIndices: Uint32Array;\n  readonly buffers: readonly TransportBufferDescriptor[];\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Every descriptor includes the typed-array constructor string, length, and\nbyte offset so consumers can rebuild deterministic views without hard-coded\nassumptions. Single-threaded presentation (no worker) still goes through the\ntransport builder, but instead of transferring the buffers we hand the pooled\ntyped arrays directly to the UI diff routine, keeping the zero-copy path."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Command recorder:"})," The recorder uses ",(0,t.jsx)(n.code,{children:"snapshot({ mode: 'recorder' })"}),"\nbefore/after command execution to capture deterministic replays; this mode\ndeep-clones the live view so structured cloning succeeds without disturbing\nthe dirty tracking that the presentation layer relies on."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"57-implementation-plan",children:"5.7 Implementation Plan"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Scaffold ",(0,t.jsx)(n.code,{children:"packages/core/src/resource-state.ts"})," with the buffer structs,\nfactory, and fa\xe7ade."]}),"\n",(0,t.jsxs)(n.li,{children:["Wire the module into existing exports (",(0,t.jsx)(n.code,{children:"packages/core/src/index.ts"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Add an opt-in snapshot guard helper to ",(0,t.jsx)(n.code,{children:"packages/core/src/immutable-snapshots.ts"}),"\nthat wraps typed arrays in write-throwing proxies when ",(0,t.jsx)(n.code,{children:"SNAPSHOT_GUARDS"})," is enabled,\nplus tests covering both the fast path (direct views) and the guarded debug path.\nConstructor references must remain passthrough so call sites can continue to\ninstantiate typed views via ",(0,t.jsx)(n.code,{children:"new snapshot.typed.constructor(length)"})," without\ntripping the guard."]}),"\n",(0,t.jsxs)(n.li,{children:["Implement the pooled buffer transport (",(0,t.jsx)(n.code,{children:"TransportBufferPool"}),") and bridge\nutilities that build ",(0,t.jsx)(n.code,{children:"ResourcePublishTransport"})," payloads proportional to the\ndirty set, including worker/non-worker code paths and metadata reconstruction."]}),"\n",(0,t.jsxs)(n.li,{children:["Add reconciliation helpers (",(0,t.jsx)(n.code,{children:"reconcileSaveAgainstDefinitions"}),", definition\ndigest emission) and expose ",(0,t.jsx)(n.code,{children:"forceClearDirtyState()"})," for test-only reset flows."]}),"\n",(0,t.jsxs)(n.li,{children:["Add Vitest coverage for initialization, mutation semantics, dirty tracking,\nduplicate-id guarding, snapshot generation (including ",(0,t.jsx)(n.code,{children:"null"})," persistence for\nuncapped capacities), income/expense publish mirroring, and rehydration from\npersisted saves. Include cases for per-resource ",(0,t.jsx)(n.code,{children:"dirtyTolerance"})," overrides\nsaturating ",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_OVERRIDE_MAX"})," and telemetry emission when the cap is\nhit."]}),"\n",(0,t.jsxs)(n.li,{children:["Update command handlers (future issue) to depend on ",(0,t.jsx)(n.code,{children:"ResourceState"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Extend documentation (",(0,t.jsx)(n.code,{children:"docs/runtime-command-queue-design.md"}),") with references\nto the new storage contract after implementation lands."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"6-testing-strategy",children:"6. Testing Strategy"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Unit tests verifying:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Deterministic preservation of the definition-supplied resource order (stable\nindices when the content array itself is stable)."}),"\n",(0,t.jsx)(n.li,{children:"Duplicate ids throw during initialization."}),"\n",(0,t.jsxs)(n.li,{children:["Initial amount sanitization clamps into ",(0,t.jsx)(n.code,{children:"[0, capacity]"}),", rejects non-finite\nvalues with telemetry + throw, and logs whenever a clamp occurs."]}),"\n",(0,t.jsxs)(n.li,{children:["Capacity enforcement (including accepting ",(0,t.jsx)(n.code,{children:"Infinity"}),") and telemetry emission\non attempted overflows."]}),"\n",(0,t.jsx)(n.li,{children:"Spending failure paths leave balances untouched."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"requireIndex"})," and ",(0,t.jsx)(n.code,{children:"assertValidIndex"})," telemetry + throw on unknown ids or\nout-of-range indices."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"finalizeTick"})," converts rates into clamped deltas given various ",(0,t.jsx)(n.code,{children:"deltaMs"}),"\nand suppresses changes whenever ",(0,t.jsx)(n.code,{children:"epsilonEquals(appliedDelta, 0)"})," succeeds."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"applyIncome"})," / ",(0,t.jsx)(n.code,{children:"applyExpense"})," reject negative, ",(0,t.jsx)(n.code,{children:"NaN"}),", or infinite inputs\nwith telemetry and throw."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dirtyTolerance"})," overrides clamp to the allowed range (",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_ABSOLUTE"}),"\n\u2192 ",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_OVERRIDE_MAX"}),"), influence\n",(0,t.jsx)(n.code,{children:"epsilonEquals"}),", surface telemetry when ceilings are reached, and round-trip\nthrough publish/recorder snapshots without allocation churn."]}),"\n",(0,t.jsxs)(n.li,{children:["Zero-value income/expense submissions, or opposing submissions that land\nwithin the epsilon band, do not mark resources dirty and rate changes still\npropagate into the publish buffers when ",(0,t.jsx)(n.code,{children:"epsilonEquals"})," fails."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dirtyIndexPositions"})," keeps tail swaps O(1) and is reset after publish."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"snapshot({ mode: 'publish' })"})," resets the dirty scratch counter while leaving\nthe published delta accessible and read-only through the double-buffered\nproxies, guaranteeing the snapshot emitted on the previous publish remains\nunchanged and documenting that older snapshots require cloning."]}),"\n",(0,t.jsxs)(n.li,{children:["Immutable snapshot guards throw in development/test builds and can be toggled\nwith ",(0,t.jsx)(n.code,{children:"SNAPSHOT_GUARDS"})," in production builds."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"snapshot({ mode: 'recorder' })"})," leaves dirty tracking and live buffers\nuntouched while returning a deep-clone suitable for structured cloning."]}),"\n",(0,t.jsx)(n.li,{children:"Dirty index tracking only flags mutated resources per tick."}),"\n",(0,t.jsxs)(n.li,{children:["Alternating add/spend sequences that mathematically cancel within the\nepsilon drop out of ",(0,t.jsx)(n.code,{children:"dirtyIndexScratch"})," before publish."]}),"\n",(0,t.jsx)(n.li,{children:"Publish snapshots copy only the union of the previous and current dirty\nindices; clean resources do not trigger full-buffer clones."}),"\n",(0,t.jsx)(n.li,{children:"Publish tick deltas are zeroed for indices that revert to their previous\nstate before publish."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ResourcePublishTransport"})," payloads only include ",(0,t.jsx)(n.code,{children:"dirtyCount"})," elements per\nfield, reuse pooled buffers, and reconstruct correctly on both worker and\nmain-thread consumers (including constructor metadata validation)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"forceClearDirtyState()"})," clears rate accumulators and scratch metadata without\nrequiring a publish, and ",(0,t.jsx)(n.code,{children:"resetPerTickAccumulators()"})," still throws when called\nbefore publish."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"exportForSave()"})," serializes uncapped capacities as ",(0,t.jsx)(n.code,{children:"null"})," and rehydrates to\n",(0,t.jsx)(n.code,{children:"Number.POSITIVE_INFINITY"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Rehydration from saves updates both live and publish buffers so the first\npublish after restore reflects the persisted values."}),"\n",(0,t.jsx)(n.li,{children:"Save reconciliation rejects mismatched ids/lengths and emits telemetry when\ndefinitions drift."}),"\n",(0,t.jsxs)(n.li,{children:["Snapshot tests ensuring immutable wrappers block mutation attempts (including\n",(0,t.jsx)(n.code,{children:".buffer"})," access and bulk mutators)."]}),"\n",(0,t.jsx)(n.li,{children:"Property-based tests (future follow-up) around additive/subtractive symmetry."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"7-risks--mitigations",children:"7. Risks & Mitigations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Precision drift & magnitude ceiling:"})," Using ",(0,t.jsx)(n.code,{children:"Float64Array"})," mitigates\ncumulative rounding error common in idle economies, but values above ",(0,t.jsx)(n.code,{children:"2^53"}),"\nlose integer precision. Balance tuning will monitor growth curves and, when\ndefinitions demand it, graduate to a fixed-point or logarithmic representation\ncaptured in a follow-up design doc."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Serialization cost:"})," Large typed arrays can inflate save size. Mitigate by\ndelta-encoding saves or compressing offline, tracked in a follow-up issue."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Publish diff cost:"})," Each publish now copies only the union of the previous\nand current dirty indices, so typical frames stay proportional to the change\nset. Worst-case churn (everything dirty every tick) degenerates to full-buffer\ncopies; telemetry will track publish duration so we can revisit the strategy\nif content packs grow orders of magnitude larger."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Content churn:"})," New resources require reinitialization. Mitigate by\ndefining migration utilities that map old saves onto new resource ordering."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Future threading needs:"})," If a separate worker manipulates resources, shared\nbuffers would require atomics. Out of scope now; document invariants so future\nwork can extend safely."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Proxy guard complexity:"})," Zero-copy typed-array proxies must replicate the\nexisting immutability guarantees. The implementation will live alongside the\nexisting snapshot utilities and include exhaustive tests for mutator trapping."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"8-decisions--clarifications",children:"8. Decisions & Clarifications"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prestige currencies:"})," Prestige and primary currencies share the same\n",(0,t.jsx)(n.code,{children:"ResourceState"}),". Content packs tag prestige entries in their definitions, and\nthe runtime stores that metadata alongside the immutable ",(0,t.jsx)(n.code,{children:"ids"})," array so\nsystems can branch without duplicating buffers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ordering:"})," Resource definitions keep the order supplied by the content pack.\nThe pack compiler owns determinism of that ordering, and the factory validates\nduplicates without re-sorting so design-authored presentation remains intact."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Income/expense accumulation:"})," ",(0,t.jsx)(n.code,{children:"applyIncome"})," / ",(0,t.jsx)(n.code,{children:"applyExpense"})," reset to zero\neach tick via ",(0,t.jsx)(n.code,{children:"resetPerTickAccumulators"}),". Rolling averages are calculated by\nanalytics code that consumes successive snapshots instead of mutating the core\nbuffers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Telemetry format:"})," Mutations emit structured telemetry events with\n",(0,t.jsx)(n.code,{children:"{resourceId, operation, amountBefore, amountAfter}"})," payloads. An optional\ndiagnostics system aggregates these into per-second summaries for dashboards\nwithout coupling the storage layer to presentation concerns."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Localized labels:"})," Snapshots expose resource ids only; UI and localization\nlayers resolve display names via the content pack metadata. This avoids sharing\nmutable strings or translation maps across module boundaries."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dirty tolerance configuration:"})," Content packs may provide an optional\n",(0,t.jsx)(n.code,{children:"dirtyTolerance"})," per resource; the factory normalizes the value into\n",(0,t.jsx)(n.code,{children:"dirtyTolerance[index]"})," (clamped only by ",(0,t.jsx)(n.code,{children:"DIRTY_EPSILON_OVERRIDE_MAX"}),"), the\npublish buffers mirror it, and telemetry fires when runtime changes push\ncomparisons up against the ceiling so designers can right-size the tolerance."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Snapshot guard defaults:"})," ",(0,t.jsx)(n.code,{children:"SNAPSHOT_GUARDS='auto'"})," enables immutable proxies\nin development and test builds automatically; production builds can override to\n",(0,t.jsx)(n.code,{children:"'force-on'"})," (hardened) or ",(0,t.jsx)(n.code,{children:"'force-off'"})," (maximum throughput)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Additional resolved clarifications:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The factory rejects duplicate resource ids up front, ensuring deterministic\nindexing."}),"\n",(0,t.jsxs)(n.li,{children:["The tick loop calls ",(0,t.jsx)(n.code,{children:"finalizeTick"})," after systems finish mutating rates and\nbalances, emits a snapshot, and then invokes ",(0,t.jsx)(n.code,{children:"resetPerTickAccumulators"}),"\nimmediately after the publish so subsequent reads observe cleared per-tick\nstate."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"setCapacity"})," accepts ",(0,t.jsx)(n.code,{children:"Infinity"})," to re-establish uncapped resources while\ncontinuing to reject ",(0,t.jsx)(n.code,{children:"NaN"})," and negatives."]}),"\n",(0,t.jsx)(n.li,{children:"Save rehydration writes values into both live and publish buffers and clears\ndirty scratch state before the next tick processes."}),"\n",(0,t.jsx)(n.li,{children:"Publish snapshots ping-pong between two typed-array sets; the runtime reuses\nthe buffer that is not currently active, so only the snapshot from the\nprevious publish is preserved without copying."}),"\n",(0,t.jsxs)(n.li,{children:["Dirty index positions reset to ",(0,t.jsx)(n.code,{children:"-1"})," after each publish, preserving O(1)\nremoval semantics for the next tick."]}),"\n",(0,t.jsxs)(n.li,{children:["The shared ",(0,t.jsx)(n.code,{children:"epsilonEquals"})," helper (absolute ",(0,t.jsx)(n.code,{children:"1e-9"}),", relative ",(0,t.jsx)(n.code,{children:"1e-9"}),", ceiling\n",(0,t.jsx)(n.code,{children:"1e-3"}),", optionally overridden per resource) governs all float comparisons\nbetween live and publish buffers so jitter never keeps resources dirty or\nproduces phantom deltas while still detecting meaningful changes at higher\nmagnitudes."]}),"\n",(0,t.jsx)(n.li,{children:"Publish snapshots guarantee immutability for the most recent publish only; any\nconsumer that needs to hold snapshots for longer must deep-clone the data."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"9-acceptance-criteria",children:"9. Acceptance Criteria"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Struct-of-arrays ",(0,t.jsx)(n.code,{children:"ResourceState"})," module checked into ",(0,t.jsx)(n.code,{children:"packages/core"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Deterministic initialization from sample content definitions."}),"\n",(0,t.jsxs)(n.li,{children:["Mutation helpers enforce caps, permit ",(0,t.jsx)(n.code,{children:"Infinity"})," for uncapped resources, and\nprevent negative balances."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"applyIncome"}),"/",(0,t.jsx)(n.code,{children:"applyExpense"})," reject negative, ",(0,t.jsx)(n.code,{children:"NaN"}),", or infinite rates while\nlogging telemetry for diagnostics."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"finalizeTick"})," converts per-second rates using ",(0,t.jsx)(n.code,{children:"deltaMs / 1_000"})," and suppresses\ndeltas whenever ",(0,t.jsx)(n.code,{children:"epsilonEquals(appliedDelta, 0)"})," succeeds to keep deterministic\nbehaviour."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"requireIndex"}),"/",(0,t.jsx)(n.code,{children:"assertValidIndex"})," guard invalid lookups with telemetry and\nexceptions."]}),"\n",(0,t.jsxs)(n.li,{children:["External consumers only mutate state through the fa\xe7ade; the module never\nhands out the live ",(0,t.jsx)(n.code,{children:"ResourceStateBuffers"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Snapshot API returns immutable data compatible with ",(0,t.jsx)(n.code,{children:"CommandRecorder"}),", and\nthe engine guarantees the most recent publish snapshot remains immutable; any\nconsumer that retains older snapshots must clone them explicitly."]}),"\n",(0,t.jsxs)(n.li,{children:["Snapshots expose zero-copy typed array views (read-only by contract) and honour\nthe optional ",(0,t.jsx)(n.code,{children:"SNAPSHOT_GUARDS"})," debug flag that wraps the arrays in write-throwing\nproxies without impacting the default fast path."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SNAPSHOT_GUARDS"})," defaults to enabled in development/test environments and can\nbe explicitly toggled for production builds."]}),"\n",(0,t.jsxs)(n.li,{children:["Dirty index scratch list and ",(0,t.jsx)(n.code,{children:"dirtyIndexPositions"})," map power delta publications\nwithout heap churn while keeping removals O(1)."]}),"\n",(0,t.jsxs)(n.li,{children:["Snapshot comparison and dirty tracking both honour ",(0,t.jsx)(n.code,{children:"epsilonEquals"}),", ensuring\nnear-zero float noise does not keep resources marked dirty."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dirtyTolerance"})," values are sanitized during initialization or hydration and\nmirrored into both live and publish buffers; they remain immutable during\nper-tick mutations so the delta pipeline can ignore them without losing\nruntime changes."]}),"\n",(0,t.jsx)(n.li,{children:"Publish mode replays the previous publish's dirty indices into the inactive\nbuffer, zeros their tick deltas, and then applies the current tick's dirty\nupdates so clean resources never incur full-buffer copies when buffers swap."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ResourcePublishTransport"})," payloads contain metadata describing each typed\narray and send only ",(0,t.jsx)(n.code,{children:"dirtyCount"})," elements per field via a pooled buffer strategy."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"reconcileSaveAgainstDefinitions"})," validates save payloads, enforces id parity,\nand reports mismatches instead of silently dropping data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"forceClearDirtyState()"})," provides an explicit non-publish reset path for tests\nwhile production flows continue to rely on publish."]}),"\n",(0,t.jsx)(n.li,{children:"Save rehydration updates both live and publish buffers so the next publish\nreflects persisted state without a warm-up tick."}),"\n",(0,t.jsx)(n.li,{children:"Unit tests cover initialization, mutation, and snapshot behaviors."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);