"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[2262],{457:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"issue-809-design","title":"renderer-webgpu: Reduce Per-Frame Allocations in Quad/Text Batching (Issue 809)","description":"Document Control","source":"@site/../../docs/issue-809-design.md","sourceDirName":".","slug":"/issue-809-design","permalink":"/Idle-Game-Engine/issue-809-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/issue-809-design.md","tags":[],"version":"current","sidebarPosition":99,"frontMatter":{"title":"renderer-webgpu: Reduce Per-Frame Allocations in Quad/Text Batching (Issue 809)","sidebar_position":99}}');var i=s(5270),t=s(7678);const d={title:"renderer-webgpu: Reduce Per-Frame Allocations in Quad/Text Batching (Issue 809)",sidebar_position:99},l="renderer-webgpu: Reduce Per-Frame Allocations in Quad/Text Batching (Issue 809)",a={},c=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Open Questions",id:"13-open-questions",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function o(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"renderer-webgpu-reduce-per-frame-allocations-in-quadtext-batching-issue-809",children:"renderer-webgpu: Reduce Per-Frame Allocations in Quad/Text Batching (Issue 809)"})}),"\n",(0,i.jsx)(n.h2,{id:"document-control",children:"Document Control"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Title"}),": Reduce per-frame allocations in WebGPU quad/text batching"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authors"}),": Codex (AI)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reviewers"}),": @hansjm10"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Draft"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Last Updated"}),": 2026-01-21"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Related Issues"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/809",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/809"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,i.jsxs)(n.p,{children:["The WebGPU renderer currently accumulates quad instance data in a ",(0,i.jsx)(n.code,{children:"number[]"})," and allocates a new ",(0,i.jsx)(n.code,{children:"Float32Array"})," on every batch flush, while text rendering pushes per-glyph instance data into the same hot array path. At higher draw/text volumes this produces avoidable GC pressure and frame-time spikes. This design replaces the hot-path ",(0,i.jsx)(n.code,{children:"number[]"})," with a reusable, growable ",(0,i.jsx)(n.code,{children:"Float32Array"})," instance builder (cursor-based writer) that is reused across flushes and frames, and updates the upload path to write only the used byte range without allocating new buffers in steady state."]}),"\n",(0,i.jsx)(n.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Background"}),": ",(0,i.jsx)(n.code,{children:"@idle-engine/renderer-webgpu"})," renders ",(0,i.jsx)(n.code,{children:"rect"}),", ",(0,i.jsx)(n.code,{children:"image"}),", and ",(0,i.jsx)(n.code,{children:"text"})," draws as instanced quads (",(0,i.jsx)(n.code,{children:"INSTANCE_STRIDE_BYTES = 48"}),", i.e. 12 floats per instance) using a single GPU instance buffer updated via ",(0,i.jsx)(n.code,{children:"device.queue.writeBuffer(...)"}),". Draws are sorted by pass and ",(0,i.jsx)(n.code,{children:"sortKey"})," (",(0,i.jsx)(n.code,{children:"orderDrawsByPassAndSortKey"}),") and then streamed through a quad batching loop that flushes when the pipeline kind changes (rect vs image), the pass changes (world vs ui), or scissor state changes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),": The quad batching loop builds up ",(0,i.jsx)(n.code,{children:"WebGpuQuadRenderState.batchInstances: number[]"})," and, on each flush, converts it into ",(0,i.jsx)(n.code,{children:"new Float32Array(state.batchInstances)"})," before uploading. Additionally, ",(0,i.jsx)(n.code,{children:"#resetQuadBatch"})," discards the existing array by assigning a new ",(0,i.jsx)(n.code,{children:"[]"}),". For text draws, ",(0,i.jsx)(n.code,{children:"appendBitmapTextInstances(...)"})," pushes 12 numbers per glyph into the same array. These repeated allocations and high-frequency ",(0,i.jsx)(n.code,{children:"push(...)"})," calls can create significant GC pressure and degrade performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Forces"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Preserve the renderer contract: ",(0,i.jsx)(n.code,{children:"RenderCommandBuffer"})," inputs and rendering outputs must remain behaviorally identical."]}),"\n",(0,i.jsx)(n.li,{children:"Keep batching semantics correct across pipeline/pass/scissor boundaries."}),"\n",(0,i.jsxs)(n.li,{children:["Ensure the solution works in both browser WebGPU and the test harness (stub WebGPU environment used by ",(0,i.jsx)(n.code,{children:"webgpu-renderer.test.ts"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goals"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Eliminate per-flush allocations in steady state (after buffers grow to the required capacity)."}),"\n",(0,i.jsxs)(n.li,{children:["Avoid ",(0,i.jsx)(n.code,{children:"number[]"})," usage on the hot path for quad and text instance accumulation."]}),"\n",(0,i.jsx)(n.li,{children:"Maintain the existing instance layout (pos/size, uv rect, color = 12 floats) and draw call behavior."}),"\n",(0,i.jsx)(n.li,{children:"Add a unit test or micro-benchmark that asserts buffer reuse behavior across multiple renders/flushes."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Non-Goals"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Redesigning draw ordering/grouping (",(0,i.jsx)(n.code,{children:"orderDrawsByPassAndSortKey"}),") or changing batching boundaries."]}),"\n",(0,i.jsx)(n.li,{children:"Implementing advanced text shaping/kerning or changing bitmap font layout rules."}),"\n",(0,i.jsxs)(n.li,{children:["Eliminating all allocations in ",(0,i.jsx)(n.code,{children:"render(...)"})," (e.g., ",(0,i.jsx)(n.code,{children:"#writeGlobals"})," currently allocates small temporary typed arrays); these may be follow-up optimizations."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Primary Stakeholders"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Renderer maintainers (",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Desktop shell maintainers relying on stable frame-time (",(0,i.jsx)(n.code,{children:"packages/shell-desktop"}),"), indirectly."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Agent Roles"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Docs Agent"}),": Maintain this design doc and track open questions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Renderer Implementation Agent"}),": Implement typed buffer builder + refactor quad/text batching to use it."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test/Perf Agent"}),": Update/add tests (and optional micro-benchmark) to prove reuse and prevent regressions."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Affected Packages/Services"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})," (batching + upload path)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})," (tests for buffer uploads and reuse)"]}),"\n",(0,i.jsxs)(n.li,{children:["(Optional) a new helper module under ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/"})," (typed buffer builder)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compatibility Considerations"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["No changes to ",(0,i.jsx)(n.code,{children:"@idle-engine/renderer-contract"})," or ",(0,i.jsx)(n.code,{children:"RenderCommandBuffer"})," formats."]}),"\n",(0,i.jsx)(n.li,{children:"The GPU-side instance vertex layout must remain unchanged (attribute order and stride)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"WebGpuRendererImpl"})," builds and flushes per-batch instance data as follows:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The render loop streams ordered draws through ",(0,i.jsx)(n.code,{children:"#renderQuadDrawEntry(...)"}),", which calls:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#handleRectDraw(...)"})," / ",(0,i.jsx)(n.code,{children:"#handleImageDraw(...)"}),": pushes 12 values per draw into ",(0,i.jsx)(n.code,{children:"state.batchInstances"})," and increments ",(0,i.jsx)(n.code,{children:"state.batchInstanceCount"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#handleTextDraw(...)"}),": calls ",(0,i.jsx)(n.code,{children:"appendBitmapTextInstances({ batchInstances: state.batchInstances, ... })"}),", which pushes 12 values per rendered glyph and returns the number of appended glyph instances."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Flushing (",(0,i.jsx)(n.code,{children:"#flushQuadBatch(...)"}),") converts the JS array to a typed array (",(0,i.jsx)(n.code,{children:"new Float32Array(state.batchInstances)"}),"), grows the GPU instance buffer if needed, and uploads the data using ",(0,i.jsx)(n.code,{children:"device.queue.writeBuffer(...)"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Resetting a batch (",(0,i.jsx)(n.code,{children:"#resetQuadBatch(...)"}),") discards the prior ",(0,i.jsx)(n.code,{children:"batchInstances"})," array by assigning ",(0,i.jsx)(n.code,{children:"state.batchInstances = []"}),", ensuring a new array allocation per flush/batch boundary."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The test suite (",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"}),") currently treats instance uploads as an ",(0,i.jsx)(n.code,{children:"ArrayBuffer"})," payload passed to ",(0,i.jsx)(n.code,{children:"queue.writeBuffer(...)"}),", and validates instance content by constructing ",(0,i.jsx)(n.code,{children:"new Float32Array(data)"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,i.jsx)(n.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Replace the hot ",(0,i.jsx)(n.code,{children:"number[]"})," accumulation with a reusable typed instance builder:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A growable ",(0,i.jsx)(n.code,{children:"Float32Array"})," buffer and a write cursor (float offset)."]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"reset()"})," method to set the cursor back to 0 without allocating."]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"reserve(requiredFloats)"})," / ",(0,i.jsx)(n.code,{children:"ensureCapacity(requiredFloats)"})," method to grow geometrically when needed."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Keep the current batching boundaries (kind/pass/scissor) but change writes from ",(0,i.jsx)(n.code,{children:"push(...)"})," to direct indexed writes into the typed buffer."]}),"\n",(0,i.jsxs)(n.li,{children:["Upload only the used portion of the builder\u2019s underlying ",(0,i.jsx)(n.code,{children:"ArrayBuffer"})," by using the ",(0,i.jsx)(n.code,{children:"dataOffset"}),"/",(0,i.jsx)(n.code,{children:"size"})," parameters of ",(0,i.jsx)(n.code,{children:"queue.writeBuffer(...)"})," (or equivalent ",(0,i.jsx)(n.code,{children:"ArrayBufferView"})," upload), avoiding ",(0,i.jsx)(n.code,{children:"slice(...)"})," allocations."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Diagram (conceptual)"}),":\n",(0,i.jsx)(n.code,{children:"ordered draws"})," \u2192 ",(0,i.jsx)(n.code,{children:"batch boundary checks"})," \u2192 ",(0,i.jsx)(n.code,{children:"typed instance writer (cursor)"})," \u2192 ",(0,i.jsx)(n.code,{children:"flush"})," \u2192 ",(0,i.jsx)(n.code,{children:"queue.writeBuffer(instanceBuffer, ..., size = usedBytes)"})," \u2192 ",(0,i.jsx)(n.code,{children:"reset cursor"})]}),"\n",(0,i.jsx)(n.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime Changes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Introduce a ",(0,i.jsx)(n.code,{children:"Float32ArrayBuilder"})," (name TBD) with:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"buffer: Float32Array"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lengthFloats: number"})," (cursor)"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"reset(): void"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ensureCapacity(requiredFloats: number): void"})," (doubling strategy; copies existing contents on growth)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Update ",(0,i.jsx)(n.code,{children:"WebGpuQuadRenderState"})," to store the builder (or store it on the renderer instance and reference it from render state) instead of ",(0,i.jsx)(n.code,{children:"batchInstances: number[]"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Update ",(0,i.jsx)(n.code,{children:"#handleRectDraw"}),", ",(0,i.jsx)(n.code,{children:"#handleImageDraw"}),", and ",(0,i.jsx)(n.code,{children:"appendBitmapTextInstances"})," to write directly into the typed buffer:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Write 12 floats per instance in the existing order: ",(0,i.jsx)(n.code,{children:"[x, y, w, h, u0, v0, u1, v1, r, g, b, a]"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Increment ",(0,i.jsx)(n.code,{children:"batchInstanceCount"})," as today, or derive it from ",(0,i.jsx)(n.code,{children:"lengthFloats / 12"})," (choose one and add invariants to keep them consistent)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Update ",(0,i.jsx)(n.code,{children:"#flushQuadBatch"})," to:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Compute ",(0,i.jsx)(n.code,{children:"usedBytes = lengthFloats * 4"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Call ",(0,i.jsx)(n.code,{children:"#ensureInstanceBuffer(usedBytes)"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Upload without allocating:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Preferred: ",(0,i.jsx)(n.code,{children:"queue.writeBuffer(instanceBuffer, 0, builder.buffer.buffer, 0, usedBytes)"})," (exact signature TBD per environment/types)."]}),"\n",(0,i.jsxs)(n.li,{children:["Alternative: ",(0,i.jsx)(n.code,{children:"queue.writeBuffer(instanceBuffer, 0, builder.buffer, 0, usedBytes)"})," (upload view directly)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Reset the builder cursor and batch metadata."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data & Schemas"}),": N/A."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"APIs & Contracts"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No external API changes."}),"\n",(0,i.jsxs)(n.li,{children:["If tests need visibility into reuse behavior, expose minimal internals via ",(0,i.jsx)(n.code,{children:"webgpu-renderer.ts"})," ",(0,i.jsx)(n.code,{children:"__test__"})," exports (e.g., a helper to access the instance builder identity) without making it part of the public renderer interface."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tooling & Automation"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Update ",(0,i.jsx)(n.code,{children:"webgpu-renderer.test.ts"})," expectations to accept the new ",(0,i.jsx)(n.code,{children:"writeBuffer"})," call shape (likely including ",(0,i.jsx)(n.code,{children:"dataOffset"}),"/",(0,i.jsx)(n.code,{children:"size"}),", and/or a ",(0,i.jsx)(n.code,{children:"Float32Array"})," payload)."]}),"\n",(0,i.jsx)(n.li,{children:"Add a unit test that renders twice and asserts the instance upload source buffer is reused once capacity is sufficient."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deployment"}),": No special rollout mechanics; change is internal to the renderer package."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Telemetry & Observability"}),": N/A in-code. For manual verification, use browser devtools allocation profiling or Node ",(0,i.jsx)(n.code,{children:"--trace-gc"})," during a high-volume render loop to confirm reduced GC churn."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security & Compliance"}),": No new data handling; no user input surfaces added."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,i.jsx)(n.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Issue Title"}),(0,i.jsx)(n.th,{children:"Scope Summary"}),(0,i.jsx)(n.th,{children:"Proposed Assignee/Agent"}),(0,i.jsx)(n.th,{children:"Dependencies"}),(0,i.jsx)(n.th,{children:"Acceptance Criteria"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"feat(renderer-webgpu): add reusable Float32Array builder"})}),(0,i.jsx)(n.td,{children:"Implement growable typed buffer + cursor utility"}),(0,i.jsx)(n.td,{children:"Renderer Implementation Agent"}),(0,i.jsx)(n.td,{children:"None"}),(0,i.jsx)(n.td,{children:"Builder supports reset + growth; no per-reset allocation"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"refactor(renderer-webgpu): use typed builder for quad/text batching"})}),(0,i.jsxs)(n.td,{children:["Replace ",(0,i.jsx)(n.code,{children:"number[]"})," writes and ",(0,i.jsx)(n.code,{children:"new Float32Array(...)"})," conversion with builder writes + upload by size"]}),(0,i.jsx)(n.td,{children:"Renderer Implementation Agent"}),(0,i.jsx)(n.td,{children:"Builder utility"}),(0,i.jsx)(n.td,{children:"Rendering output matches existing tests; steady-state flushes allocate 0 new arrays"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"test(renderer-webgpu): assert instance upload buffer reuse"})}),(0,i.jsx)(n.td,{children:"Update/add Vitest case to prove buffer identity reuse across renders/flushes"}),(0,i.jsx)(n.td,{children:"Test/Perf Agent"}),(0,i.jsx)(n.td,{children:"Refactor"}),(0,i.jsx)(n.td,{children:"Test fails if per-flush typed buffers are reallocated"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bench(renderer-webgpu): optional micro-benchmark for flush loop"})}),(0,i.jsx)(n.td,{children:"Small benchmark harness (Vitest or script) to quantify allocations/time"}),(0,i.jsx)(n.td,{children:"Test/Perf Agent"}),(0,i.jsx)(n.td,{children:"Refactor"}),(0,i.jsx)(n.td,{children:"Demonstrates reduced allocations in steady state (TBD metrics)"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 1"}),": Land builder + refactor + unit test proving reuse."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 2"}),": Optional follow-ups to reduce other per-frame allocations (e.g., globals scratch buffers) if profiling shows remaining hotspots."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hand-off Package"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})}),"\n",(0,i.jsxs)(n.li,{children:["(Optional) ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/<typed-builder>.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["This design doc: ",(0,i.jsx)(n.code,{children:"docs/issue-809-design.md"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Communication Cadence"}),": One reviewer pass after Phase 1; Phase 2 only if profiling data supports it."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Context Packets"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Issue 809: ",(0,i.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/809",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/809"})]}),"\n",(0,i.jsxs)(n.li,{children:["Renderer implementation: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Existing tests: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Instance layout constants: ",(0,i.jsx)(n.code,{children:"INSTANCE_STRIDE_BYTES"}),", shader ",(0,i.jsx)(n.code,{children:"VertexInput"})," in ",(0,i.jsx)(n.code,{children:"webgpu-renderer.ts"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prompting & Constraints"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Do not edit checked-in generated outputs under ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/dist/**"})," by hand."]}),"\n",(0,i.jsxs)(n.li,{children:["Preserve type-only imports/exports (",(0,i.jsx)(n.code,{children:"import type"})," / ",(0,i.jsx)(n.code,{children:"export type"}),") if adding new modules."]}),"\n",(0,i.jsxs)(n.li,{children:["Keep ",(0,i.jsx)(n.code,{children:"INSTANCE_STRIDE_BYTES"})," and attribute ordering unchanged unless the shader + pipeline are updated in lockstep (out of scope)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety Rails"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Always upload exactly ",(0,i.jsx)(n.code,{children:"instanceCount * INSTANCE_STRIDE_BYTES"})," bytes (no stale trailing data)."]}),"\n",(0,i.jsx)(n.li,{children:"Reset cursor and batch metadata on every flush and on early-out cases (empty batch, zero scissor rect)."}),"\n",(0,i.jsx)(n.li,{children:"Ensure growth logic is bounded and does not thrash (geometric growth; avoid per-instance reallocations)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation Hooks"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pnpm test --filter @idle-engine/renderer-webgpu"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pnpm lint --filter @idle-engine/renderer-webgpu"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Reuse ",(0,i.jsx)(n.code,{children:"number[]"})," instead of reallocating"]}),": Avoids ",(0,i.jsx)(n.code,{children:"state.batchInstances = []"}),", but still requires allocating a typed array (or copying) to upload to the GPU each flush."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Precompute and allocate per frame"}),": Build a single typed array for all instances in the frame. This complicates scissor boundaries and mixed rect/image/text batching, and may require extra passes over text to count glyphs."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pool per-flush typed arrays"}),": Reduces GC of buffers but still allocates frequently and increases complexity (pool sizing, lifetime, fragmentation)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mapped GPU buffers"}),": Using mapped-at-creation buffers or persistent mapping is not broadly viable and complicates WebGPU usage patterns; also likely increases complexity beyond this issue\u2019s scope."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unit / Integration"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Update ",(0,i.jsx)(n.code,{children:"webgpu-renderer.test.ts"})," to validate instance uploads when ",(0,i.jsx)(n.code,{children:"writeBuffer"})," uses ",(0,i.jsx)(n.code,{children:"dataOffset"}),"/",(0,i.jsx)(n.code,{children:"size"})," and/or a typed view payload."]}),"\n",(0,i.jsxs)(n.li,{children:["Add a new test that:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"renders a scene that triggers at least one flush and grows the instance builder to a non-trivial size,"}),"\n",(0,i.jsx)(n.li,{children:"renders the same scene again,"}),"\n",(0,i.jsxs)(n.li,{children:["asserts the instance upload source buffer identity is reused (same ",(0,i.jsx)(n.code,{children:"ArrayBuffer"})," or same builder object) and the ",(0,i.jsx)(n.code,{children:"size"})," argument matches the expected used bytes."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Optional micro-benchmark that runs a tight loop with many flushes and asserts stable buffer identity; record timing locally (no console output in CI beyond Vitest\u2019s reporter)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tooling / A11y"}),": N/A."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Risk"}),": Upload path writes the full underlying buffer instead of the used range, causing stale data to be rendered.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Mitigation"}),": Always pass ",(0,i.jsx)(n.code,{children:"size = instanceCount * INSTANCE_STRIDE_BYTES"})," (or ",(0,i.jsx)(n.code,{children:"lengthFloats * 4"}),") to ",(0,i.jsx)(n.code,{children:"writeBuffer"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Risk"}),": Cursor/instanceCount drift leads to incorrect ",(0,i.jsx)(n.code,{children:"drawIndexed"})," instance counts.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Mitigation"}),": Derive one from the other (single source of truth), and add assertions in tests (e.g., ",(0,i.jsx)(n.code,{children:"lengthFloats === instanceCount * 12"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Risk"}),": Tests become brittle due to different ",(0,i.jsx)(n.code,{children:"writeBuffer"})," argument types (",(0,i.jsx)(n.code,{children:"ArrayBuffer"})," vs ",(0,i.jsx)(n.code,{children:"ArrayBufferView"}),").",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Mitigation"}),": Update tests to validate content by constructing a ",(0,i.jsx)(n.code,{children:"Float32Array"})," view over the provided data with offsets/sizes instead of assuming ",(0,i.jsx)(n.code,{children:"data.byteLength"})," equals the used bytes."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Milestones"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Merge Phase 1 changes with passing tests."}),"\n",(0,i.jsx)(n.li,{children:"If desired, follow up with Phase 2 allocation reductions based on profiling."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Migration Strategy"}),": None."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Communication"}),": Note in the PR description that per-flush allocations were removed and include the new reuse test as evidence."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"13-open-questions",children:"13. Open Questions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Should Issue 809 also cover the small per-frame allocations in ",(0,i.jsx)(n.code,{children:"#writeGlobals(...)"})," (currently allocates a ",(0,i.jsx)(n.code,{children:"Float32Array"})," twice per render), or keep that as follow-up work?"]}),"\n",(0,i.jsxs)(n.li,{children:["What is the preferred test assertion shape for \u201cno per-flush allocation\u201d in this repo: buffer identity reuse, ",(0,i.jsx)(n.code,{children:"writeBuffer"})," argument inspection, or a dedicated benchmark harness?"]}),"\n",(0,i.jsxs)(n.li,{children:["Should the typed builder live inside ",(0,i.jsx)(n.code,{children:"webgpu-renderer.ts"})," (minimal surface area) or as a separate module under ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/"})," for reuse/testing?"]}),"\n",(0,i.jsxs)(n.li,{children:["Do we want to reserve capacity up-front based on draw counts (and ",(0,i.jsx)(n.code,{children:"text.length"})," as an upper bound) to reduce growth checks in the tight loop?"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Replace other small per-frame temporary typed arrays (",(0,i.jsx)(n.code,{children:"#writeGlobals"}),") with reusable scratch buffers if profiling shows they are meaningful."]}),"\n",(0,i.jsxs)(n.li,{children:["Consider reusing other transient arrays in render state (",(0,i.jsx)(n.code,{children:"scissorStack"}),") if scissor-heavy UIs become a hotspot."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"15-references",children:"15. References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Issue 809: ",(0,i.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/809",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/809"})]}),"\n",(0,i.jsxs)(n.li,{children:["Quad/text batching + flush allocation: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Instance upload tests: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Renderer package overview: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/README.md"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batch flush"}),": The point where accumulated instances are uploaded to the GPU and drawn (triggered by kind/pass/scissor boundaries)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Instance buffer"}),": The GPU vertex buffer containing per-quad instance attributes (12 floats per instance)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Steady state"}),": After the typed builder has grown to accommodate typical peak instance counts, subsequent frames should not allocate new buffers."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Typed buffer builder"}),": A growable typed array plus cursor used as a reusable write target for instance data."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Date"}),(0,i.jsx)(n.th,{children:"Author"}),(0,i.jsx)(n.th,{children:"Change Summary"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2026-01-21"}),(0,i.jsx)(n.td,{children:"Codex (AI)"}),(0,i.jsx)(n.td,{children:"Initial draft for Issue 809"})]})})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},7678:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var r=s(9430);const i={},t=r.createContext(i);function d(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);