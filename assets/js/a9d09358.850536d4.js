"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[9422],{1937:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"rng-prd-design-issue-590","title":"RNG PRD Design (Issue 590)","description":"Document Control","source":"@site/../../docs/rng-prd-design-issue-590.md","sourceDirName":".","slug":"/rng-prd-design-issue-590","permalink":"/Idle-Game-Engine/rng-prd-design-issue-590","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/rng-prd-design-issue-590.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"RNG PRD Design (Issue 590)","sidebar_position":4}}');var t=n(5270),r=n(7678);const l={title:"RNG PRD Design (Issue 590)",sidebar_position:4},a="RNG PRD Design (Issue 590)",d={},c=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"Background",id:"background",level:3},{value:"Problem",id:"problem",level:3},{value:"Forces",id:"forces",level:3},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"Goals",id:"goals",level:3},{value:"Non-Goals",id:"non-goals",level:3},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"Primary Stakeholders",id:"primary-stakeholders",level:3},{value:"Agent Roles",id:"agent-roles",level:3},{value:"Affected Packages/Services",id:"affected-packagesservices",level:3},{value:"Compatibility Considerations",id:"compatibility-considerations",level:3},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"Runtime Changes",id:"runtime-changes",level:4},{value:"Data &amp; Schemas",id:"data--schemas",level:4},{value:"APIs &amp; Contracts",id:"apis--contracts",level:4},{value:"Tooling &amp; Automation",id:"tooling--automation",level:4},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"Deployment",id:"deployment",level:4},{value:"Telemetry &amp; Observability",id:"telemetry--observability",level:4},{value:"Security &amp; Compliance",id:"security--compliance",level:4},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"Context Packets",id:"context-packets",level:3},{value:"Prompting &amp; Constraints",id:"prompting--constraints",level:3},{value:"Safety Rails",id:"safety-rails",level:3},{value:"Validation Hooks",id:"validation-hooks",level:3},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Open Questions",id:"13-open-questions",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function o(e){const s={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"rng-prd-design-issue-590",children:"RNG PRD Design (Issue 590)"})}),"\n",(0,t.jsx)(s.h2,{id:"document-control",children:"Document Control"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Title"}),": Implement deterministic Pseudo-Random Distribution (PRD) for mission success rolls"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Authors"}),": Runtime Core Team"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reviewers"}),": N/A"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Status"}),": Draft"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Last Updated"}),": 2026-01-05"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Related Issues"}),": #590, #586, PR #741"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,t.jsx)(s.p,{children:"This design introduces Pseudo-Random Distribution (PRD) to the core RNG module and integrates it into mission-mode transforms to make repeated probability checks feel \u201cfair\u201d (fewer extreme streaks) while remaining deterministic. PRD state is persisted through save/load and state-sync workflows so that mission outcomes remain reproducible across offline catch-up, snapshot restore, and debugging comparisons."}),"\n",(0,t.jsx)(s.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,t.jsx)(s.h3,{id:"background",children:"Background"}),"\n",(0,t.jsx)(s.p,{children:"Mission success (and similar chance-based mechanics) is currently modelled as repeated Bernoulli trials using deterministic RNG. While correct statistically, streaks are common and can feel unfair to players (e.g., multiple failures in a row at 50%)."}),"\n",(0,t.jsx)(s.h3,{id:"problem",children:"Problem"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Standard RNG produces streaks that feel unintuitive or \u201crigged\u201d at small sample sizes, even when statistically valid."}),"\n",(0,t.jsx)(s.li,{children:"Without additional state, repeated checks cannot adapt based on recent outcomes."}),"\n",(0,t.jsx)(s.li,{children:"The runtime requires deterministic simulation (replayable from seed/state) and therefore cannot rely on external or non-deterministic entropy."}),"\n",(0,t.jsx)(s.li,{children:"PRD state must survive save/restore and snapshot synchronization to avoid changing outcomes after persistence boundaries."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"forces",children:"Forces"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Determinism"}),": Outcomes must be reproducible across seeded runs, offline catch-up, and restore workflows."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Performance"}),": PRD constant calculation should avoid expensive loops at tiny probabilities."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Content-driven"}),": PRD must be opt-in per mechanic (default off) and safe for future extensions."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Observability"}),": State-sync tooling should be able to diff PRD state when debugging divergence."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,t.jsx)(s.h3,{id:"goals",children:"Goals"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Provide a deterministic PRD implementation with stable, testable behaviour."}),"\n",(0,t.jsxs)(s.li,{children:["Integrate PRD into mission success checks behind a content flag (",(0,t.jsx)(s.code,{children:"successRate.usePRD"}),")."]}),"\n",(0,t.jsx)(s.li,{children:"Persist PRD registry state via save formats and state-sync snapshots."}),"\n",(0,t.jsx)(s.li,{children:"Make divergence diagnosable via state-sync checksum and diff reporting."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"non-goals",children:"Non-Goals"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Replace the underlying seeded RNG algorithm."}),"\n",(0,t.jsx)(s.li,{children:"Redesign mission balance or player-facing UX messaging."}),"\n",(0,t.jsx)(s.li,{children:"Add UI surfacing for current PRD thresholds (engine-only; UI can query later if needed)."}),"\n",(0,t.jsx)(s.li,{children:"Implement network authority/synchronization policies beyond existing snapshot/restore plumbing."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,t.jsx)(s.h3,{id:"primary-stakeholders",children:"Primary Stakeholders"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Runtime Core Team: owns RNG, transforms, persistence, state-sync layers."}),"\n",(0,t.jsx)(s.li,{children:"Content authors: opt into PRD via transform definitions."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"agent-roles",children:"Agent Roles"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Runtime Implementation Agent: PRD algorithm + registry."}),"\n",(0,t.jsx)(s.li,{children:"Integration Agent: mission/transform integration + runtime wiring."}),"\n",(0,t.jsx)(s.li,{children:"Persistence Agent: save format + snapshot/restore integration."}),"\n",(0,t.jsx)(s.li,{children:"Testing Agent: RNG and mission behavioural tests."}),"\n",(0,t.jsx)(s.li,{children:"Docs Agent: record design and reference code paths."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"affected-packagesservices",children:"Affected Packages/Services"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/core"}),": ",(0,t.jsx)(s.code,{children:"rng.ts"}),", ",(0,t.jsx)(s.code,{children:"transform-system.ts"}),", save format, state-sync capture/compare/restore, wiring."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/content-schema"}),": transform schema adds ",(0,t.jsx)(s.code,{children:"successRate.usePRD"})," with default ",(0,t.jsx)(s.code,{children:"false"}),"."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"compatibility-considerations",children:"Compatibility Considerations"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Save data and snapshots must tolerate missing PRD state (treat as empty registry)."}),"\n",(0,t.jsx)(s.li,{children:"PRD registry state must remain JSON-serializable and deterministic under key ordering."}),"\n",(0,t.jsx)(s.li,{children:"Content that does not opt into PRD must preserve existing behaviour."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["The runtime uses a deterministic RNG (",(0,t.jsx)(s.code,{children:"seededRandom"}),") for simulation."]}),"\n",(0,t.jsxs)(s.li,{children:["Mission success checks use ",(0,t.jsx)(s.code,{children:"seededRandom() < baseRate"})," with no memory between attempts."]}),"\n",(0,t.jsx)(s.li,{children:"Save and snapshot systems persist RNG seed/state and transform/entity/resources state, but had no PRD registry state to carry adaptive probability behaviour."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,t.jsx)(s.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Add a PRD implementation (",(0,t.jsx)(s.code,{children:"PseudoRandomDistribution"}),") that maintains a per-mechanic attempt counter and a derived PRD constant ",(0,t.jsx)(s.code,{children:"C"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["Add a ",(0,t.jsx)(s.code,{children:"PRDRegistry"})," keyed by a stable string ID (for missions: the transform ID) to store PRD state across ticks."]}),"\n",(0,t.jsxs)(s.li,{children:["Integrate PRD into mission-mode transform execution when ",(0,t.jsx)(s.code,{children:"successRate.usePRD === true"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["Persist registry state through:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["game save format (",(0,t.jsx)(s.code,{children:"packages/core/src/game-state-save.ts"}),"),"]}),"\n",(0,t.jsxs)(s.li,{children:["state-sync snapshot capture/checksum/compare/restore (",(0,t.jsx)(s.code,{children:"packages/core/src/state-sync/*"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,t.jsx)(s.h4,{id:"runtime-changes",children:"Runtime Changes"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/core/src/rng.ts"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"calculatePRDAverageProbability(constant)"}),": computes average success probability implied by a PRD constant.","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Uses expected-attempts accumulation up to the \u201cguaranteed success\u201d attempt (",(0,t.jsx)(s.code,{children:"ceil(1/C)"}),")."]}),"\n",(0,t.jsxs)(s.li,{children:["For extremely small constants (where ",(0,t.jsx)(s.code,{children:"ceil(1/C)"})," would be too large), uses a continuous approximation (",(0,t.jsx)(s.code,{children:"sqrt((2C)/pi)"}),") to avoid huge loops."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"calculatePRDConstant(probability)"}),": binary searches for a constant ",(0,t.jsx)(s.code,{children:"C"})," whose implied average probability matches the desired base rate."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"PseudoRandomDistribution"}),":","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"roll()"})," increments attempts, computes ",(0,t.jsx)(s.code,{children:"threshold = min(1, C * attempts)"}),", and resets attempts on success."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"getState()"})," returns ",(0,t.jsx)(s.code,{children:"{ attempts, constant }"})," for persistence."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"restore(state)"})," normalizes non-finite values and derives ",(0,t.jsx)(s.code,{children:"baseProbability"})," from the restored constant."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"updateBaseProbability(baseProbability)"})," recalculates ",(0,t.jsx)(s.code,{children:"C"})," when the base rate meaningfully changes; tiny deltas (including near zero) are ignored via mixed relative/absolute tolerances. Attempt counters are preserved across significant base-rate changes, except when crossing edge probabilities (0 or 1), where attempts reset to avoid \u201cbanking\u201d pity across impossible/guaranteed configurations."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"PRDRegistry"}),":","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"getOrCreate(id, baseProbability)"})," returns a stable PRD instance per ID and updates the base probability if re-requested."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"captureState()"})," and ",(0,t.jsx)(s.code,{children:"restoreState(states | undefined)"})," serialize/restore a JSON record keyed by ID."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"data--schemas",children:"Data & Schemas"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/core"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Save format adds optional ",(0,t.jsx)(s.code,{children:"prd?: SerializedPRDRegistryState"})," where each entry stores ",(0,t.jsx)(s.code,{children:"attempts"})," and ",(0,t.jsx)(s.code,{children:"constant"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["State-sync snapshot (",(0,t.jsx)(s.code,{children:"GameStateSnapshot"}),") includes ",(0,t.jsx)(s.code,{children:"prd: SerializedPRDRegistryState"})," as an authoritative snapshot field (empty ",(0,t.jsx)(s.code,{children:"{}"})," when no PRD state exists)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/content-schema/src/modules/transforms.ts"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"successRate.usePRD: boolean"})," (default ",(0,t.jsx)(s.code,{children:"false"}),") allows content to opt into PRD for mission success rolls."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"apis--contracts",children:"APIs & Contracts"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SerializedPRDRegistryState"})," is a plain JSON object (",(0,t.jsx)(s.code,{children:"Record<string, PRDState>"}),") and must remain deterministic under key sort for checksum/diff tooling."]}),"\n",(0,t.jsx)(s.li,{children:"PRD IDs must be stable across runs for persistence and synchronization; for missions, the transform ID is used."}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"tooling--automation",children:"Tooling & Automation"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["State-sync:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/core/src/state-sync/checksum.ts"})," includes PRD state in deterministic checksum (excluding ",(0,t.jsx)(s.code,{children:"capturedAt"}),")."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/core/src/state-sync/compare.ts"})," reports PRD diffs per ID (",(0,t.jsx)(s.code,{children:"attempts"}),", ",(0,t.jsx)(s.code,{children:"constant"}),") to help diagnose divergence."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/core/src/state-sync/restore-runtime.ts"})," restores PRD registry state into the wired runtime."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,t.jsx)(s.h4,{id:"deployment",children:"Deployment"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["PRD behaviour is content-gated; default behaviour remains unchanged for content that does not set ",(0,t.jsx)(s.code,{children:"usePRD: true"}),"."]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"telemetry--observability",children:"Telemetry & Observability"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"State-sync diff output includes PRD deltas to identify whether RNG divergence is due to PRD attempt counters/constants or other state."}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"security--compliance",children:"Security & Compliance"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"No PII involved. PRD state is numeric and content-keyed only."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,t.jsx)(s.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Issue Title"}),(0,t.jsx)(s.th,{children:"Scope Summary"}),(0,t.jsx)(s.th,{children:"Proposed Assignee/Agent"}),(0,t.jsx)(s.th,{children:"Dependencies"}),(0,t.jsx)(s.th,{children:"Acceptance Criteria"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"feat(core): implement PRD algorithm + registry"})}),(0,t.jsx)(s.td,{children:"Add constant calculation, PRD state machine, registry capture/restore"}),(0,t.jsx)(s.td,{children:"Runtime Implementation Agent"}),(0,t.jsx)(s.td,{children:"#590"}),(0,t.jsx)(s.td,{children:"Unit tests cover determinism, streak bounds, tiny-probability behaviour"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"feat(core): integrate PRD into mission transforms"})}),(0,t.jsxs)(s.td,{children:["Use PRD on mission success checks behind ",(0,t.jsx)(s.code,{children:"successRate.usePRD"})]}),(0,t.jsx)(s.td,{children:"Integration Agent"}),(0,t.jsx)(s.td,{children:"Transform mission execution"}),(0,t.jsx)(s.td,{children:"PRD drives outcomes deterministically when enabled; unchanged behaviour when disabled"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"feat(core): persist PRD through save + state-sync"})}),(0,t.jsx)(s.td,{children:"Save/hydrate + snapshot/checksum/compare/restore include PRD state"}),(0,t.jsx)(s.td,{children:"Persistence Agent"}),(0,t.jsx)(s.td,{children:"PRD registry exists"}),(0,t.jsx)(s.td,{children:"Save/load and snapshot restore preserve PRD attempt counters/constants"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"test(core): expand PRD + mission coverage"})}),(0,t.jsx)(s.td,{children:"Add targeted tests for PRD registry and mission integration"}),(0,t.jsx)(s.td,{children:"Testing Agent"}),(0,t.jsx)(s.td,{children:"Above slices"}),(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"pnpm --filter @idle-engine/core test"})," passes"]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"docs: add PRD design document"})}),(0,t.jsx)(s.td,{children:"Document structure and code references"}),(0,t.jsx)(s.td,{children:"Docs Agent"}),(0,t.jsx)(s.td,{children:"Implementation ready"}),(0,t.jsx)(s.td,{children:"Design doc added using template headings"})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Phase 1"}),": Implement PRD + registry and unit tests."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Phase 2"}),": Integrate into mission transforms behind ",(0,t.jsx)(s.code,{children:"usePRD"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Phase 3"}),": Persist PRD state through save + state-sync and add diff/restore validation."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Hand-off Package"}),": ",(0,t.jsx)(s.code,{children:"packages/core/src/rng.ts"}),", ",(0,t.jsx)(s.code,{children:"packages/core/src/transform-system.ts"}),", ",(0,t.jsx)(s.code,{children:"packages/core/src/game-state-save.ts"}),", ",(0,t.jsx)(s.code,{children:"packages/core/src/state-sync/*"}),", ",(0,t.jsx)(s.code,{children:"packages/content-schema/src/modules/transforms.ts"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Communication Cadence"}),": PR review checkpoints at each phase boundary; treat state-sync checksum changes as a gating signal for correctness."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,t.jsx)(s.h3,{id:"context-packets",children:"Context Packets"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Related design docs: ",(0,t.jsx)(s.code,{children:"docs/runtime-command-queue-design.md"}),", ",(0,t.jsx)(s.code,{children:"docs/state-synchronization-protocol-design.md"}),", ",(0,t.jsx)(s.code,{children:"docs/progression-coordinator-design.md"}),"."]}),"\n",(0,t.jsx)(s.li,{children:"Issue context: #590 (PRD), #586 (entity/mission system parent)."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"prompting--constraints",children:"Prompting & Constraints"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Keep simulation deterministic; avoid sources of entropy beyond ",(0,t.jsx)(s.code,{children:"seededRandom"}),"/captured RNG state."]}),"\n",(0,t.jsx)(s.li,{children:"Prefer pure functions in PRD computation and stable key ordering for serialized shapes."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"safety-rails",children:"Safety Rails"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Do not edit checked-in ",(0,t.jsx)(s.code,{children:"dist/"})," outputs by hand."]}),"\n",(0,t.jsx)(s.li,{children:"Do not add logging that could pollute deterministic test reporters."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"validation-hooks",children:"Validation Hooks"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"pnpm lint"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"pnpm --filter @idle-engine/core test"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"pnpm typecheck"})}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Pure uniform RNG"}),": simplest, but produces streaks that feel unfair and offers no adaptive behaviour."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Hard streak caps / forced success after N failures"}),": easy to implement but distorts average probability and is more exploitable/visible."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Weighted history window / pity timer curves"}),": flexible, but harder to reason about, harder to serialize compatibly, and less standardized than PRD."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Unit / Integration"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/core/src/rng-prd.test.ts"}),": constant calculation, determinism, streak bounds, restore normalization, registry capture/restore."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/core/src/__tests__/transform-system/mission-mode.test.ts"}),": mission execution uses PRD when enabled and preserves determinism."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/core/src/game-state-save.test.ts"}),": roundtrips PRD registry through save/load."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"packages/core/src/state-sync/*.test.ts"}),": checksum and compare include PRD state and restore-runtime applies it."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Performance"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Ensure constant calculation avoids pathological loops for tiny probabilities (continuous approximation path)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Risk: PRD constant calculation cost at tiny probabilities"}),(0,t.jsx)(s.br,{}),"\n","Mitigation: cap attempt loops and use continuous approximation for large ",(0,t.jsx)(s.code,{children:"ceil(1/C)"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Risk: Base-rate jitter resets attempt counters unexpectedly"}),(0,t.jsx)(s.br,{}),"\n","Mitigation: apply mixed relative/absolute epsilon threshold before recalculating constant and resetting attempts."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Risk: PRD key scoping too coarse or too fine"}),(0,t.jsx)(s.br,{}),"\n","Mitigation: start with transform ID; if future mechanics require separate PRD streams per entity/instance, extend ID scheme explicitly and migrate save state."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Risk: Missing PRD state on restore changes outcomes"}),(0,t.jsx)(s.br,{}),"\n","Mitigation: treat missing state as empty registry; content can accept reset-on-restore semantics for first-run or legacy saves."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Milestones"}),": Land PRD + integration + persistence behind ",(0,t.jsx)(s.code,{children:"successRate.usePRD"})," (default off)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Migration Strategy"}),": Save and snapshot formats treat missing ",(0,t.jsx)(s.code,{children:"prd"})," as empty; no schema version bump required for opt-in behaviour."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Communication"}),": Document the flag in transform schema and call out determinism implications in mission system docs when added."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"13-open-questions",children:"13. Open Questions"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Should mission PRD IDs incorporate additional scoping (e.g., content pack version, mission difficulty tier) to avoid unintentionally sharing state between logically distinct rolls?"}),"\n",(0,t.jsx)(s.li,{children:"Do we want to expose PRD \u201ccurrent probability\u201d via runtime APIs for UI display/debug tooling?"}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Add a dedicated \u201cMission & PRD\u201d section to content authoring docs with examples once the mission system stabilizes."}),"\n",(0,t.jsx)(s.li,{children:"Consider adding a small debug hook to export PRD registry state through diagnostics timelines when investigating divergence."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"15-references",children:"15. References"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Issue: ",(0,t.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/590",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/590"})]}),"\n",(0,t.jsxs)(s.li,{children:["PR: ",(0,t.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/pull/741",children:"https://github.com/hansjm10/Idle-Game-Engine/pull/741"})]}),"\n",(0,t.jsxs)(s.li,{children:["Core implementation: ",(0,t.jsx)(s.code,{children:"packages/core/src/rng.ts"}),", ",(0,t.jsx)(s.code,{children:"packages/core/src/transform-system.ts"})]}),"\n",(0,t.jsxs)(s.li,{children:["Persistence: ",(0,t.jsx)(s.code,{children:"packages/core/src/game-state-save.ts"})]}),"\n",(0,t.jsxs)(s.li,{children:["State sync: ",(0,t.jsx)(s.code,{children:"packages/core/src/state-sync/capture.ts"}),", ",(0,t.jsx)(s.code,{children:"packages/core/src/state-sync/checksum.ts"}),", ",(0,t.jsx)(s.code,{children:"packages/core/src/state-sync/compare.ts"}),", ",(0,t.jsx)(s.code,{children:"packages/core/src/state-sync/restore-runtime.ts"})]}),"\n",(0,t.jsxs)(s.li,{children:["Content schema flag: ",(0,t.jsx)(s.code,{children:"packages/content-schema/src/modules/transforms.ts"})]}),"\n",(0,t.jsxs)(s.li,{children:["External background: ",(0,t.jsx)(s.a,{href:"https://liquipedia.net/dota2/Pseudo_Random_Distribution",children:"https://liquipedia.net/dota2/Pseudo_Random_Distribution"})]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"PRD"}),": Pseudo-Random Distribution; a stateful probability scheme that increases success chance after failures to reduce streakiness while matching the desired average rate."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Base Rate"}),": The intended long-run success probability authored in content."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.strong,{children:["Constant (",(0,t.jsx)(s.code,{children:"C"}),")"]}),": The derived PRD step constant used to compute per-attempt thresholds."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Date"}),(0,t.jsx)(s.th,{children:"Author"}),(0,t.jsx)(s.th,{children:"Change Summary"})]})}),(0,t.jsx)(s.tbody,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"2026-01-05"}),(0,t.jsx)(s.td,{children:"Runtime Core Team"}),(0,t.jsx)(s.td,{children:"Initial draft for PRD implementation (Issue #590)"})]})})]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},7678:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>a});var i=n(9430);const t={},r=i.createContext(t);function l(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);