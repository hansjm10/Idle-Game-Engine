"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[5046],{7678:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(9430);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}},8793:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"state-synchronization-protocol-design","title":"State Synchronization Protocol Design","description":"Document Control","source":"@site/../../docs/state-synchronization-protocol-design.md","sourceDirName":".","slug":"/state-synchronization-protocol-design","permalink":"/Idle-Game-Engine/state-synchronization-protocol-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/state-synchronization-protocol-design.md","tags":[],"version":"current","frontMatter":{}}');var r=s(5270),i=s(7678);const o={},a="State Synchronization Protocol Design",c={},l=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"Background",id:"background",level:3},{value:"Problem",id:"problem",level:3},{value:"Forces",id:"forces",level:3},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"Goals",id:"goals",level:3},{value:"Non-Goals",id:"non-goals",level:3},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"Primary Stakeholders",id:"primary-stakeholders",level:3},{value:"Agent Roles",id:"agent-roles",level:3},{value:"Affected Packages/Services",id:"affected-packagesservices",level:3},{value:"Compatibility Considerations",id:"compatibility-considerations",level:3},{value:"5. Current State",id:"5-current-state",level:2},{value:"Existing Serialization Architecture",id:"existing-serialization-architecture",level:3},{value:"Gaps",id:"gaps",level:3},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"6.2.1 GameStateSnapshot Type",id:"621-gamestatesnapshot-type",level:4},{value:"6.2.2 Snapshot Capture API",id:"622-snapshot-capture-api",level:4},{value:"6.2.3 Checksum Computation",id:"623-checksum-computation",level:4},{value:"6.2.4 Snapshot Restore API",id:"624-snapshot-restore-api",level:4},{value:"6.2.5 Divergence Detection API",id:"625-divergence-detection-api",level:4},{value:"6.2.6 Usage Patterns",id:"626-usage-patterns",level:4},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"Deployment",id:"deployment",level:4},{value:"Telemetry &amp; Observability",id:"telemetry--observability",level:4},{value:"Security &amp; Compliance",id:"security--compliance",level:4},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"Context Packets",id:"context-packets",level:3},{value:"Prompting &amp; Constraints",id:"prompting--constraints",level:3},{value:"Safety Rails",id:"safety-rails",level:3},{value:"Validation Hooks",id:"validation-hooks",level:3},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"Delta Synchronization Instead of Snapshots",id:"delta-synchronization-instead-of-snapshots",level:3},{value:"Cryptographic Hashing (SHA-256)",id:"cryptographic-hashing-sha-256",level:3},{value:"xxHash Instead of FNV-1a",id:"xxhash-instead-of-fnv-1a",level:3},{value:"Per-Component Checksums",id:"per-component-checksums",level:3},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"Unit / Integration",id:"unit--integration",level:3},{value:"Performance",id:"performance",level:3},{value:"Property-Based Tests",id:"property-based-tests",level:3},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"Milestones",id:"milestones",level:3},{value:"Migration Strategy",id:"migration-strategy",level:3},{value:"Communication",id:"communication",level:3},{value:"13. Open Questions",id:"13-open-questions",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A - Glossary",id:"appendix-a---glossary",level:2},{value:"Appendix B - Change Log",id:"appendix-b---change-log",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"state-synchronization-protocol-design",children:"State Synchronization Protocol Design"})}),"\n",(0,r.jsx)(n.h2,{id:"document-control",children:"Document Control"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Title"}),": Add State Synchronization Protocol for Client/Server Architecture"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authors"}),": Idle Engine Docs Agent"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reviewers"}),": Runtime Core maintainers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Status"}),": Implemented (Phase 1-2)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Last Updated"}),": 2025-12-22"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Related Issues"}),": #544"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,r.jsx)(n.p,{children:"This design introduces infrastructure for synchronizing game state between an authoritative server and clients in the Idle Engine. The protocol enables periodic state snapshots, deterministic checksum verification for divergence detection, and efficient resync mechanisms when client-predicted state diverges from the server. By building on the existing deterministic simulation and serialization patterns, this protocol provides the foundation for multiplayer features, anti-cheat validation, and cloud save reconciliation without compromising the engine's offline-first design."}),"\n",(0,r.jsx)(n.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,r.jsx)(n.h3,{id:"background",children:"Background"}),"\n",(0,r.jsx)(n.p,{children:"The Idle Engine runtime is fully deterministic and serializable. Existing infrastructure includes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ResourceState.exportForSave()"})," for resource serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"CommandQueue.exportForSave()"})," for command queue serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"serializeProgressionCoordinatorState()"})," for progression state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"createVerificationRuntime()"})," for replay-based verification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"buildEconomyStateSummary()"})," for economy snapshots"]}),"\n",(0,r.jsxs)(n.li,{children:["Seeded RNG via ",(0,r.jsx)(n.code,{children:"getCurrentRNGSeed()"})," and ",(0,r.jsx)(n.code,{children:"setRNGSeed()"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"However, these primitives are scattered across subsystems and lack a unified protocol for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Capturing complete game state as a single atomic snapshot"}),"\n",(0,r.jsx)(n.li,{children:"Computing fast checksums for divergence detection"}),"\n",(0,r.jsx)(n.li,{children:"Restoring a runtime from a snapshot"}),"\n",(0,r.jsx)(n.li,{children:"Identifying specific differences when divergence occurs"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"problem",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"Without a unified state synchronization protocol:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Server-authoritative validation requires ad-hoc state assembly"}),"\n",(0,r.jsx)(n.li,{children:"Desync detection between clients and server is manual and error-prone"}),"\n",(0,r.jsx)(n.li,{children:"Cloud save reconciliation lacks a structured comparison mechanism"}),"\n",(0,r.jsx)(n.li,{children:"Anti-cheat replay verification cannot efficiently compare endpoints"}),"\n",(0,r.jsx)(n.li,{children:"Future multiplayer features have no foundation for state transfer"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"forces",children:"Forces"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Checksum computation must complete within microseconds for per-tick verification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Determinism"}),": Snapshot capture and restore must preserve bit-exact state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bandwidth"}),": Full snapshots should support partial extraction for network efficiency"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debuggability"}),": Divergence detection must pinpoint specific differences for debugging"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compatibility"}),": Protocol must work across browser Workers, Node.js, and potential native shells"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,r.jsx)(n.h3,{id:"goals",children:"Goals"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unified Snapshot API"}),": Single ",(0,r.jsx)(n.code,{children:"captureGameStateSnapshot()"})," function that aggregates all runtime state components"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fast Checksums"}),": ",(0,r.jsx)(n.code,{children:"computeStateChecksum()"})," producing deterministic hashes in <100\u03bcs for typical game states"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complete Restore"}),": ",(0,r.jsx)(n.code,{children:"restoreFromSnapshot()"})," that fully hydrates a runtime to an identical state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Round-Trip Invariant"}),": ",(0,r.jsx)(n.code,{children:"capture \u2192 serialize \u2192 deserialize \u2192 restore"})," produces bit-identical state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Divergence Debugging"}),": ",(0,r.jsx)(n.code,{children:"compareStates()"})," API that identifies specific field differences"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Partial Snapshots"}),": Support for extracting/restoring subsets (e.g., resources only) for bandwidth optimization"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"non-goals",children:"Non-Goals"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Real-time multiplayer netcode (tick-by-tick synchronization)"}),"\n",(0,r.jsx)(n.li,{children:"Network transport layer implementation"}),"\n",(0,r.jsx)(n.li,{children:"Compression algorithms for wire format (deferred to transport layer)"}),"\n",(0,r.jsx)(n.li,{children:"Client prediction with rollback (future work building on this foundation)"}),"\n",(0,r.jsx)(n.li,{children:"Server-side continuous simulation (use replay verification instead)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,r.jsx)(n.h3,{id:"primary-stakeholders",children:"Primary Stakeholders"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Runtime Core maintainers (implementation)"}),"\n",(0,r.jsx)(n.li,{children:"Shell maintainers (Worker bridge updates)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"agent-roles",children:"Agent Roles"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Agent"}),(0,r.jsx)(n.th,{children:"Responsibilities"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Runtime Implementation Agent"}),(0,r.jsxs)(n.td,{children:["Core snapshot/checksum/restore APIs in ",(0,r.jsx)(n.code,{children:"packages/core"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Testing Agent"}),(0,r.jsx)(n.td,{children:"Unit tests, property-based tests, round-trip verification"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Docs Agent"}),(0,r.jsx)(n.td,{children:"API documentation, usage examples"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"affected-packagesservices",children:"Affected Packages/Services"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/"})," - New synchronization module"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/index.ts"})," - Public API exports"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"compatibility-considerations",children:"Compatibility Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"New APIs are additive; no breaking changes to existing serialization"}),"\n",(0,r.jsx)(n.li,{children:"Snapshot format versioned for future schema evolution"}),"\n",(0,r.jsxs)(n.li,{children:["Existing ",(0,r.jsx)(n.code,{children:"exportForSave()"})," methods remain unchanged"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,r.jsx)(n.h3,{id:"existing-serialization-architecture",children:"Existing Serialization Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The runtime currently has per-subsystem serialization:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ResourceState"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/resource-state.ts:1283-1341"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"exportForSave(\n  automationState?: ReadonlyMap<string, AutomationState>,\n  transformState?: ReadonlyMap<string, TransformState>,\n): SerializedResourceState\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns ",(0,r.jsx)(n.code,{children:"ids"}),", ",(0,r.jsx)(n.code,{children:"amounts"}),", ",(0,r.jsx)(n.code,{children:"capacities"}),", ",(0,r.jsx)(n.code,{children:"unlocked"}),", ",(0,r.jsx)(n.code,{children:"visible"}),", ",(0,r.jsx)(n.code,{children:"flags"}),", ",(0,r.jsx)(n.code,{children:"definitionDigest"}),", and optionally embedded automation/transform state."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CommandQueue"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/command-queue.ts:207-248"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"exportForSave(): SerializedCommandQueueV1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns ",(0,r.jsx)(n.code,{children:"schemaVersion"}),", ",(0,r.jsx)(n.code,{children:"entries[]"})," with ",(0,r.jsx)(n.code,{children:"type"}),", ",(0,r.jsx)(n.code,{children:"priority"}),", ",(0,r.jsx)(n.code,{children:"timestamp"}),", ",(0,r.jsx)(n.code,{children:"step"}),", ",(0,r.jsx)(n.code,{children:"payload"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ProgressionCoordinator"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/progression-coordinator-save.ts:156-200"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"serializeProgressionCoordinatorState(\n  coordinator: ProgressionCoordinator,\n  productionSystem?: { exportAccumulators: () => SerializedProductionAccumulators },\n): SerializedProgressionCoordinatorStateV2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Returns ",(0,r.jsx)(n.code,{children:"step"}),", ",(0,r.jsx)(n.code,{children:"resources"}),", ",(0,r.jsx)(n.code,{children:"generators"}),", ",(0,r.jsx)(n.code,{children:"upgrades"}),", ",(0,r.jsx)(n.code,{children:"achievements"}),", ",(0,r.jsx)(n.code,{children:"productionAccumulators"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"RNG State"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/rng.ts"}),"):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"getCurrentRNGSeed(): number | undefined"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"setRNGSeed(seed: number): void"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"getRNGState(): number | undefined"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"setRNGState(state: number): void"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Verification Runtime"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/index.ts:940-979"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"createVerificationRuntime(options: CreateVerificationRuntimeOptions): VerificationRuntime\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Hydrates a runtime from ",(0,r.jsx)(n.code,{children:"EconomyStateSummary"})," for replay verification."]}),"\n",(0,r.jsx)(n.h3,{id:"gaps",children:"Gaps"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"No single function to capture all state atomically"}),"\n",(0,r.jsx)(n.li,{children:"No checksum computation for fast divergence detection"}),"\n",(0,r.jsx)(n.li,{children:"No structured comparison for debugging desyncs"}),"\n",(0,r.jsx)(n.li,{children:"Restore requires manual assembly of multiple components"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,r.jsx)(n.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    State Sync Protocol                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502  captureGameStateSnapshot()                                 \u2502\n\u2502  \u251c\u2500\u2500 ResourceState.exportForSave()                          \u2502\n\u2502  \u251c\u2500\u2500 ProgressionCoordinator state                           \u2502\n\u2502  \u251c\u2500\u2500 AutomationSystem state                                 \u2502\n\u2502  \u251c\u2500\u2500 TransformSystem state                                  \u2502\n\u2502  \u251c\u2500\u2500 CommandQueue.exportForSave()                           \u2502\n\u2502  \u2514\u2500\u2500 Runtime metadata (step, stepSizeMs, rngSeed, rngState) \u2502\n\u2502                    \u2502                                        \u2502\n\u2502                    \u25bc                                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n\u2502  \u2502         GameStateSnapshot               \u2502               \u2502\n\u2502  \u2502  (unified, versioned, serializable)     \u2502               \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2502           \u2502                    \u2502                           \u2502\n\u2502           \u25bc                    \u25bc                           \u2502\n\u2502  computeStateChecksum()    restoreFromSnapshot()           \u2502\n\u2502  (FNV-1a / xxHash32)       (hydrate runtime)               \u2502\n\u2502           \u2502                                                \u2502\n\u2502           \u25bc                                                \u2502\n\u2502  compareStates(local, remote): StateDiff                   \u2502\n\u2502  (field-by-field divergence report)                        \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,r.jsx)(n.h4,{id:"621-gamestatesnapshot-type",children:"6.2.1 GameStateSnapshot Type"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/state-sync/types.ts\n\nexport interface GameStateSnapshot {\n  /** Schema version for forward compatibility */\n  readonly version: 1;\n\n  /** Capture timestamp (wall clock, for diagnostics only) */\n  readonly capturedAt: number;\n\n  /** Runtime metadata */\n  readonly runtime: {\n    readonly step: number;\n    readonly stepSizeMs: number;\n    readonly rngSeed: number | undefined;\n    readonly rngState?: number;\n  };\n\n  /** Serialized resource state */\n  readonly resources: SerializedResourceState;\n\n  /** Serialized progression coordinator state */\n  readonly progression: SerializedProgressionCoordinatorStateV2;\n\n  /** Serialized automation states */\n  readonly automation: readonly SerializedAutomationState[];\n\n  /** Serialized transform states */\n  readonly transforms: readonly SerializedTransformState[];\n\n  /** Serialized entity system state */\n  readonly entities: SerializedEntitySystemState;\n\n  /** Serialized PRD registry state */\n  readonly prd: SerializedPRDRegistryState;\n\n  /** Serialized command queue */\n  readonly commandQueue: SerializedCommandQueueV1;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"622-snapshot-capture-api",children:"6.2.2 Snapshot Capture API"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/state-sync/capture.ts\n\nexport interface CaptureSnapshotOptions {\n  /** Runtime instance to capture */\n  readonly runtime: IdleEngineRuntime;\n\n  /** Progression coordinator to capture */\n  readonly progressionCoordinator: ProgressionCoordinator;\n\n  /** Optional timestamp override (wall clock, diagnostic only) */\n  readonly capturedAt?: number;\n\n  /** Automation system state extractor */\n  readonly getAutomationState: () => ReadonlyMap<string, AutomationState>;\n\n  /** Transform system state extractor */\n  readonly getTransformState: () => ReadonlyMap<string, TransformState>;\n\n  /** Entity system state extractor */\n  readonly getEntityState: () => EntitySystemState;\n\n  /** PRD state extractor */\n  readonly getPrdState: () => SerializedPRDRegistryState;\n\n  /** Command queue to capture */\n  readonly commandQueue: CommandQueue;\n\n  /** Optional production system for accumulators */\n  readonly productionSystem?: { exportAccumulators: () => SerializedProductionAccumulators };\n}\n\nexport function captureGameStateSnapshot(\n  options: CaptureSnapshotOptions,\n): GameStateSnapshot {\n  const {\n    runtime,\n    progressionCoordinator,\n    capturedAt,\n    getAutomationState,\n    getTransformState,\n    getEntityState,\n    getPrdState,\n    commandQueue,\n    productionSystem,\n  } = options;\n\n  const automationState = getAutomationState();\n  const transformState = getTransformState();\n  const entityState = getEntityState();\n  const prdState = getPrdState();\n\n  return {\n    version: 1,\n    capturedAt: capturedAt ?? Date.now(),\n    runtime: {\n      step: runtime.getCurrentStep(),\n      stepSizeMs: runtime.getStepSizeMs(),\n      rngSeed: getCurrentRNGSeed(),\n      rngState: getRNGState(),\n    },\n    resources: progressionCoordinator.resourceState.exportForSave(),\n    progression: serializeProgressionCoordinatorState(\n      progressionCoordinator,\n      productionSystem,\n    ),\n    automation: serializeAutomationState(automationState),\n    transforms: serializeTransformState(transformState),\n    entities: serializeEntitySystemState(entityState),\n    prd: prdState,\n    commandQueue: commandQueue.exportForSave(),\n  };\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note: automation/transforms are captured as top-level fields; ",(0,r.jsx)(n.code,{children:"resources.exportForSave()"})," intentionally omits embedded automation/transform state to match the existing save format and avoid duplication. Resources are exported from the progression coordinator to keep the snapshot internally consistent.\nCaptured timestamps are diagnostic only; use ",(0,r.jsx)(n.code,{children:"capturedAt"})," in ",(0,r.jsx)(n.code,{children:"CaptureSnapshotOptions"})," when you need a deterministic value (e.g., tests or snapshot diffing)."]}),"\n",(0,r.jsx)(n.h4,{id:"623-checksum-computation",children:"6.2.3 Checksum Computation"}),"\n",(0,r.jsx)(n.p,{children:"Based on research, FNV-1a is optimal for game state hashing due to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Excellent performance on small-to-medium data (<1KB typical game state)"}),"\n",(0,r.jsx)(n.li,{children:"Simple implementation (no dependencies)"}),"\n",(0,r.jsx)(n.li,{children:"Good distribution properties"}),"\n",(0,r.jsx)(n.li,{children:"Deterministic across platforms"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For larger states (>10KB), xxHash32 provides better throughput."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/state-sync/checksum.ts\n\nconst FNV_OFFSET_BASIS_32 = 0x811c9dc5;\nconst FNV_PRIME_32 = 0x01000193;\nconst utf8Encoder = new TextEncoder();\n\nfunction normalizeForDeterministicJson(value: unknown): unknown {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((entry) => normalizeForDeterministicJson(entry));\n  }\n\n  const result: Record<string, unknown> = {};\n  const keys = Object.keys(value).sort();\n  for (const key of keys) {\n    result[key] = normalizeForDeterministicJson(\n      (value as Record<string, unknown>)[key],\n    );\n  }\n  return result;\n}\n\nfunction stringifyDeterministic(value: unknown): string {\n  return JSON.stringify(normalizeForDeterministicJson(value));\n}\n\n/**\n * Compute FNV-1a hash of a Uint8Array.\n * Returns a 32-bit hash as an 8-character hex string.\n */\nexport function fnv1a32(data: Uint8Array): string {\n  let hash = FNV_OFFSET_BASIS_32;\n  for (let i = 0; i < data.length; i++) {\n    hash ^= data[i];\n    hash = Math.imul(hash, FNV_PRIME_32) >>> 0;\n  }\n  return hash.toString(16).padStart(8, '0');\n}\n\n/**\n * Compute a deterministic checksum for a game state snapshot.\n *\n * The checksum excludes capturedAt, since it is diagnostic only. The remaining\n * fields are recursively normalized with sorted keys, serialized to canonical\n * JSON, encoded to UTF-8, and hashed with FNV-1a.\n */\nexport function computeStateChecksum(snapshot: GameStateSnapshot): string {\n  const checksumSnapshot = {\n    version: snapshot.version,\n    runtime: snapshot.runtime,\n    resources: snapshot.resources,\n    progression: snapshot.progression,\n    automation: snapshot.automation,\n    transforms: snapshot.transforms,\n    commandQueue: snapshot.commandQueue,\n  };\n\n  const json = stringifyDeterministic(checksumSnapshot);\n  return fnv1a32(utf8Encoder.encode(json));\n}\n\n/**\n * Compute checksum for a partial snapshot (e.g., resources only).\n */\nexport function computePartialChecksum<K extends keyof GameStateSnapshot>(\n  snapshot: GameStateSnapshot,\n  keys: readonly K[],\n): string {\n  const partial: Partial<GameStateSnapshot> = {};\n  for (const key of keys) {\n    partial[key] = snapshot[key];\n  }\n  const json = stringifyDeterministic(partial);\n  return fnv1a32(utf8Encoder.encode(json));\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"624-snapshot-restore-api",children:"6.2.4 Snapshot Restore API"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/state-sync/restore.ts\n\nexport interface RestoreSnapshotOptions {\n  /** Snapshot to restore from */\n  readonly snapshot: GameStateSnapshot;\n\n  /** Resource definitions for hydration */\n  readonly resourceDefinitions: readonly ResourceDefinition[];\n\n  /** Runtime options (overrides snapshot values if provided) */\n  readonly runtimeOptions?: Partial<IdleEngineRuntimeOptions>;\n\n  /** Whether to apply RNG seed from snapshot (default: true) */\n  readonly applyRngSeed?: boolean;\n}\n\nexport interface RestoredRuntime {\n  /** Hydrated runtime instance */\n  readonly runtime: IdleEngineRuntime;\n\n  /** Hydrated resource state */\n  readonly resources: ResourceState;\n\n  /** Reconciliation metadata (added/removed resources) */\n  readonly reconciliation: ResourceDefinitionReconciliation;\n\n  /** Restored command queue */\n  readonly commandQueue: CommandQueue;\n}\n\nexport function restoreFromSnapshot(\n  options: RestoreSnapshotOptions,\n): RestoredRuntime {\n  const {\n    snapshot,\n    resourceDefinitions,\n    runtimeOptions,\n    applyRngSeed = true,\n  } = options;\n\n  const { resources, reconciliation } = hydrateResourceStateFromSerialized(\n    snapshot.resources,\n    resourceDefinitions,\n  );\n\n  const commandQueue = runtimeOptions?.commandQueue ?? new CommandQueue();\n  const runtime = resolveRuntimeFactory()({\n    ...runtimeOptions,\n    commandQueue,\n    stepSizeMs: runtimeOptions?.stepSizeMs ?? snapshot.runtime.stepSizeMs,\n    initialStep: runtimeOptions?.initialStep ?? snapshot.runtime.step,\n  });\n\n  if (applyRngSeed && snapshot.runtime.rngSeed !== undefined) {\n    setRNGSeed(snapshot.runtime.rngSeed);\n  }\n  if (applyRngSeed && snapshot.runtime.rngState !== undefined) {\n    setRNGState(snapshot.runtime.rngState);\n  }\n\n  const currentStep = runtime.getCurrentStep();\n  const rebaseStep =\n    currentStep !== snapshot.runtime.step\n      ? { savedStep: snapshot.runtime.step, currentStep }\n      : undefined;\n\n  commandQueue.restoreFromSave(\n    snapshot.commandQueue,\n    rebaseStep ? { rebaseStep } : undefined,\n  );\n\n  return { runtime, resources, reconciliation, commandQueue };\n}\n\n/**\n * Restore only specific components for bandwidth optimization.\n */\nexport type RestoreMode = 'full' | 'resources' | 'commands';\n\nexport interface RestorePartialOptions {\n  /** Optional command step rebasing for restores into a different timeline. */\n  readonly rebaseCommands?: Readonly<{\n    readonly savedStep: number;\n    readonly currentStep: number;\n  }>;\n}\n\nexport function restorePartial(\n  snapshot: GameStateSnapshot,\n  mode: RestoreMode,\n  target: {\n    resources?: ResourceState;\n    commandQueue?: CommandQueue;\n  },\n  options: RestorePartialOptions = {},\n): void {\n  const applyResources = () => {\n    if (!target.resources) {\n      return;\n    }\n    assertSerializedResourceState(snapshot.resources);\n    const remap = buildRemapFromResources(\n      target.resources,\n      snapshot.resources,\n    );\n    applySerializedResourceState(\n      target.resources,\n      snapshot.resources,\n      remap,\n    );\n  };\n\n  const restoreCommands = () => {\n    if (!target.commandQueue) {\n      return;\n    }\n    const rebaseStep = options.rebaseCommands;\n    target.commandQueue.restoreFromSave(\n      snapshot.commandQueue,\n      rebaseStep ? { rebaseStep } : undefined,\n    );\n  };\n\n  switch (mode) {\n    case 'full':\n      applyResources();\n      restoreCommands();\n      break;\n    case 'resources':\n      applyResources();\n      break;\n    case 'commands':\n      restoreCommands();\n      break;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note: ",(0,r.jsx)(n.code,{children:"restoreFromSnapshot()"})," depends on a runtime factory configured via\n",(0,r.jsx)(n.code,{children:"setRestoreRuntimeFactory()"}),". The public ",(0,r.jsx)(n.code,{children:"@idle-engine/core"})," entrypoints set\nthis to ",(0,r.jsx)(n.code,{children:"IdleEngineRuntime"})," automatically."]}),"\n",(0,r.jsx)(n.h4,{id:"625-divergence-detection-api",children:"6.2.5 Divergence Detection API"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// packages/core/src/state-sync/compare.ts\n\nexport interface StateDiff {\n  /** Whether states are identical */\n  readonly identical: boolean;\n\n  /** Runtime metadata differences */\n  readonly runtime?: {\n    step?: { local: number; remote: number };\n    stepSizeMs?: { local: number; remote: number };\n    rngSeed?: { local: number | undefined; remote: number | undefined };\n    rngState?: { local: number | undefined; remote: number | undefined };\n  };\n\n  /** Resource differences (by resource ID) */\n  readonly resources?: ReadonlyMap<string, ResourceDiff>;\n\n  /** Progression differences */\n  readonly progression?: ProgressionDiff;\n\n  /** Command queue differences */\n  readonly commandQueue?: CommandQueueDiff;\n}\n\nexport interface ResourceDiff {\n  readonly id: string;\n  readonly amount?: { local: number; remote: number };\n  readonly capacity?: { local: number | null; remote: number | null };\n  readonly unlocked?: { local: boolean; remote: boolean };\n  readonly visible?: { local: boolean; remote: boolean };\n}\n\nexport interface ProgressionDiff {\n  readonly generators?: ReadonlyMap<string, GeneratorDiff>;\n  readonly upgrades?: ReadonlyMap<string, UpgradeDiff>;\n  readonly achievements?: ReadonlyMap<string, AchievementDiff>;\n}\n\nexport interface CommandQueueDiff {\n  readonly entryCountDiff: { local: number; remote: number };\n  readonly missingInLocal: readonly string[];  // command types\n  readonly missingInRemote: readonly string[];\n}\n\n/**\n * Compare two snapshots and return detailed differences.\n * Useful for debugging desync issues.\n */\nexport function compareStates(\n  local: GameStateSnapshot,\n  remote: GameStateSnapshot,\n): StateDiff {\n  const diff: StateDiff = { identical: true };\n\n  // Compare runtime metadata\n  const runtimeDiff = compareRuntime(local.runtime, remote.runtime);\n  if (runtimeDiff) {\n    diff.runtime = runtimeDiff;\n    (diff as { identical: boolean }).identical = false;\n  }\n\n  // Compare resources\n  const resourceDiff = compareResources(local.resources, remote.resources);\n  if (resourceDiff.size > 0) {\n    diff.resources = resourceDiff;\n    (diff as { identical: boolean }).identical = false;\n  }\n\n  // Compare progression\n  const progressionDiff = compareProgression(local.progression, remote.progression);\n  if (progressionDiff) {\n    diff.progression = progressionDiff;\n    (diff as { identical: boolean }).identical = false;\n  }\n\n  // Compare command queue\n  const queueDiff = compareCommandQueues(local.commandQueue, remote.commandQueue);\n  if (queueDiff) {\n    diff.commandQueue = queueDiff;\n    (diff as { identical: boolean }).identical = false;\n  }\n\n  return diff;\n}\n\n/**\n * Quick divergence check using checksums only.\n * Use this for periodic sync checks; fall back to compareStates() for debugging.\n */\nexport function hasStateDiverged(\n  local: GameStateSnapshot,\n  remote: GameStateSnapshot,\n): boolean {\n  return computeStateChecksum(local) !== computeStateChecksum(remote);\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"626-usage-patterns",children:"6.2.6 Usage Patterns"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Snapshots vs checksums"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"computeStateChecksum()"})," or ",(0,r.jsx)(n.code,{children:"hasStateDiverged()"})," for frequent sync checks."]}),"\n",(0,r.jsx)(n.li,{children:"Use full snapshots for state transfer, resync, or audit workflows."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"capturedAt"})," is excluded from checksums; set it explicitly for deterministic testing."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Round-trip verification"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const snapshot = captureGameStateSnapshot({\n  runtime,\n  progressionCoordinator,\n  commandQueue: runtime.getCommandQueue(),\n  getAutomationState: () => getAutomationState(automationSystem),\n  getTransformState: () => getTransformState(transformSystem),\n  getEntityState: () => entitySystem.getState(),\n  getPrdState: () => prdRegistry.captureState(),\n  capturedAt: 0,\n});\n\nconst restored = restoreFromSnapshot({\n  snapshot,\n  resourceDefinitions,\n});\n\nconst restoredCoordinator = createProgressionCoordinator({\n  content,\n  stepDurationMs: snapshot.runtime.stepSizeMs,\n  initialState: {\n    stepDurationMs: snapshot.runtime.stepSizeMs,\n    resources: { state: restored.resources },\n  },\n});\n\nhydrateProgressionCoordinatorState(\n  snapshot.progression,\n  restoredCoordinator,\n  undefined,\n  { skipResources: true },\n);\n\nconst roundTrip = captureGameStateSnapshot({\n  runtime: restored.runtime as IdleEngineRuntime,\n  progressionCoordinator: restoredCoordinator,\n  commandQueue: restored.commandQueue,\n  getAutomationState: () => getAutomationState(automationSystem),\n  getTransformState: () => getTransformState(transformSystem),\n  getEntityState: () => entitySystem.getState(),\n  getPrdState: () => prdRegistry.captureState(),\n  capturedAt: 0,\n});\n\nconst diff = compareStates(snapshot, roundTrip);\nconsole.log('Round-trip identical:', diff.identical);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Runtime restore helper"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const wiring = restoreGameRuntimeFromSnapshot({\n  content,\n  snapshot,\n  // Optional: match a runtime that disabled finalize-tick production.\n  production: { applyViaFinalizeTick: false },\n  // Optional: restore into a later step (rebases automation/transform/commands).\n  runtimeOptions: { initialStep: snapshot.runtime.step + 5 },\n});\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"restoreGameRuntimeFromSnapshot()"})," composes ",(0,r.jsx)(n.code,{children:"restoreFromSnapshot()"}),", ",(0,r.jsx)(n.code,{children:"createProgressionCoordinator()"}),", and ",(0,r.jsx)(n.code,{children:"wireGameRuntime()"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Automation/transform state is restored with step rebasing based on the snapshot step and the runtime's current step."}),"\n",(0,r.jsxs)(n.li,{children:["Production restores default to ",(0,r.jsx)(n.code,{children:"applyViaFinalizeTick"})," and cap ",(0,r.jsx)(n.code,{children:"maxStepsPerFrame"})," to 1 when generators are enabled; override ",(0,r.jsx)(n.code,{children:"production.applyViaFinalizeTick"})," to match non-finalize-tick runtimes."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Debugging desyncs"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"if (hasStateDiverged(localSnapshot, remoteSnapshot)) {\n  const diff = compareStates(localSnapshot, remoteSnapshot);\n  console.warn('Desync details:', diff);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Partial snapshot/restore for bandwidth"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const resourcesChecksum = computePartialChecksum(snapshot, ['resources']);\nif (resourcesChecksum !== computePartialChecksum(remoteSnapshot, ['resources'])) {\n  restorePartial(snapshot, 'resources', { resources });\n}\n\nrestorePartial(\n  snapshot,\n  'commands',\n  { commandQueue },\n  { rebaseCommands: { savedStep: snapshot.runtime.step, currentStep: runtime.getCurrentStep() } },\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,r.jsx)(n.h4,{id:"deployment",children:"Deployment"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["New module added to ",(0,r.jsx)(n.code,{children:"packages/core"}),"; no infrastructure changes required"]}),"\n",(0,r.jsxs)(n.li,{children:["Public API exported from ",(0,r.jsx)(n.code,{children:"packages/core/src/index.ts"})]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"telemetry--observability",children:"Telemetry & Observability"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Checksum computation time tracked via diagnostics timeline"}),"\n",(0,r.jsx)(n.li,{children:"Divergence events logged with diff summaries for debugging"}),"\n",(0,r.jsx)(n.li,{children:"Snapshot size metrics for bandwidth planning"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"security--compliance",children:"Security & Compliance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Snapshots may contain gameplay progress; no PII by design"}),"\n",(0,r.jsx)(n.li,{children:"Checksums are non-cryptographic (FNV-1a); use proper signatures for authentication"}),"\n",(0,r.jsx)(n.li,{children:"Snapshot validation rejects malformed/tampered data"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,r.jsx)(n.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Issue Title"}),(0,r.jsx)(n.th,{children:"Scope Summary"}),(0,r.jsx)(n.th,{children:"Proposed Assignee/Agent"}),(0,r.jsx)(n.th,{children:"Dependencies"}),(0,r.jsx)(n.th,{children:"Acceptance Criteria"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"feat(core): define GameStateSnapshot type"}),(0,r.jsx)(n.td,{children:"Type definitions for unified snapshot"}),(0,r.jsx)(n.td,{children:"Runtime Implementation Agent"}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsx)(n.td,{children:"Types exported; JSDoc complete"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"feat(core): implement captureGameStateSnapshot"}),(0,r.jsx)(n.td,{children:"Aggregate all state into snapshot"}),(0,r.jsx)(n.td,{children:"Runtime Implementation Agent"}),(0,r.jsx)(n.td,{children:"Type definitions"}),(0,r.jsx)(n.td,{children:"Unit tests; captures all components"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"feat(core): implement computeStateChecksum"}),(0,r.jsx)(n.td,{children:"FNV-1a checksum for snapshots"}),(0,r.jsx)(n.td,{children:"Runtime Implementation Agent"}),(0,r.jsx)(n.td,{children:"Capture API"}),(0,r.jsx)(n.td,{children:"Determinism test; <100\u03bcs benchmark"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"feat(core): implement restoreFromSnapshot"}),(0,r.jsx)(n.td,{children:"Hydrate runtime from snapshot"}),(0,r.jsx)(n.td,{children:"Runtime Implementation Agent"}),(0,r.jsx)(n.td,{children:"Capture API"}),(0,r.jsx)(n.td,{children:"Round-trip test passes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"feat(core): implement compareStates"}),(0,r.jsx)(n.td,{children:"Field-by-field diff for debugging"}),(0,r.jsx)(n.td,{children:"Runtime Implementation Agent"}),(0,r.jsx)(n.td,{children:"Type definitions"}),(0,r.jsx)(n.td,{children:"Diff reports all differences"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"test(core): property-based sync tests"}),(0,r.jsx)(n.td,{children:"Generate random states; verify invariants"}),(0,r.jsx)(n.td,{children:"Testing Agent"}),(0,r.jsx)(n.td,{children:"All APIs"}),(0,r.jsx)(n.td,{children:"1000+ cases pass"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"docs(core): state sync API documentation"}),(0,r.jsx)(n.td,{children:"Usage examples and API reference"}),(0,r.jsx)(n.td,{children:"Docs Agent"}),(0,r.jsx)(n.td,{children:"All APIs"}),(0,r.jsx)(n.td,{children:"Docs reviewed and merged"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase 1"}),": Core APIs (",(0,r.jsx)(n.code,{children:"captureGameStateSnapshot"}),", ",(0,r.jsx)(n.code,{children:"computeStateChecksum"}),", ",(0,r.jsx)(n.code,{children:"restoreFromSnapshot"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase 2"}),": Debugging tools (",(0,r.jsx)(n.code,{children:"compareStates"}),", partial checksums)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase 3"}),": Integration with future services (cloud sync)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hand-off Package"}),": This design doc, existing serialization code paths, ",(0,r.jsx)(n.code,{children:"docs/idle-engine-design.md"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Communication Cadence"}),": One PR per issue-map row; maintain backward compatibility"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,r.jsx)(n.h3,{id:"context-packets",children:"Context Packets"}),"\n",(0,r.jsx)(n.p,{children:"Files agents must load before execution:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/resource-state.ts"})," - Existing resource serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/command-queue.ts"})," - Command queue serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/progression-coordinator-save.ts"})," - Progression serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/rng.ts"})," - RNG seed handling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/index.ts"})," - Public API patterns"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"prompting--constraints",children:"Prompting & Constraints"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use imperative commit messages: ",(0,r.jsx)(n.code,{children:"feat(core): add captureGameStateSnapshot"})]}),"\n",(0,r.jsxs)(n.li,{children:["Follow existing naming patterns (e.g., ",(0,r.jsx)(n.code,{children:"exportForSave"})," convention)"]}),"\n",(0,r.jsx)(n.li,{children:"Maintain 100% test coverage for new public APIs"}),"\n",(0,r.jsx)(n.li,{children:"Use type-only imports for TypeScript types"}),"\n",(0,r.jsx)(n.li,{children:"Keep checksum computation pure and side-effect free"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"safety-rails",children:"Safety Rails"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"NEVER reset git history or force push to main"}),"\n",(0,r.jsxs)(n.li,{children:["DO NOT introduce non-deterministic behavior (e.g., ",(0,r.jsx)(n.code,{children:"Date.now()"})," in checksums)"]}),"\n",(0,r.jsx)(n.li,{children:"ALWAYS use deterministic JSON serialization (recursive key sorting)"}),"\n",(0,r.jsxs)(n.li,{children:["NEVER modify existing ",(0,r.jsx)(n.code,{children:"exportForSave()"})," signatures"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"validation-hooks",children:"Validation Hooks"}),"\n",(0,r.jsx)(n.p,{children:"Commands agents must run:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pnpm lint"})," - Code style"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pnpm typecheck"})," - Type safety"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pnpm test --filter @idle-engine/core"})," - Unit tests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pnpm build"})," - Build verification"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,r.jsx)(n.h3,{id:"delta-synchronization-instead-of-snapshots",children:"Delta Synchronization Instead of Snapshots"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Approach"}),": Send only changed fields between sync points."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Trade-offs"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pro: Lower bandwidth for incremental updates"}),"\n",(0,r.jsx)(n.li,{children:"Con: Significantly more complex; requires change tracking infrastructure"}),"\n",(0,r.jsx)(n.li,{children:"Con: Error accumulation risk if delta is lost"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision"}),": Start with full snapshots; delta compression can layer on top as bandwidth optimization in transport layer."]}),"\n",(0,r.jsx)(n.h3,{id:"cryptographic-hashing-sha-256",children:"Cryptographic Hashing (SHA-256)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Approach"}),": Use SHA-256 for tamper detection."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Trade-offs"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pro: Cryptographic security for integrity"}),"\n",(0,r.jsx)(n.li,{children:"Con: 10-100x slower than FNV-1a"}),"\n",(0,r.jsx)(n.li,{children:"Con: Overkill for desync detection (not a security boundary)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision"}),": Use FNV-1a for performance; rely on transport-layer signatures for authentication."]}),"\n",(0,r.jsx)(n.h3,{id:"xxhash-instead-of-fnv-1a",children:"xxHash Instead of FNV-1a"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Approach"}),": Use xxHash32 for all checksums."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Trade-offs"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pro: Faster for large data (>1KB)"}),"\n",(0,r.jsx)(n.li,{children:"Con: Requires WASM/native dependency or pure JS implementation"}),"\n",(0,r.jsx)(n.li,{children:"Con: FNV-1a is faster for typical game state sizes (<1KB)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision"}),": Start with FNV-1a (zero dependencies); add xxHash option if profiling shows need."]}),"\n",(0,r.jsx)(n.h3,{id:"per-component-checksums",children:"Per-Component Checksums"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Approach"}),": Compute separate checksums for resources, progression, commands."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Trade-offs"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pro: Identifies which subsystem diverged"}),"\n",(0,r.jsx)(n.li,{children:"Con: Multiple hash computations per sync"}),"\n",(0,r.jsx)(n.li,{children:"Con: Cross-component consistency still requires full comparison"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision"}),": Implement ",(0,r.jsx)(n.code,{children:"computePartialChecksum()"})," for debugging; primary API uses full checksum."]}),"\n",(0,r.jsx)(n.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,r.jsx)(n.h3,{id:"unit--integration",children:"Unit / Integration"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Capture tests"}),": Verify all state components included in snapshot"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Checksum determinism"}),": Same state produces identical checksum across runs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Round-trip tests"}),": ",(0,r.jsx)(n.code,{children:"capture \u2192 serialize \u2192 deserialize \u2192 restore \u2192 capture"})," produces identical snapshot"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Checksum uniqueness"}),": Different states produce different checksums (collision resistance)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Comparison tests"}),": ",(0,r.jsx)(n.code,{children:"compareStates()"})," identifies all field differences"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Checksum benchmark"}),": <100\u03bcs for typical game state (~100 resources, 50 generators)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Capture benchmark"}),": <1ms for full snapshot"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Restore benchmark"}),": <5ms for full hydration"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"property-based-tests",children:"Property-Based Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Generate random game states\n// Verify: capture(restore(capture(state))) === capture(state)\n// Verify: checksum(state1) !== checksum(state2) when state1 !== state2\n"})}),"\n",(0,r.jsx)(n.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Risk"}),(0,r.jsx)(n.th,{children:"Impact"}),(0,r.jsx)(n.th,{children:"Likelihood"}),(0,r.jsx)(n.th,{children:"Mitigation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Checksum collisions causing missed divergence"}),(0,r.jsx)(n.td,{children:"High"}),(0,r.jsx)(n.td,{children:"Low"}),(0,r.jsx)(n.td,{children:"Use 32-bit hash; upgrade to 64-bit if collisions observed"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"JSON serialization non-determinism"}),(0,r.jsx)(n.td,{children:"High"}),(0,r.jsx)(n.td,{children:"Medium"}),(0,r.jsx)(n.td,{children:"Explicitly sort keys; add determinism tests"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Performance regression on large states"}),(0,r.jsx)(n.td,{children:"Medium"}),(0,r.jsx)(n.td,{children:"Low"}),(0,r.jsx)(n.td,{children:"Benchmark during development; optimize hot paths"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Schema evolution breaking compatibility"}),(0,r.jsx)(n.td,{children:"High"}),(0,r.jsx)(n.td,{children:"Medium"}),(0,r.jsx)(n.td,{children:"Version field in snapshot; migration utilities"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Floating-point serialization drift"}),(0,r.jsx)(n.td,{children:"High"}),(0,r.jsx)(n.td,{children:"Medium"}),(0,r.jsx)(n.td,{children:"Use JSON.stringify (IEEE 754); document precision limits"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,r.jsx)(n.h3,{id:"milestones",children:"Milestones"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Core APIs"}),": Implement and test snapshot/checksum/restore"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Integration"}),": Wire into Worker bridge for UI sync diagnostics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Server Validation"}),": Integrate with future backend verification (TBD)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"migration-strategy",children:"Migration Strategy"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"New APIs are additive; existing code unaffected"}),"\n",(0,r.jsx)(n.li,{children:"Snapshot format versioned from v1; future migrations use version field"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"communication",children:"Communication"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"API documentation published with release"}),"\n",(0,r.jsx)(n.li,{children:"Migration guide if breaking changes in future versions"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"13-open-questions",children:"13. Open Questions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Checksum algorithm upgrade path"}),": Should we support pluggable hash algorithms, or is FNV-1a sufficient long-term?"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Partial restore granularity"}),": Which subsets of state are useful for bandwidth optimization (resources only, commands only, etc.)?"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Snapshot compression"}),": Should the protocol define optional compression, or leave that to transport?"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Floating-point precision"}),": Should we quantize floats before hashing to avoid IEEE 754 edge cases?"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Decision: capture ",(0,r.jsx)(n.code,{children:"runtime.rngState"})," in snapshots and restore it when present to\nsupport restore-and-continue determinism without changing the v1 schema."]}),"\n",(0,r.jsx)(n.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Delta synchronization"}),": Layer delta compression on snapshots for bandwidth optimization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client prediction"}),": Build on restore/compare APIs for prediction with rollback; see ",(0,r.jsx)(n.a,{href:"/Idle-Game-Engine/runtime-client-prediction-rollback-design-issue-546",children:"Client Prediction and Rollback Design (Issue 546)"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Server continuous validation"}),": Optional mode where server runs shadow simulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Snapshot versioning/migration"}),": Utilities for upgrading old snapshot formats"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Binary serialization"}),": Replace JSON with MessagePack for size reduction"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"15-references",children:"15. References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/resource-state.ts:1283-1341"})," - Resource serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/command-queue.ts:207-248"})," - Command queue serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/progression-coordinator-save.ts:156-200"})," - Progression serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/rng.ts"})," - RNG seed handling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/index.ts:940-979"})," - Verification runtime pattern"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/index.ts:499-591"})," - EconomyStateSummary pattern"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"docs/idle-engine-design.md"})," - Engine architecture"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://gafferongames.com/post/state_synchronization/",children:"Gaffer On Games: State Synchronization"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://gafferongames.com/post/deterministic_lockstep/",children:"Gaffer On Games: Deterministic Lockstep"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://gafferongames.com/post/snapshot_compression/",children:"Gaffer On Games: Snapshot Compression"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html",children:"Gabriel Gambetta: Client-Side Prediction and Server Reconciliation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://aras-p.info/blog/2016/08/09/More-Hash-Function-Tests/",children:"Aras Pranckevi\u010dius: Hash Function Tests"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"appendix-a---glossary",children:"Appendix A - Glossary"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Snapshot"}),": Complete serialized state of the game at a specific simulation step"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Checksum"}),": Fast hash of snapshot for divergence detection (not cryptographic)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Divergence/Desync"}),": When client and server states differ unexpectedly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Round-trip invariant"}),": Property that capture \u2192 restore produces identical state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"FNV-1a"}),": Fowler-Noll-Vo hash function variant; fast, simple, good distribution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hydration"}),": Process of reconstructing runtime objects from serialized data"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"appendix-b---change-log",children:"Appendix B - Change Log"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Date"}),(0,r.jsx)(n.th,{children:"Author"}),(0,r.jsx)(n.th,{children:"Change Summary"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2025-12-19"}),(0,r.jsx)(n.td,{children:"Idle Engine Docs Agent"}),(0,r.jsx)(n.td,{children:"Initial draft for #544"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2025-12-22"}),(0,r.jsx)(n.td,{children:"Codex"}),(0,r.jsx)(n.td,{children:"Mark Phase 1-2 implementation status for #544"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);