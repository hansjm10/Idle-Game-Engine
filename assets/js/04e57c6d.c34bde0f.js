"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[253],{7678:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(9430);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},9029:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"automation-system-api","title":"AutomationSystem API Reference","description":"Complete API documentation for the Idle Engine automation system","source":"@site/../../docs/automation-system-api.md","sourceDirName":".","slug":"/automation-system-api","permalink":"/Idle-Game-Engine/automation-system-api","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/automation-system-api.md","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"title":"AutomationSystem API Reference","description":"Complete API documentation for the Idle Engine automation system","sidebar_position":13}}');var i=t(5270),r=t(7678);const o={title:"AutomationSystem API Reference",description:"Complete API documentation for the Idle Engine automation system",sidebar_position:13},a="AutomationSystem API Reference",c={},d=[{value:"Core API",id:"core-api",level:2},{value:"createAutomationSystem(options)",id:"createautomationsystemoptions",level:3},{value:"getAutomationState(system)",id:"getautomationstatesystem",level:3},{value:"State Types",id:"state-types",level:2},{value:"AutomationState",id:"automationstate",level:3},{value:"AutomationSystemOptions",id:"automationsystemoptions",level:3},{value:"ResourceStateReader",id:"resourcestatereader",level:3},{value:"Trigger Evaluators",id:"trigger-evaluators",level:2},{value:"evaluateIntervalTrigger(automation, state, currentStep, stepDurationMs)",id:"evaluateintervaltriggerautomation-state-currentstep-stepdurationms",level:3},{value:"evaluateResourceThresholdTrigger(automation, resourceState)",id:"evaluateresourcethresholdtriggerautomation-resourcestate",level:3},{value:"evaluateCommandQueueEmptyTrigger(commandQueue)",id:"evaluatecommandqueueemptytriggercommandqueue",level:3},{value:"evaluateEventTrigger(automationId, pendingEventTriggers)",id:"evaluateeventtriggerautomationid-pendingeventtriggers",level:3},{value:"Cooldown Management",id:"cooldown-management",level:2},{value:"isCooldownActive(state, currentStep)",id:"iscooldownactivestate-currentstep",level:3},{value:"updateCooldown(automation, state, currentStep, stepDurationMs)",id:"updatecooldownautomation-state-currentstep-stepdurationms",level:3},{value:"Command Enqueueing",id:"command-enqueueing",level:2},{value:"enqueueAutomationCommand(automation, commandQueue, currentStep, stepDurationMs)",id:"enqueueautomationcommandautomation-commandqueue-currentstep-stepdurationms",level:3},{value:"Integration Example",id:"integration-example",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"References",id:"references",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"automationsystem-api-reference",children:"AutomationSystem API Reference"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"AutomationSystem"})," evaluates automation triggers and enqueues commands when triggers fire. It supports 4 trigger types: interval, resourceThreshold, commandQueueEmpty, and event."]}),"\n",(0,i.jsx)(n.h2,{id:"core-api",children:"Core API"}),"\n",(0,i.jsx)(n.h3,{id:"createautomationsystemoptions",children:"createAutomationSystem(options)"}),"\n",(0,i.jsx)(n.p,{children:"Creates an AutomationSystem that evaluates triggers and enqueues commands."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function createAutomationSystem(\n  options: AutomationSystemOptions\n): System & { getState: () => ReadonlyMap<string, AutomationState> }\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"options.automations"})," (readonly AutomationDefinition[]): Array of automation definitions from content pack"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"options.stepDurationMs"})," (number): Duration of each runtime step in milliseconds (default: 100)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"options.commandQueue"})," (CommandQueue): The runtime's command queue instance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"options.resourceState"})," (ResourceStateReader): Resource state for threshold evaluation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"options.initialState"})," (Map<string, AutomationState>, optional): Restored automation state from save file"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," System object with additional ",(0,i.jsx)(n.code,{children:"getState()"})," method for state extraction"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { createAutomationSystem } from '@idle-engine/core';\n\nconst system = createAutomationSystem({\n  automations: contentPack.automations,\n  stepDurationMs: 100,\n  commandQueue: runtime.getCommandQueue(),\n  resourceState: progressionCoordinator.resourceState,\n  initialState: savedState?.automationState,\n});\n\nruntime.addSystem(system);\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Lifecycle:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialization"}),": Creates state for each automation (enabled/disabled, cooldowns, last-fired)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Setup"}),": Subscribes to event triggers and automation toggle commands"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tick"}),": Evaluates triggers each tick, enqueues commands when triggered"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"State Persistence:"})}),"\n",(0,i.jsx)(n.p,{children:"Unlock state is persistent\u2014once an automation is unlocked, it remains unlocked. The system only evaluates unlock conditions for automations that are not yet unlocked. Currently, only 'always' unlock conditions are evaluated; full condition evaluation requires integration with progression systems."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"getautomationstatesystem",children:"getAutomationState(system)"}),"\n",(0,i.jsx)(n.p,{children:"Extracts the internal state from an AutomationSystem for serialization to save files."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function getAutomationState(\n  system: ReturnType<typeof createAutomationSystem>\n): ReadonlyMap<string, AutomationState>\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system"}),": The AutomationSystem instance from which to extract state"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," ReadonlyMap of automation IDs to their current state"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const state = getAutomationState(automationSystem);\nconst autoState = state.get('auto:collector');\nconsole.log(`Enabled: ${autoState?.enabled}, Last fired: ${autoState?.lastFiredStep}`);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"state-types",children:"State Types"}),"\n",(0,i.jsx)(n.h3,{id:"automationstate",children:"AutomationState"}),"\n",(0,i.jsx)(n.p,{children:"Internal state for a single automation."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Definition:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface AutomationState {\n  readonly id: string;\n  enabled: boolean;\n  lastFiredStep: number;\n  cooldownExpiresStep: number;\n  unlocked: boolean;\n  lastThresholdSatisfied?: boolean;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Fields:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"id"}),": Automation identifier matching the content definition"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"enabled"}),": Whether the automation is currently enabled"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lastFiredStep"}),": Step number when automation last fired (-Infinity if never)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cooldownExpiresStep"}),": Step number when cooldown expires (0 if no cooldown)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"unlocked"}),": Whether the automation is currently unlocked"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lastThresholdSatisfied"}),": Previous threshold state for crossing detection (undefined = never evaluated)"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"automationsystemoptions",children:"AutomationSystemOptions"}),"\n",(0,i.jsx)(n.p,{children:"Configuration options for creating an AutomationSystem."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Definition:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface AutomationSystemOptions {\n  readonly automations: readonly AutomationDefinition[];\n  readonly stepDurationMs: number;\n  readonly commandQueue: CommandQueue;\n  readonly resourceState: ResourceStateReader;\n  readonly initialState?: Map<string, AutomationState>;\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"resourcestatereader",children:"ResourceStateReader"}),"\n",(0,i.jsx)(n.p,{children:"Minimal interface for resource state access during automation evaluation."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Definition:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface ResourceStateReader {\n  getAmount(resourceIndex: number): number;\n  getResourceIndex?(resourceId: string): number;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"getAmount(resourceIndex)"}),": Returns the current amount of the resource at the given index"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"getResourceIndex(resourceId)"}),": Resolves a resource ID to its internal index (-1 if not found)"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"trigger-evaluators",children:"Trigger Evaluators"}),"\n",(0,i.jsx)(n.h3,{id:"evaluateintervaltriggerautomation-state-currentstep-stepdurationms",children:"evaluateIntervalTrigger(automation, state, currentStep, stepDurationMs)"}),"\n",(0,i.jsx)(n.p,{children:"Evaluates whether an interval trigger should fire."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function evaluateIntervalTrigger(\n  automation: AutomationDefinition,\n  state: AutomationState,\n  currentStep: number,\n  stepDurationMs: number\n): boolean\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Fires immediately on first tick (when ",(0,i.jsx)(n.code,{children:"lastFiredStep === -Infinity"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Fires when elapsed steps since last fire \u2265 interval duration in steps"}),"\n",(0,i.jsxs)(n.li,{children:["Interval is calculated as ",(0,i.jsx)(n.code,{children:"Math.ceil(intervalMs / stepDurationMs)"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Automation with 1000ms interval, 100ms step duration\n// Interval = 10 steps (1000ms / 100ms)\nconst shouldFire = evaluateIntervalTrigger(automation, state, 10, 100);\n// Returns true if currentStep - lastFiredStep >= 10\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Throws:"})," Error if automation trigger is not of kind 'interval'"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"evaluateresourcethresholdtriggerautomation-resourcestate",children:"evaluateResourceThresholdTrigger(automation, resourceState)"}),"\n",(0,i.jsx)(n.p,{children:"Evaluates whether a resourceThreshold condition is currently satisfied."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function evaluateResourceThresholdTrigger(\n  automation: AutomationDefinition,\n  resourceState: ResourceStateReader\n): boolean\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Returns current state of the condition (not crossing detection)"}),"\n",(0,i.jsx)(n.li,{children:"Caller must track previous state to detect crossings"}),"\n",(0,i.jsxs)(n.li,{children:["Resource IDs resolved to indices via ",(0,i.jsx)(n.code,{children:"resourceState.getResourceIndex()"})]}),"\n",(0,i.jsx)(n.li,{children:"Missing resources (index -1) treated as amount 0"}),"\n",(0,i.jsxs)(n.li,{children:["Supports four comparators: ",(0,i.jsx)(n.code,{children:"gte"}),", ",(0,i.jsx)(n.code,{children:"gt"}),", ",(0,i.jsx)(n.code,{children:"lte"}),", ",(0,i.jsx)(n.code,{children:"lt"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Crossing Detection Pattern:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const currentlySatisfied = evaluateResourceThresholdTrigger(automation, resourceState);\nconst previouslySatisfied = state.lastThresholdSatisfied ?? false;\n\n// Fire only on transition from false -> true (crossing event)\nconst triggered = currentlySatisfied && !previouslySatisfied;\n\n// Update state for next tick\nstate.lastThresholdSatisfied = currentlySatisfied;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cooldown Interaction:"})}),"\n",(0,i.jsxs)(n.p,{children:["This function is called during cooldown checks to update ",(0,i.jsx)(n.code,{children:"AutomationState.lastThresholdSatisfied"}),". This ensures crossing detection remains accurate when the cooldown expires, even if the resource crossed the threshold multiple times during the cooldown period."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Throws:"})," Error if automation trigger is not of kind 'resourceThreshold'"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"evaluatecommandqueueemptytriggercommandqueue",children:"evaluateCommandQueueEmptyTrigger(commandQueue)"}),"\n",(0,i.jsx)(n.p,{children:"Evaluates whether a commandQueueEmpty trigger should fire."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function evaluateCommandQueueEmptyTrigger(\n  commandQueue: CommandQueue\n): boolean\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Returns true if command queue size is 0"}),"\n",(0,i.jsx)(n.li,{children:"Allows automations to fire when no other commands are pending"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const commandQueue = new CommandQueue();\nconst shouldFire = evaluateCommandQueueEmptyTrigger(commandQueue); // true\n\ncommandQueue.enqueue({ type: 'PURCHASE_UPGRADE', ... });\nconst shouldNotFire = evaluateCommandQueueEmptyTrigger(commandQueue); // false\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"evaluateeventtriggerautomationid-pendingeventtriggers",children:"evaluateEventTrigger(automationId, pendingEventTriggers)"}),"\n",(0,i.jsx)(n.p,{children:"Evaluates whether an event trigger should fire."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function evaluateEventTrigger(\n  automationId: string,\n  pendingEventTriggers: ReadonlySet<string>\n): boolean\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Returns true if automation ID is in the pending triggers set"}),"\n",(0,i.jsxs)(n.li,{children:["Set is populated by event handlers during ",(0,i.jsx)(n.code,{children:"setup()"})]}),"\n",(0,i.jsx)(n.li,{children:"Set is cleared after each tick"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const pendingEventTriggers = new Set(['auto:collector', 'auto:upgrader']);\nconst shouldFire = evaluateEventTrigger('auto:collector', pendingEventTriggers); // true\nconst shouldNotFire = evaluateEventTrigger('auto:other', pendingEventTriggers); // false\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"cooldown-management",children:"Cooldown Management"}),"\n",(0,i.jsx)(n.h3,{id:"iscooldownactivestate-currentstep",children:"isCooldownActive(state, currentStep)"}),"\n",(0,i.jsx)(n.p,{children:"Checks if an automation is currently in cooldown."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function isCooldownActive(\n  state: AutomationState,\n  currentStep: number\n): boolean\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Returns true if ",(0,i.jsx)(n.code,{children:"currentStep < state.cooldownExpiresStep"})]}),"\n",(0,i.jsx)(n.li,{children:"Returns false if cooldown has expired or no cooldown is active"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const state = {\n  id: 'auto:test',\n  enabled: true,\n  lastFiredStep: 10,\n  cooldownExpiresStep: 20,\n  unlocked: true\n};\nconst isActive = isCooldownActive(state, 15); // true\nconst isExpired = isCooldownActive(state, 20); // false\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"updatecooldownautomation-state-currentstep-stepdurationms",children:"updateCooldown(automation, state, currentStep, stepDurationMs)"}),"\n",(0,i.jsx)(n.p,{children:"Updates the cooldown expiration step after an automation fires."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function updateCooldown(\n  automation: AutomationDefinition,\n  state: AutomationState,\n  currentStep: number,\n  stepDurationMs: number\n): void\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Converts cooldown duration (ms) to steps: ",(0,i.jsx)(n.code,{children:"Math.ceil(cooldown / stepDurationMs)"})]}),"\n",(0,i.jsxs)(n.li,{children:["Sets ",(0,i.jsx)(n.code,{children:"cooldownExpiresStep = currentStep + cooldownSteps + 1"})]}),"\n",(0,i.jsx)(n.li,{children:"The +1 accounts for command execution delay (commands execute at currentStep + 1)"}),"\n",(0,i.jsxs)(n.li,{children:["If no cooldown defined, sets ",(0,i.jsx)(n.code,{children:"cooldownExpiresStep = 0"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const automation = { cooldown: 500, ... }; // 500ms cooldown\nconst state = { cooldownExpiresStep: 0, ... };\nupdateCooldown(automation, state, 10, 100); // stepDurationMs = 100ms\n// state.cooldownExpiresStep will be 16 (10 + ceil(500/100) + 1)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"command-enqueueing",children:"Command Enqueueing"}),"\n",(0,i.jsx)(n.h3,{id:"enqueueautomationcommandautomation-commandqueue-currentstep-stepdurationms",children:"enqueueAutomationCommand(automation, commandQueue, currentStep, stepDurationMs)"}),"\n",(0,i.jsx)(n.p,{children:"Enqueues a command for an automation trigger."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function enqueueAutomationCommand(\n  automation: AutomationDefinition,\n  commandQueue: CommandQueue,\n  currentStep: number,\n  stepDurationMs: number\n): void\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Converts automation target into appropriate command type"}),"\n",(0,i.jsxs)(n.li,{children:["Enqueues command at ",(0,i.jsx)(n.code,{children:"CommandPriority.AUTOMATION"})]}),"\n",(0,i.jsxs)(n.li,{children:["Commands scheduled to execute on next step (",(0,i.jsx)(n.code,{children:"currentStep + 1"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Timestamps derived from simulation clock (",(0,i.jsx)(n.code,{children:"step * stepDurationMs"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Target Type Mapping:"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Target Type"}),(0,i.jsx)(n.th,{children:"Command Type"}),(0,i.jsx)(n.th,{children:"Payload"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"generator"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TOGGLE_GENERATOR"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ generatorId: targetId, enabled: true }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"upgrade"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"PURCHASE_UPGRADE"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ upgradeId: targetId, quantity: 1 }"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"system"})}),(0,i.jsx)(n.td,{children:"System-specific"}),(0,i.jsxs)(n.td,{children:["Mapped via ",(0,i.jsx)(n.code,{children:"mapSystemTargetToCommandType()"})]})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Generator Behavior:"})}),"\n",(0,i.jsxs)(n.p,{children:["Generator automations always enable generators (",(0,i.jsx)(n.code,{children:"enabled: true"}),"). Disabling generators requires manual player commands or system-initiated toggles."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const automation = {\n  targetType: 'generator',\n  targetId: 'gen:clicks',\n  ...\n};\nenqueueAutomationCommand(automation, commandQueue, 10, 100);\n// Command enqueued to execute at step 11 with timestamp 1000ms\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Throws:"})," Error if target type is unknown"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"integration-example",children:"Integration Example"}),"\n",(0,i.jsx)(n.p,{children:"Complete integration with IdleEngineRuntime:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import {\n  createAutomationSystem,\n  getAutomationState,\n  IdleEngineRuntime,\n} from '@idle-engine/core';\n\n// Load content pack\nconst contentPack = await import('@idle-engine/sample-pack');\n\n// Create runtime\nconst runtime = new IdleEngineRuntime({\n  stepDurationMs: 100,\n  contentPack,\n});\n\n// Create automation system\nconst automationSystem = createAutomationSystem({\n  automations: contentPack.automations,\n  stepDurationMs: 100,\n  commandQueue: runtime.getCommandQueue(),\n  resourceState: progressionCoordinator.resourceState,\n  initialState: loadedState?.automationState,\n});\n\n// Register system\nruntime.addSystem(automationSystem);\n\n// Start runtime\nruntime.start();\n\n// Later: Extract state for save file\nconst automationState = getAutomationState(automationSystem);\nconst saveData = {\n  progression: progressionCoordinator.getState(),\n  automationState: Array.from(automationState.entries()).reduce(\n    (acc, [id, state]) => ({ ...acc, [id]: state }),\n    {}\n  ),\n};\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Tick Budget:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Automation evaluation must complete within per-tick budget (<2ms for 100 automations)"}),"\n",(0,i.jsx)(n.li,{children:"Use lazy evaluation: skip locked/disabled automations early"}),"\n",(0,i.jsx)(n.li,{children:"Prefer Map lookups over array scans for O(1) performance"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Memory:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Automation state memory usage <1KB per automation"}),"\n",(0,i.jsx)(n.li,{children:"State is compact: booleans, numbers, no deep nesting"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Determinism:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Trigger evaluation must be pure (same inputs \u2192 same outputs)"}),"\n",(0,i.jsxs)(n.li,{children:["No ",(0,i.jsx)(n.code,{children:"Date.now()"})," or ",(0,i.jsx)(n.code,{children:"Math.random()"})," in trigger logic"]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"context.step"})," and ",(0,i.jsx)(n.code,{children:"context.timestamp"})," for timing"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Design Document: ",(0,i.jsx)(n.code,{children:"docs/automation-execution-system-design.md"})]}),"\n",(0,i.jsxs)(n.li,{children:["Content Schema: ",(0,i.jsx)(n.code,{children:"packages/content-schema/src/modules/automations.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Implementation: ",(0,i.jsx)(n.code,{children:"packages/core/src/automation-system.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Tests: ",(0,i.jsx)(n.code,{children:"packages/core/src/automation-system.test.ts"})]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);