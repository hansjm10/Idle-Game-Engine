"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[3686],{7678:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>o});var i=n(9430);const r={},d=i.createContext(r);function l(e){const s=i.useContext(d);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(d.Provider,{value:s},e.children)}},9910:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>t,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"issue-849-design","title":"shell-desktop: centralize sim-worker protocol types (Issue 849)","description":"Document Control","source":"@site/../../docs/issue-849-design.md","sourceDirName":".","slug":"/issue-849-design","permalink":"/Idle-Game-Engine/issue-849-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/issue-849-design.md","tags":[],"version":"current","sidebarPosition":99,"frontMatter":{"title":"shell-desktop: centralize sim-worker protocol types (Issue 849)","sidebar_position":99}}');var r=n(5270),d=n(7678);const l={title:"shell-desktop: centralize sim-worker protocol types (Issue 849)",sidebar_position:99},o="shell-desktop: centralize sim-worker protocol types (Issue 849)",t={},c=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Resolved Decisions (from design review)",id:"13-resolved-decisions-from-design-review",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function a(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"shell-desktop-centralize-sim-worker-protocol-types-issue-849",children:"shell-desktop: centralize sim-worker protocol types (Issue 849)"})}),"\n",(0,r.jsx)(s.h2,{id:"document-control",children:"Document Control"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Title"}),": Centralize sim-worker protocol types to prevent drift"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Authors"}),": Codex (AI)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Reviewers"}),": @hansjm10"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Status"}),": Draft"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Last Updated"}),": 2026-02-03"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Related Issues"}),": ",(0,r.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/849",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/849"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"@idle-engine/shell-desktop"})," currently defines the sim-worker message protocol in multiple places (",(0,r.jsx)(s.code,{children:"main.ts"}),", ",(0,r.jsx)(s.code,{children:"sim-worker.ts"}),", and tests), which has led to protocol drift (",(0,r.jsx)(s.code,{children:"frames"})," vs ",(0,r.jsx)(s.code,{children:"frame"}),") and dead branches in the main process. This design centralizes the protocol in a single shared module (",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim/worker-protocol.ts"}),"), standardizes the outbound frame payload to the existing coalesced ",(0,r.jsx)(s.code,{children:"frame"})," message (with ",(0,r.jsx)(s.code,{children:"droppedFrames"}),"), and updates main/worker/tests to import the shared types so future changes cannot silently diverge."]}),"\n",(0,r.jsx)(s.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Background"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["The desktop shell\u2019s sim runs in a Node worker thread (",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"}),") and communicates with the main process (",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"}),") using ",(0,r.jsx)(s.code,{children:"worker_threads"})," message passing."]}),"\n",(0,r.jsx)(s.li,{children:"Recent refactors (e.g., frame coalescing in the worker) changed runtime behavior but did not fully converge the protocol types used in main/worker/tests."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Problem"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})," defines an outbound message variant ",(0,r.jsx)(s.code,{children:"{ kind: 'frames', frames: RenderCommandBuffer[], nextStep }"})," and contains a handler branch for it, but ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})," never emits it (only ",(0,r.jsx)(s.code,{children:"{ kind: 'frame', frame?, droppedFrames, nextStep }"}),")."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"})," still simulates both ",(0,r.jsx)(s.code,{children:"frames"})," and ",(0,r.jsx)(s.code,{children:"frame"}),", masking dead code paths and allowing drift to persist."]}),"\n",(0,r.jsx)(s.li,{children:"This drift is brittle: it can hide broken behavior behind branches that are never exercised in production."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Forces"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Keep the sim loop deterministic and the protocol stable within the package."}),"\n",(0,r.jsxs)(s.li,{children:["Maintain the current worker behavior (coalesced ",(0,r.jsx)(s.code,{children:"frame"})," output) unless there is a compelling reason to reintroduce ",(0,r.jsx)(s.code,{children:"frames"}),"."]}),"\n",(0,r.jsx)(s.li,{children:"Enforce type consistency without introducing runtime dependencies or circular imports."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Goals"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Define sim-worker inbound/outbound message types in exactly one module and reuse them from the main process, worker, and tests."}),"\n",(0,r.jsxs)(s.li,{children:["Choose a single outbound \u201cframe delivery\u201d shape and remove dead branches in ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"}),"."]}),"\n",(0,r.jsx)(s.li,{children:"Keep the chosen protocol explicit and test-covered so future changes require coordinated updates."}),"\n",(0,r.jsxs)(s.li,{children:["Ensure ",(0,r.jsx)(s.code,{children:"pnpm test --filter @idle-engine/shell-desktop"})," passes after implementation."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Non-Goals"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Changing simulation semantics (tick scheduling, frame generation, or command processing) beyond protocol type consolidation."}),"\n",(0,r.jsxs)(s.li,{children:["Redesigning the renderer IPC surface (",(0,r.jsx)(s.code,{children:"IPC_CHANNELS.frame"}),", ",(0,r.jsx)(s.code,{children:"IPC_CHANNELS.simStatus"}),")."]}),"\n",(0,r.jsxs)(s.li,{children:["Introducing a cross-package protocol dependency (this remains internal to ",(0,r.jsx)(s.code,{children:"@idle-engine/shell-desktop"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Primary Stakeholders"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Desktop shell maintainers (",(0,r.jsx)(s.code,{children:"packages/shell-desktop"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Runtime integration/test maintainers (tests in ",(0,r.jsx)(s.code,{children:"packages/shell-desktop"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Agent Roles"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Runtime/Shell Implementation Agent"}),": Create the shared protocol module and migrate main/worker code to import it."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Test Agent"}),": Update unit tests to use the shared protocol and remove coverage for deleted protocol variants."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Docs Agent"}),": Keep this document and code references accurate during review."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Affected Packages/Services"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop"})," only:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"})}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.test.ts"})," (type imports)"]}),"\n",(0,r.jsxs)(s.li,{children:["New: ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim/worker-protocol.ts"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Compatibility Considerations"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["This is an internal protocol inside the packaged desktop app; main and worker are shipped together, so removing ",(0,r.jsx)(s.code,{children:"frames"})," does not introduce a compatibility matrix across releases."]}),"\n",(0,r.jsxs)(s.li,{children:["During development with hot reload, ensure both the worker script (",(0,r.jsx)(s.code,{children:"sim-worker.js"}),") and main process code are rebuilt together; the protocol module helps make divergence less likely."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})," declares:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Inbound: ",(0,r.jsx)(s.code,{children:"init"}),", ",(0,r.jsx)(s.code,{children:"tick"}),", ",(0,r.jsx)(s.code,{children:"enqueueCommands"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["Outbound: ",(0,r.jsx)(s.code,{children:"ready"}),", ",(0,r.jsx)(s.code,{children:"frames"}),", ",(0,r.jsx)(s.code,{children:"frame"}),", ",(0,r.jsx)(s.code,{children:"error"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["Runtime handler branches for ",(0,r.jsx)(s.code,{children:"frames"})," and ",(0,r.jsx)(s.code,{children:"frame"})," (both forward the last frame to ",(0,r.jsx)(s.code,{children:"IPC_CHANNELS.frame"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})," declares its own protocol types:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Inbound: ",(0,r.jsx)(s.code,{children:"init"}),", ",(0,r.jsx)(s.code,{children:"tick"}),", ",(0,r.jsx)(s.code,{children:"enqueueCommands"}),", ",(0,r.jsx)(s.code,{children:"shutdown"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["Outbound: ",(0,r.jsx)(s.code,{children:"ready"}),", ",(0,r.jsx)(s.code,{children:"frame"}),", ",(0,r.jsx)(s.code,{children:"error"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["On ",(0,r.jsx)(s.code,{children:"tick"}),", it computes ",(0,r.jsx)(s.code,{children:"droppedFrames = max(0, frames.length - 1)"})," and emits a single coalesced ",(0,r.jsx)(s.code,{children:"frame"})," message with the last frame (or no ",(0,r.jsx)(s.code,{children:"frame"})," field when none were produced)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"})," still simulates ",(0,r.jsx)(s.code,{children:"frames"})," messages even though they are never emitted by the worker implementation."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,r.jsx)(s.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Add a shared protocol module within ",(0,r.jsx)(s.code,{children:"@idle-engine/shell-desktop"}),": ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim/worker-protocol.ts"}),"."]}),"\n",(0,r.jsx)(s.li,{children:"Move all sim-worker message type definitions into this module."}),"\n",(0,r.jsxs)(s.li,{children:["Standardize the outbound \u201cframe delivery\u201d message to the existing coalesced ",(0,r.jsx)(s.code,{children:"frame"})," shape:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"{ kind: 'frame', frame?: RenderCommandBuffer, droppedFrames: number, nextStep: number }"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["Remove the ",(0,r.jsx)(s.code,{children:"frames"})," message shape from the protocol and delete the corresponding handler branch in ",(0,r.jsx)(s.code,{children:"main.ts"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["Update ",(0,r.jsx)(s.code,{children:"main.ts"}),", ",(0,r.jsx)(s.code,{children:"sim-worker.ts"}),", and tests to import the shared message types."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Runtime Changes"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"No changes to sim runtime behavior."}),"\n",(0,r.jsx)(s.li,{children:"No changes to tick scheduling or coalescing logic; only type consolidation and dead-branch removal."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Data & Schemas"}),": N/A (no persisted data changes)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"APIs & Contracts"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["New internal module: ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim/worker-protocol.ts"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["Contract definitions (TypeScript, structural at runtime):","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Inbound messages (main -> worker):","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SimWorkerInitMessage"}),": ",(0,r.jsx)(s.code,{children:"{ kind: 'init', stepSizeMs: number, maxStepsPerFrame: number }"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SimWorkerTickMessage"}),": ",(0,r.jsx)(s.code,{children:"{ kind: 'tick', deltaMs: number }"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SimWorkerEnqueueCommandsMessage"}),": ",(0,r.jsx)(s.code,{children:"{ kind: 'enqueueCommands', commands: readonly Command[] }"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SimWorkerShutdownMessage"}),": ",(0,r.jsx)(s.code,{children:"{ kind: 'shutdown' }"})," (supported for unit tests and potential future graceful shutdown; production ",(0,r.jsx)(s.code,{children:"main.ts"})," currently uses ",(0,r.jsx)(s.code,{children:"worker.terminate()"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SimWorkerInboundMessage"}),": union of the above."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["Outbound messages (worker -> main):","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SimWorkerReadyMessage"}),": ",(0,r.jsx)(s.code,{children:"{ kind: 'ready', stepSizeMs: number, nextStep: number }"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SimWorkerFrameMessage"}),": ",(0,r.jsx)(s.code,{children:"{ kind: 'frame', frame?: RenderCommandBuffer, droppedFrames: number, nextStep: number }"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SimWorkerErrorMessage"}),": ",(0,r.jsx)(s.code,{children:"{ kind: 'error', error: string }"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SimWorkerOutboundMessage"}),": union of the above."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["Implementation notes:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Use ",(0,r.jsx)(s.code,{children:"import type { ... }"})," for type-only imports (",(0,r.jsx)(s.code,{children:"Command"}),", ",(0,r.jsx)(s.code,{children:"RenderCommandBuffer"}),") to satisfy ",(0,r.jsx)(s.code,{children:"@typescript-eslint/consistent-type-imports"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["Keep local imports using ",(0,r.jsx)(s.code,{children:".js"})," specifiers (consistent with existing ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/*"})," patterns), e.g. ",(0,r.jsx)(s.code,{children:"import type { SimWorkerOutboundMessage } from './sim/worker-protocol.js'"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"main.ts"})," must not include any ",(0,r.jsx)(s.code,{children:"kind === 'frames'"})," branch after migration; ",(0,r.jsx)(s.code,{children:"SimWorkerFramesMessage"})," must not exist."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SimWorkerInitMessage"})," is a required main->worker configuration message in production. Runtime semantics for malformed payloads are still defined because the worker receives ",(0,r.jsx)(s.code,{children:"unknown"})," at runtime:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Validation: ",(0,r.jsx)(s.code,{children:"stepSizeMs"})," and ",(0,r.jsx)(s.code,{children:"maxStepsPerFrame"})," must each be a finite number ",(0,r.jsx)(s.code,{children:">= 1"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["On invalid/missing ",(0,r.jsx)(s.code,{children:"stepSizeMs"}),"/",(0,r.jsx)(s.code,{children:"maxStepsPerFrame"}),": emit ",(0,r.jsx)(s.code,{children:"{ kind: 'error', error: string }"})," and do not emit ",(0,r.jsx)(s.code,{children:"ready"})," for that message. The worker does not modify any existing runtime configuration."]}),"\n",(0,r.jsxs)(s.li,{children:["Error string stability for invalid ",(0,r.jsx)(s.code,{children:"init"}),": ",(0,r.jsx)(s.code,{children:"error"})," must contain the stable substring ",(0,r.jsx)(s.code,{children:"protocol:init"})," and the offending field name (",(0,r.jsx)(s.code,{children:"stepSizeMs"})," or ",(0,r.jsx)(s.code,{children:"maxStepsPerFrame"}),"). (Tests should assert these substrings rather than the full error string.)"]}),"\n",(0,r.jsxs)(s.li,{children:["Recovery: after an invalid ",(0,r.jsx)(s.code,{children:"init"}),", a later valid ",(0,r.jsx)(s.code,{children:"init"})," is accepted; it creates/replaces the runtime and emits ",(0,r.jsx)(s.code,{children:"ready"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["If the worker receives ",(0,r.jsx)(s.code,{children:"tick"})," / ",(0,r.jsx)(s.code,{children:"enqueueCommands"})," before any valid ",(0,r.jsx)(s.code,{children:"init"}),", it lazily creates a runtime using core defaults (",(0,r.jsx)(s.code,{children:"stepSizeMs = 100"}),", ",(0,r.jsx)(s.code,{children:"maxStepsPerFrame = 50"}),"). This remains true even if an earlier ",(0,r.jsx)(s.code,{children:"init"})," was invalid (invalid ",(0,r.jsx)(s.code,{children:"init"})," does not initialize the runtime)."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Tooling & Automation"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"No new tooling required. Ensure the package test suite still runs under existing Vitest config."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Deployment"}),": No special deployment considerations; this is packaged with the desktop app."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Telemetry & Observability"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Keep existing error logging behavior in ",(0,r.jsx)(s.code,{children:"main.ts"})," and ",(0,r.jsx)(s.code,{children:"sim-worker.ts"})," unchanged."]}),"\n",(0,r.jsx)(s.li,{children:"No additional console logging should be introduced (tests rely on clean output)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Security & Compliance"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"No new external inputs or PII surfaces are introduced."}),"\n",(0,r.jsxs)(s.li,{children:["Message parsing continues to treat untrusted payloads defensively (existing ",(0,r.jsx)(s.code,{children:"typeof message === 'object'"})," checks in ",(0,r.jsx)(s.code,{children:"sim-worker.ts"})," remain)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,r.jsx)(s.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Issue Title"}),(0,r.jsx)(s.th,{children:"Scope Summary"}),(0,r.jsx)(s.th,{children:"Proposed Assignee/Agent"}),(0,r.jsx)(s.th,{children:"Dependencies"}),(0,r.jsx)(s.th,{children:"Acceptance Criteria"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"feat(shell-desktop): add shared sim-worker protocol module"}),(0,r.jsxs)(s.td,{children:["Introduce ",(0,r.jsx)(s.code,{children:"worker-protocol.ts"})," defining inbound/outbound message types"]}),(0,r.jsx)(s.td,{children:"Runtime/Shell Implementation Agent"}),(0,r.jsx)(s.td,{children:"Doc approved"}),(0,r.jsxs)(s.td,{children:["Module added; exports cover all used message kinds; no ",(0,r.jsx)(s.code,{children:"frames"})," type in protocol"]})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"refactor(shell-desktop): migrate main/worker to shared protocol"}),(0,r.jsxs)(s.td,{children:["Replace inline protocol type declarations with imports; delete ",(0,r.jsx)(s.code,{children:"frames"})," handler branch"]}),(0,r.jsx)(s.td,{children:"Runtime/Shell Implementation Agent"}),(0,r.jsx)(s.td,{children:"Shared module merged"}),(0,r.jsxs)(s.td,{children:[(0,r.jsx)(s.code,{children:"main.ts"})," no longer references ",(0,r.jsx)(s.code,{children:"frames"}),"; ",(0,r.jsx)(s.code,{children:"sim-worker.ts"})," uses shared types; build passes"]})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"test(shell-desktop): update protocol tests"}),(0,r.jsxs)(s.td,{children:["Remove ",(0,r.jsx)(s.code,{children:"frames"})," simulations; update tests to compile against shared protocol types"]}),(0,r.jsx)(s.td,{children:"Test Agent"}),(0,r.jsx)(s.td,{children:"Main/worker migration merged"}),(0,r.jsxs)(s.td,{children:[(0,r.jsx)(s.code,{children:"pnpm test --filter @idle-engine/shell-desktop"})," passes; no ",(0,r.jsx)(s.code,{children:"frames"})," message remains in tests"]})]})]})]}),"\n",(0,r.jsx)(s.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Phase 1"}),": Implement shared protocol module + migrate main/worker + update tests (single PR)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Phase 2"}),": (Optional follow-up) Add runtime-level validation helpers (type guards) if future protocol expansion warrants stricter checks."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Hand-off Package"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Files to modify:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim/worker-protocol.ts"})," (new)"]}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"})}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.test.ts"})," (optional: type imports)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["Core behavioral constraint: keep worker\u2019s coalesced ",(0,r.jsx)(s.code,{children:"frame"})," behavior unchanged."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Communication Cadence"}),": Request review after tests pass for ",(0,r.jsx)(s.code,{children:"@idle-engine/shell-desktop"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Context Packets"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"GitHub issue: #849"}),"\n",(0,r.jsxs)(s.li,{children:["Source files: ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"}),", ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})]}),"\n",(0,r.jsxs)(s.li,{children:["Tests: ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"}),", ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.test.ts"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Prompting & Constraints"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Keep TypeScript style consistent: ES modules, two-space indentation, ",(0,r.jsx)(s.code,{children:"import type"})," usage."]}),"\n",(0,r.jsxs)(s.li,{children:["Do not edit generated ",(0,r.jsx)(s.code,{children:"dist/"})," outputs."]}),"\n",(0,r.jsx)(s.li,{children:"Avoid expanding scope to renderer IPC or runtime internals."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Safety Rails"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Do not introduce new runtime logging beyond existing ",(0,r.jsx)(s.code,{children:"console.error"})," sites."]}),"\n",(0,r.jsx)(s.li,{children:"Avoid changing tick-loop timing or message ordering semantics."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Validation Hooks"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.code,{children:"pnpm test --filter @idle-engine/shell-desktop"})}),"\n",(0,r.jsxs)(s.li,{children:["(Optional) ",(0,r.jsx)(s.code,{children:"pnpm lint --filter @idle-engine/shell-desktop"})," if available in workspace scripts."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:["Keep both ",(0,r.jsx)(s.code,{children:"frames"})," and ",(0,r.jsx)(s.code,{children:"frame"})," variants"]}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Pros: could support bulk frame delivery for debugging."}),"\n",(0,r.jsx)(s.li,{children:"Cons: increases surface area, encourages drift, and requires additional tests and runtime branches; violates the issue\u2019s \u201cno dead branch\u201d goal."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:["Reintroduce ",(0,r.jsx)(s.code,{children:"frames"})," intentionally (worker emits ",(0,r.jsx)(s.code,{children:"frames"}),")"]}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Pros: more explicit about multiple frames per tick."}),"\n",(0,r.jsxs)(s.li,{children:["Cons: renderer only needs the latest frame; the existing worker already computes ",(0,r.jsx)(s.code,{children:"droppedFrames"})," and provides a coalesced shape; switching back would increase message size and introduce additional main-process logic."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:["Move protocol types into ",(0,r.jsx)(s.code,{children:"ipc.ts"})]}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Pros: fewer files."}),"\n",(0,r.jsx)(s.li,{children:"Cons: mixes renderer IPC surface with worker protocol; increases coupling and makes it harder to evolve independently."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Unit / Integration"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Update ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Remove cases that emit ",(0,r.jsx)(s.code,{children:"{ kind: 'frames', ... }"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["Ensure forwarding behavior is still covered for ",(0,r.jsx)(s.code,{children:"frame"})," messages:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["When ",(0,r.jsx)(s.code,{children:"frame"})," is present, main forwards it to ",(0,r.jsx)(s.code,{children:"IPC_CHANNELS.frame"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["When ",(0,r.jsx)(s.code,{children:"frame"})," is absent, main does not send any frame IPC."]}),"\n",(0,r.jsx)(s.li,{children:"When forwarding throws, main logs an error (existing test remains valid)."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["Update ",(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.test.ts"}),":","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Compile-time: import protocol types for message payloads to ensure contract adherence."}),"\n",(0,r.jsxs)(s.li,{children:["Runtime: add explicit coverage for ",(0,r.jsx)(s.code,{children:"init"})," validation semantics:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Missing fields: ",(0,r.jsx)(s.code,{children:"init"})," missing ",(0,r.jsx)(s.code,{children:"stepSizeMs"})," and/or ",(0,r.jsx)(s.code,{children:"maxStepsPerFrame"})," emits ",(0,r.jsx)(s.code,{children:"{ kind: 'error' }"})," with ",(0,r.jsx)(s.code,{children:"error"})," containing ",(0,r.jsx)(s.code,{children:"protocol:init"})," and the missing field name; no ",(0,r.jsx)(s.code,{children:"ready"})," is emitted."]}),"\n",(0,r.jsxs)(s.li,{children:["Invalid values: non-finite values (",(0,r.jsx)(s.code,{children:"NaN"}),", ",(0,r.jsx)(s.code,{children:"Infinity"}),") and ",(0,r.jsx)(s.code,{children:"<= 0"})," values for either field emit ",(0,r.jsx)(s.code,{children:"{ kind: 'error' }"})," with ",(0,r.jsx)(s.code,{children:"error"})," containing ",(0,r.jsx)(s.code,{children:"protocol:init"})," and the offending field name; no ",(0,r.jsx)(s.code,{children:"ready"})," is emitted."]}),"\n",(0,r.jsxs)(s.li,{children:["Post-invalid behavior: after an invalid ",(0,r.jsx)(s.code,{children:"init"}),", a ",(0,r.jsx)(s.code,{children:"tick"})," still produces ",(0,r.jsx)(s.code,{children:"frame"})," output (default-runtime path), and a later valid ",(0,r.jsx)(s.code,{children:"init"})," emits ",(0,r.jsx)(s.code,{children:"ready"})," and proceeds normally."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Performance"}),": N/A (no algorithmic changes)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Tooling / A11y"}),": N/A."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Risk"}),": Removing ",(0,r.jsx)(s.code,{children:"frames"})," breaks any hidden callers relying on that shape.","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Mitigation"}),": ",(0,r.jsx)(s.code,{children:"frames"})," is not emitted by the worker implementation; update tests to match production behavior and keep the protocol internal to the package."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Risk"}),": TS-only refactor accidentally changes runtime payload shapes.","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Mitigation"}),": Keep runtime emit sites unchanged; validate with existing unit tests; ensure message shapes in tests match actual worker emissions."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Risk"}),": Future protocol additions drift again.","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Mitigation"}),": Require all additions to go through ",(0,r.jsx)(s.code,{children:"worker-protocol.ts"})," and update main/worker/tests by importing from it."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Milestones"}),": Single PR landing with protocol module + refactor + test updates."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Migration Strategy"}),": N/A (internal protocol shipped together)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Communication"}),": Mention in PR description that ",(0,r.jsx)(s.code,{children:"frames"})," was removed as dead code and that ",(0,r.jsx)(s.code,{children:"frame"})," is the canonical outbound message."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"13-resolved-decisions-from-design-review",children:"13. Resolved Decisions (from design review)"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"shutdown"})}),": Included in ",(0,r.jsx)(s.code,{children:"SimWorkerInboundMessage"}),". Expected sender is unit tests (and optionally future production code). Current production ",(0,r.jsx)(s.code,{children:"main.ts"})," shutdown continues to use ",(0,r.jsx)(s.code,{children:"worker.terminate()"}),"; no change to that behavior is required for this issue."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:[(0,r.jsx)(s.code,{children:"init"})," fields"]}),": ",(0,r.jsx)(s.code,{children:"SimWorkerInitMessage.stepSizeMs"})," and ",(0,r.jsx)(s.code,{children:"maxStepsPerFrame"})," are required in the shared protocol type. In production, ",(0,r.jsx)(s.code,{children:"main.ts"})," must send a valid ",(0,r.jsx)(s.code,{children:"init"})," before starting the tick loop. For malformed runtime payloads, invalid/missing fields emit ",(0,r.jsx)(s.code,{children:"{ kind: 'error', ... }"})," (with stable ",(0,r.jsx)(s.code,{children:"protocol:init"})," + field-name substrings), do not emit ",(0,r.jsx)(s.code,{children:"ready"})," for that ",(0,r.jsx)(s.code,{children:"init"}),", and do not change any existing runtime configuration; subsequent ",(0,r.jsx)(s.code,{children:"tick"}),"/",(0,r.jsx)(s.code,{children:"enqueueCommands"})," run against the existing runtime (or defaults if none exists) until a valid ",(0,r.jsx)(s.code,{children:"init"})," arrives."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Add optional runtime type-guard helpers (e.g., ",(0,r.jsx)(s.code,{children:"isSimWorkerOutboundMessage"}),") if future debugging indicates malformed messages are a recurring source of crashes."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"15-references",children:"15. References"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["GitHub issue: ",(0,r.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/849",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/849"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})," (sim worker protocol types and message handler branches)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})," (current worker emission uses ",(0,r.jsx)(s.code,{children:"kind: 'frame'"})," only)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"})," (tests currently simulate both ",(0,r.jsx)(s.code,{children:"frames"})," and ",(0,r.jsx)(s.code,{children:"frame"}),")"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Coalesced frame"}),": A protocol behavior where the worker may produce multiple render frames per tick but only sends the latest frame (plus a ",(0,r.jsx)(s.code,{children:"droppedFrames"})," count) to avoid flooding the main/renderer."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Protocol drift"}),": When message type definitions used by different components diverge over time without coordinated changes."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Date"}),(0,r.jsx)(s.th,{children:"Author"}),(0,r.jsx)(s.th,{children:"Change Summary"})]})}),(0,r.jsx)(s.tbody,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"2026-02-03"}),(0,r.jsx)(s.td,{children:"Codex (AI)"}),(0,r.jsx)(s.td,{children:"Initial draft"})]})})]})]})}function h(e={}){const{wrapper:s}={...(0,d.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);