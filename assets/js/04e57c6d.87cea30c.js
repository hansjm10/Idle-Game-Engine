"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[7253],{7678:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(9430);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},9029:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"automation-system-api","title":"AutomationSystem API Reference","description":"Complete API documentation for the Idle Engine automation system","source":"@site/../../docs/automation-system-api.md","sourceDirName":".","slug":"/automation-system-api","permalink":"/Idle-Game-Engine/automation-system-api","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/automation-system-api.md","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"title":"AutomationSystem API Reference","description":"Complete API documentation for the Idle Engine automation system","sidebar_position":13}}');var s=t(5270),i=t(7678);const o={title:"AutomationSystem API Reference",description:"Complete API documentation for the Idle Engine automation system",sidebar_position:13},a="AutomationSystem API Reference",d={},c=[{value:"Core API",id:"core-api",level:2},{value:"createAutomationSystem(options)",id:"createautomationsystemoptions",level:3},{value:"Resource State Accessor",id:"resource-state-accessor",level:2},{value:"ResourceStateAccessor (runtime input)",id:"resourcestateaccessor-runtime-input",level:3},{value:"Adapter helper",id:"adapter-helper",level:3},{value:"getAutomationState(system)",id:"getautomationstatesystem",level:3},{value:"restoreState(state, options)",id:"restorestatestate-options",level:3},{value:"State Types",id:"state-types",level:2},{value:"AutomationState",id:"automationstate",level:3},{value:"SerializedAutomationState",id:"serializedautomationstate",level:3},{value:"AutomationSystemOptions",id:"automationsystemoptions",level:3},{value:"ResourceStateReader",id:"resourcestatereader",level:3},{value:"ResourceState Adapter",id:"resourcestate-adapter",level:3},{value:"Trigger Evaluators",id:"trigger-evaluators",level:2},{value:"evaluateIntervalTrigger(automation, state, currentStep, stepDurationMs)",id:"evaluateintervaltriggerautomation-state-currentstep-stepdurationms",level:3},{value:"evaluateResourceThresholdTrigger(automation, resourceState)",id:"evaluateresourcethresholdtriggerautomation-resourcestate",level:3},{value:"evaluateCommandQueueEmptyTrigger(commandQueue)",id:"evaluatecommandqueueemptytriggercommandqueue",level:3},{value:"evaluateEventTrigger(automationId, pendingEventTriggers)",id:"evaluateeventtriggerautomationid-pendingeventtriggers",level:3},{value:"Cooldown Management",id:"cooldown-management",level:2},{value:"isCooldownActive(state, currentStep)",id:"iscooldownactivestate-currentstep",level:3},{value:"updateCooldown(automation, state, currentStep, stepDurationMs, formulaContext?)",id:"updatecooldownautomation-state-currentstep-stepdurationms-formulacontext",level:3},{value:"Command Enqueueing",id:"command-enqueueing",level:2},{value:"enqueueAutomationCommand(automation, commandQueue, currentStep, stepDurationMs)",id:"enqueueautomationcommandautomation-commandqueue-currentstep-stepdurationms",level:3},{value:"Integration Example",id:"integration-example",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"References",id:"references",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"automationsystem-api-reference",children:"AutomationSystem API Reference"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"AutomationSystem"})," evaluates automation triggers and enqueues commands when triggers fire. It supports 4 trigger types: interval, resourceThreshold, commandQueueEmpty, and event. As of issue #348, automations may declare a ",(0,s.jsx)(n.code,{children:"resourceCost"})," which is validated and deducted atomically at fire time."]}),"\n",(0,s.jsx)(n.h2,{id:"core-api",children:"Core API"}),"\n",(0,s.jsx)(n.h3,{id:"createautomationsystemoptions",children:"createAutomationSystem(options)"}),"\n",(0,s.jsx)(n.p,{children:"Creates an AutomationSystem that evaluates triggers and enqueues commands."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function createAutomationSystem(\n  options: AutomationSystemOptions\n): System & { getState: () => ReadonlyMap<string, AutomationState> }\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options.automations"})," (readonly AutomationDefinition[]): Array of automation definitions from content pack"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options.stepDurationMs"})," (number): Duration of each runtime step in milliseconds (default: 100)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options.commandQueue"})," (CommandQueue): The runtime's command queue instance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options.resourceState"})," (ResourceStateAccessor): Resource state accessor used for threshold evaluation and optional spending when ",(0,s.jsx)(n.code,{children:"resourceCost"})," is present"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options.initialState"})," (Map<string, AutomationState>, optional): Restored automation state from save file"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," System object with additional ",(0,s.jsx)(n.code,{children:"getState()"})," method for state extraction"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { createAutomationSystem } from '@idle-engine/core';\n\nconst system = createAutomationSystem({\n  automations: contentPack.automations,\n  stepDurationMs: 100,\n  commandQueue: runtime.getCommandQueue(),\n  // Prefer the adapter to normalize indices and expose spend\n  resourceState: createResourceStateAdapter(progressionCoordinator.resourceState),\n  initialState: savedState?.automationState,\n});\n\nruntime.addSystem(system);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Lifecycle:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Initialization"}),": Creates state for each automation (enabled/disabled, cooldowns, last-fired)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Setup"}),": Subscribes to event triggers and automation toggle commands"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tick"}),": Evaluates triggers each tick, enqueues commands when triggered"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"State Persistence:"})}),"\n",(0,s.jsx)(n.p,{children:"Unlock state is persistent\u2014once an automation is unlocked, it remains unlocked. The system only evaluates unlock conditions for automations that are not yet unlocked. Currently, only 'always' unlock conditions are evaluated; full condition evaluation requires integration with progression systems."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"resource-state-accessor",children:"Resource State Accessor"}),"\n",(0,s.jsx)(n.h3,{id:"resourcestateaccessor-runtime-input",children:"ResourceStateAccessor (runtime input)"}),"\n",(0,s.jsxs)(n.p,{children:["Minimal interface used by the automation system to read resource amounts, resolve IDs, and (optionally) spend when an automation declares a ",(0,s.jsx)(n.code,{children:"resourceCost"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export interface ResourceStateAccessor {\n  getAmount(resourceIndex: number): number;\n  getResourceIndex?(resourceId: string): number; // returns -1 if not found\n  spendAmount?(\n    resourceIndex: number,\n    amount: number,\n    context?: { systemId?: string; commandId?: string },\n  ): boolean; // returns true on successful spend\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Spending is attempted during ",(0,s.jsx)(n.code,{children:"tick()"})," after a trigger fires but before enqueueing the target command. If the spend fails, the automation does not enqueue or enter cooldown on that tick."]}),"\n",(0,s.jsx)(n.li,{children:"For event triggers, failed spends retain the pending event so the automation can retry on a later tick."}),"\n",(0,s.jsx)(n.li,{children:"For resource threshold triggers, failed spends do not consume the false\u2192true crossing so the automation retries while the condition remains satisfied."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Note: ",(0,s.jsx)(n.code,{children:"ResourceStateReader"})," remains as a deprecated alias. Prefer ",(0,s.jsx)(n.code,{children:"ResourceStateAccessor"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"adapter-helper",children:"Adapter helper"}),"\n",(0,s.jsxs)(n.p,{children:["Use the adapter to bridge from the core ",(0,s.jsx)(n.code,{children:"ResourceState"})," API (which exposes ",(0,s.jsx)(n.code,{children:"getIndex"}),") to the ",(0,s.jsx)(n.code,{children:"ResourceStateAccessor"})," contract expected by the automation system:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createResourceStateAdapter } from '@idle-engine/core';\n\nconst system = createAutomationSystem({\n  automations,\n  commandQueue,\n  stepDurationMs,\n  resourceState: createResourceStateAdapter(progressionCoordinator.resourceState),\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getautomationstatesystem",children:"getAutomationState(system)"}),"\n",(0,s.jsx)(n.p,{children:"Extracts the internal state from an AutomationSystem for serialization to save files."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function getAutomationState(\n  system: ReturnType<typeof createAutomationSystem>\n): ReadonlyMap<string, AutomationState>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"system"}),": The AutomationSystem instance from which to extract state"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ReadonlyMap of automation IDs to their current state"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const state = getAutomationState(automationSystem);\nconst autoState = state.get('auto:collector');\nconsole.log(`Enabled: ${autoState?.enabled}, Last fired: ${autoState?.lastFiredStep}`);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"restorestatestate-options",children:"restoreState(state, options)"}),"\n",(0,s.jsx)(n.p,{children:"Restores automation state from serialized save data."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"restoreState(\n  state: readonly SerializedAutomationState[],\n  options?: { savedWorkerStep?: number; currentStep?: number }\n): void\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"state"}),": Array of serialized automation state entries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options.savedWorkerStep"})," (optional): Step number when snapshot was captured (for rebasing)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options.currentStep"})," (optional): Current runtime step (default: 0)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Merges provided entries into existing automation definitions"}),"\n",(0,s.jsxs)(n.li,{children:["Normalizes ",(0,s.jsx)(n.code,{children:"lastFiredStep: null"})," \u2192 ",(0,s.jsx)(n.code,{children:"-Infinity"})," (never fired)"]}),"\n",(0,s.jsxs)(n.li,{children:["Rebases step fields when ",(0,s.jsx)(n.code,{children:"savedWorkerStep"})," is provided"]}),"\n",(0,s.jsx)(n.li,{children:"Ignores unknown automation IDs not in current definitions"}),"\n",(0,s.jsx)(n.li,{children:"Preserves defaults for automations not in restore array"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Step Rebasing:"})}),"\n",(0,s.jsxs)(n.p,{children:["When restoring from a snapshot captured at a non-zero worker step, ",(0,s.jsx)(n.code,{children:"lastFiredStep"})," and ",(0,s.jsx)(n.code,{children:"cooldownExpiresStep"})," are absolute to that timeline. The rebase adjusts them to the caller's current timeline so cooldown math remains consistent:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"rebaseDelta = currentStep - savedWorkerStep\nrebasedLastFired = normalizedLastFired + rebaseDelta\nrebasedCooldownExpires = cooldownExpiresStep + rebaseDelta\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"savedWorkerStep"})," is not provided or invalid, no rebasing occurs."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Restore automation state from save file\nautomationSystem.restoreState([\n  {\n    id: 'auto:collector',\n    enabled: true,\n    lastFiredStep: 100,\n    cooldownExpiresStep: 110,\n    unlocked: true,\n  }\n], { savedWorkerStep: 100, currentStep: 0 });\n\n// After restore, lastFiredStep is rebased to 0, cooldownExpiresStep to 10\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example with null (never fired):"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Restore automation that has never fired\nautomationSystem.restoreState([\n  {\n    id: 'auto:new',\n    enabled: false,\n    lastFiredStep: null, // null represents -Infinity (never fired)\n    cooldownExpiresStep: 0,\n    unlocked: false,\n  }\n]);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"state-types",children:"State Types"}),"\n",(0,s.jsx)(n.h3,{id:"automationstate",children:"AutomationState"}),"\n",(0,s.jsx)(n.p,{children:"Internal state for a single automation."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Definition:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface AutomationState {\n  readonly id: string;\n  enabled: boolean;\n  lastFiredStep: number;\n  cooldownExpiresStep: number;\n  unlocked: boolean;\n  lastThresholdSatisfied?: boolean;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fields:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"id"}),": Automation identifier matching the content definition"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enabled"}),": Whether the automation is currently enabled"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lastFiredStep"}),": Step number when automation last fired (-Infinity if never)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cooldownExpiresStep"}),": Step number when cooldown expires (0 if no cooldown)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"unlocked"}),": Whether the automation is currently unlocked"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lastThresholdSatisfied"}),": Previous threshold state for crossing detection (undefined = never evaluated)"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"serializedautomationstate",children:"SerializedAutomationState"}),"\n",(0,s.jsx)(n.p,{children:"Serialized representation of automation state for save files and persistence."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Definition:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface SerializedAutomationState {\n  readonly id: string;\n  readonly enabled: boolean;\n  readonly lastFiredStep: number | null;  // null = never fired (-Infinity)\n  readonly cooldownExpiresStep: number;\n  readonly unlocked: boolean;\n  readonly lastThresholdSatisfied?: boolean;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fields:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"id"}),": Automation identifier matching the content definition"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enabled"}),": Whether the automation is currently enabled"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lastFiredStep"}),": Step number when automation last fired (",(0,s.jsx)(n.code,{children:"null"})," if never fired)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cooldownExpiresStep"}),": Step number when cooldown expires (0 if no cooldown)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"unlocked"}),": Whether the automation is currently unlocked"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lastThresholdSatisfied"}),": Previous threshold state for crossing detection"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Differences from ",(0,s.jsx)(n.code,{children:"AutomationState"}),":"]})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lastFiredStep"})," is ",(0,s.jsx)(n.code,{children:"number | null"})," instead of ",(0,s.jsx)(n.code,{children:"number"})," (for JSON compatibility)"]}),"\n",(0,s.jsxs)(n.li,{children:["All fields are ",(0,s.jsx)(n.code,{children:"readonly"})," (serialized data is immutable)"]}),"\n",(0,s.jsxs)(n.li,{children:["Used in ",(0,s.jsx)(n.code,{children:"SerializedResourceState.automationState"})," and ",(0,s.jsx)(n.code,{children:"restoreState()"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Serialization Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"-Infinity"})," values are converted to ",(0,s.jsx)(n.code,{children:"null"})," during serialization (",(0,s.jsx)(n.code,{children:"exportForSave"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"null"})," values are converted back to ",(0,s.jsx)(n.code,{children:"-Infinity"})," during restoration (",(0,s.jsx)(n.code,{children:"restoreState"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"This ensures JSON compatibility while preserving semantic meaning"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"automationsystemoptions",children:"AutomationSystemOptions"}),"\n",(0,s.jsx)(n.p,{children:"Configuration options for creating an AutomationSystem."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Definition:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface AutomationSystemOptions {\n  readonly automations: readonly AutomationDefinition[];\n  readonly stepDurationMs: number;\n  readonly commandQueue: CommandQueue;\n  readonly resourceState: ResourceStateReader;\n  readonly initialState?: Map<string, AutomationState>;\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"resourcestatereader",children:"ResourceStateReader"}),"\n",(0,s.jsx)(n.p,{children:"Minimal interface for resource state access during automation evaluation."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Definition:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface ResourceStateReader {\n  getAmount(resourceIndex: number): number;\n  getResourceIndex?(resourceId: string): number;\n  spendAmount?(\n    resourceIndex: number,\n    amount: number,\n    context?: { systemId?: string; commandId?: string },\n  ): boolean;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Methods:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getAmount(resourceIndex)"}),": Returns the current amount of the resource at the given index"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getResourceIndex(resourceId)"}),": Resolves a resource ID to its internal index (-1 if not found)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"spendAmount(index, amount, context?)"}),": Optionally spend from a resource. If unavailable, automations with ",(0,s.jsx)(n.code,{children:"resourceCost"})," will treat spending as failed (skip enqueue and cooldown)."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"resourcestate-adapter",children:"ResourceState Adapter"}),"\n",(0,s.jsxs)(n.p,{children:["When integrating ",(0,s.jsx)(n.code,{children:"AutomationSystem"})," with ",(0,s.jsx)(n.code,{children:"ProgressionCoordinator"}),", use ",(0,s.jsx)(n.code,{children:"createResourceStateAdapter"})," to bridge the interface gap:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { createResourceStateAdapter } from '@idle-engine/core';\n\nconst automationSystem = createAutomationSystem({\n  automations: sampleContent.automations,\n  commandQueue: runtime.getCommandQueue(),\n  resourceState: createResourceStateAdapter(progressionCoordinator.resourceState),\n  stepDurationMs,\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why the adapter is needed:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ResourceState.getIndex(id)"})," returns ",(0,s.jsx)(n.code,{children:"number | undefined"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ResourceStateReader.getResourceIndex(id)"})," expects ",(0,s.jsx)(n.code,{children:"number"}),' (with -1 for "not found")']}),"\n",(0,s.jsxs)(n.li,{children:["The adapter forwards ",(0,s.jsx)(n.code,{children:"spendAmount"})," when available so automations can enforce resource costs"]}),"\n",(0,s.jsxs)(n.li,{children:["The adapter converts ",(0,s.jsx)(n.code,{children:"undefined \u2192 -1"})," for proper automation evaluation"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Without the adapter:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"resourceState"})," would lack ",(0,s.jsx)(n.code,{children:"getResourceIndex"})," entirely"]}),"\n",(0,s.jsx)(n.li,{children:"Automations would fall back to reading index 0 for all resources"}),"\n",(0,s.jsx)(n.li,{children:"Resource-threshold automations for non-first resources would be inert"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"trigger-evaluators",children:"Trigger Evaluators"}),"\n",(0,s.jsx)(n.h3,{id:"evaluateintervaltriggerautomation-state-currentstep-stepdurationms",children:"evaluateIntervalTrigger(automation, state, currentStep, stepDurationMs)"}),"\n",(0,s.jsx)(n.p,{children:"Evaluates whether an interval trigger should fire."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function evaluateIntervalTrigger(\n  automation: AutomationDefinition,\n  state: AutomationState,\n  currentStep: number,\n  stepDurationMs: number\n): boolean\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Fires immediately on first tick (when ",(0,s.jsx)(n.code,{children:"lastFiredStep === -Infinity"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Fires when elapsed steps since last fire \u2265 interval duration in steps"}),"\n",(0,s.jsxs)(n.li,{children:["Interval is calculated as ",(0,s.jsx)(n.code,{children:"Math.ceil(intervalMs / stepDurationMs)"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Automation with 1000ms interval, 100ms step duration\n// Interval = 10 steps (1000ms / 100ms)\nconst shouldFire = evaluateIntervalTrigger(automation, state, 10, 100);\n// Returns true if currentStep - lastFiredStep >= 10\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Throws:"})," Error if automation trigger is not of kind 'interval'"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"evaluateresourcethresholdtriggerautomation-resourcestate",children:"evaluateResourceThresholdTrigger(automation, resourceState)"}),"\n",(0,s.jsx)(n.p,{children:"Evaluates whether a resourceThreshold condition is currently satisfied."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function evaluateResourceThresholdTrigger(\n  automation: AutomationDefinition,\n  resourceState: ResourceStateReader\n): boolean\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Returns current state of the condition (not crossing detection)"}),"\n",(0,s.jsx)(n.li,{children:"Caller must track previous state to detect crossings"}),"\n",(0,s.jsxs)(n.li,{children:["Resource IDs resolved to indices via ",(0,s.jsx)(n.code,{children:"resourceState.getResourceIndex()"})]}),"\n",(0,s.jsx)(n.li,{children:"Missing resources (index -1) treated as amount 0"}),"\n",(0,s.jsxs)(n.li,{children:["Supports four comparators: ",(0,s.jsx)(n.code,{children:"gte"}),", ",(0,s.jsx)(n.code,{children:"gt"}),", ",(0,s.jsx)(n.code,{children:"lte"}),", ",(0,s.jsx)(n.code,{children:"lt"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Crossing Detection Pattern:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const currentlySatisfied = evaluateResourceThresholdTrigger(automation, resourceState);\nconst previouslySatisfied = state.lastThresholdSatisfied ?? false;\n\n// Fire only on transition from false -> true (crossing event)\nconst triggered = currentlySatisfied && !previouslySatisfied;\n\n// Update state for next tick\nstate.lastThresholdSatisfied = currentlySatisfied;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Cooldown Interaction:"})}),"\n",(0,s.jsxs)(n.p,{children:["This function is called during cooldown checks to update ",(0,s.jsx)(n.code,{children:"AutomationState.lastThresholdSatisfied"}),". This ensures crossing detection remains accurate when the cooldown expires, even if the resource crossed the threshold multiple times during the cooldown period."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Throws:"})," Error if automation trigger is not of kind 'resourceThreshold'"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"evaluatecommandqueueemptytriggercommandqueue",children:"evaluateCommandQueueEmptyTrigger(commandQueue)"}),"\n",(0,s.jsx)(n.p,{children:"Evaluates whether a commandQueueEmpty trigger should fire."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function evaluateCommandQueueEmptyTrigger(\n  commandQueue: CommandQueue\n): boolean\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Returns true if command queue size is 0"}),"\n",(0,s.jsx)(n.li,{children:"Allows automations to fire when no other commands are pending"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const commandQueue = new CommandQueue();\nconst shouldFire = evaluateCommandQueueEmptyTrigger(commandQueue); // true\n\ncommandQueue.enqueue({ type: 'PURCHASE_UPGRADE', ... });\nconst shouldNotFire = evaluateCommandQueueEmptyTrigger(commandQueue); // false\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"evaluateeventtriggerautomationid-pendingeventtriggers",children:"evaluateEventTrigger(automationId, pendingEventTriggers)"}),"\n",(0,s.jsx)(n.p,{children:"Evaluates whether an event trigger should fire."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function evaluateEventTrigger(\n  automationId: string,\n  pendingEventTriggers: ReadonlySet<string>\n): boolean\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Returns true if automation ID is in the pending triggers set"}),"\n",(0,s.jsxs)(n.li,{children:["Set is populated by event handlers during ",(0,s.jsx)(n.code,{children:"setup()"})]}),"\n",(0,s.jsx)(n.li,{children:"Set is cleared after each tick"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const pendingEventTriggers = new Set(['auto:collector', 'auto:upgrader']);\nconst shouldFire = evaluateEventTrigger('auto:collector', pendingEventTriggers); // true\nconst shouldNotFire = evaluateEventTrigger('auto:other', pendingEventTriggers); // false\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"cooldown-management",children:"Cooldown Management"}),"\n",(0,s.jsx)(n.h3,{id:"iscooldownactivestate-currentstep",children:"isCooldownActive(state, currentStep)"}),"\n",(0,s.jsx)(n.p,{children:"Checks if an automation is currently in cooldown."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function isCooldownActive(\n  state: AutomationState,\n  currentStep: number\n): boolean\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Returns true if ",(0,s.jsx)(n.code,{children:"currentStep < state.cooldownExpiresStep"})]}),"\n",(0,s.jsx)(n.li,{children:"Returns false if cooldown has expired or no cooldown is active"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const state = {\n  id: 'auto:test',\n  enabled: true,\n  lastFiredStep: 10,\n  cooldownExpiresStep: 20,\n  unlocked: true\n};\nconst isActive = isCooldownActive(state, 15); // true\nconst isExpired = isCooldownActive(state, 20); // false\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"updatecooldownautomation-state-currentstep-stepdurationms-formulacontext",children:"updateCooldown(automation, state, currentStep, stepDurationMs, formulaContext?)"}),"\n",(0,s.jsx)(n.p,{children:"Updates the cooldown expiration step after an automation fires."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function updateCooldown(\n  automation: AutomationDefinition,\n  state: AutomationState,\n  currentStep: number,\n  stepDurationMs: number,\n  formulaContext?: FormulaEvaluationContext\n): void\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Evaluates cooldown as a numeric formula using the provided context"}),"\n",(0,s.jsxs)(n.li,{children:["Converts cooldown duration (ms) to steps: ",(0,s.jsx)(n.code,{children:"Math.ceil(cooldown / stepDurationMs)"})]}),"\n",(0,s.jsxs)(n.li,{children:["Sets ",(0,s.jsx)(n.code,{children:"cooldownExpiresStep = currentStep + cooldownSteps + 1"})]}),"\n",(0,s.jsx)(n.li,{children:"The +1 accounts for command execution delay (commands execute at currentStep + 1)"}),"\n",(0,s.jsxs)(n.li,{children:["If no cooldown defined or evaluation is non-finite/\u22640, sets ",(0,s.jsx)(n.code,{children:"cooldownExpiresStep = 0"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const automation = { cooldown: { kind: 'constant', value: 500 }, ... };\nconst state = { cooldownExpiresStep: 0, ... };\nupdateCooldown(automation, state, 10, 100); // stepDurationMs = 100ms\n// state.cooldownExpiresStep will be 16 (10 + ceil(500/100) + 1)\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"command-enqueueing",children:"Command Enqueueing"}),"\n",(0,s.jsx)(n.h3,{id:"enqueueautomationcommandautomation-commandqueue-currentstep-stepdurationms",children:"enqueueAutomationCommand(automation, commandQueue, currentStep, stepDurationMs)"}),"\n",(0,s.jsx)(n.p,{children:"Enqueues a command for an automation trigger."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function enqueueAutomationCommand(\n  automation: AutomationDefinition,\n  commandQueue: CommandQueue,\n  currentStep: number,\n  stepDurationMs: number\n): void\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Converts automation target into appropriate command type"}),"\n",(0,s.jsxs)(n.li,{children:["Enqueues command at ",(0,s.jsx)(n.code,{children:"CommandPriority.AUTOMATION"})]}),"\n",(0,s.jsxs)(n.li,{children:["Commands scheduled to execute on next step (",(0,s.jsx)(n.code,{children:"currentStep + 1"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Timestamps derived from simulation clock (",(0,s.jsx)(n.code,{children:"step * stepDurationMs"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Target Type Mapping:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Target Type"}),(0,s.jsx)(n.th,{children:"Command Type"}),(0,s.jsx)(n.th,{children:"Payload"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"generator"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TOGGLE_GENERATOR"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{ generatorId: targetId, enabled: targetEnabled ?? true }"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"upgrade"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PURCHASE_UPGRADE"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{ upgradeId: targetId }"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"purchaseGenerator"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PURCHASE_GENERATOR"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{ generatorId: targetId, count: floor(targetCount ?? 1) (min 1) }"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"collectResource"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"COLLECT_RESOURCE"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{ resourceId: targetId, amount: max(targetAmount ?? 1, 0) }"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"system"})}),(0,s.jsx)(n.td,{children:"System-specific"}),(0,s.jsxs)(n.td,{children:["Mapped via ",(0,s.jsx)(n.code,{children:"mapSystemTargetToCommandType()"})]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Generator Behavior:"})}),"\n",(0,s.jsxs)(n.p,{children:["Generator automations default to enabling generators (",(0,s.jsx)(n.code,{children:"targetEnabled"})," omitted \u2192 ",(0,s.jsx)(n.code,{children:"enabled: true"}),"). To disable generators via automation, set ",(0,s.jsx)(n.code,{children:"targetEnabled: false"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"PurchaseGenerator Behavior:"})}),"\n",(0,s.jsxs)(n.p,{children:["PurchaseGenerator automations enqueue ",(0,s.jsx)(n.code,{children:"PURCHASE_GENERATOR"})," with a deterministic ",(0,s.jsx)(n.code,{children:"count"}),". When ",(0,s.jsx)(n.code,{children:"targetCount"})," is omitted the runtime defaults to ",(0,s.jsx)(n.code,{children:"1"}),". Non-integer values are floored and counts are clamped to a minimum of ",(0,s.jsx)(n.code,{children:"1"})," before enqueueing."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"CollectResource Behavior:"})}),"\n",(0,s.jsxs)(n.p,{children:["CollectResource automations enqueue ",(0,s.jsx)(n.code,{children:"COLLECT_RESOURCE"})," with a deterministic ",(0,s.jsx)(n.code,{children:"amount"}),". When ",(0,s.jsx)(n.code,{children:"targetAmount"})," is omitted the runtime defaults to ",(0,s.jsx)(n.code,{children:"1"}),". Non-positive or non-finite amounts are treated as ",(0,s.jsx)(n.code,{children:"0"})," before enqueueing."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const automation = {\n  targetType: 'generator',\n  targetId: 'gen:clicks',\n  ...\n};\nenqueueAutomationCommand(automation, commandQueue, 10, 100);\n// Command enqueued to execute at step 11 with timestamp 1000ms\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Throws:"})," Error if target type is unknown"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"integration-example",children:"Integration Example"}),"\n",(0,s.jsx)(n.p,{children:"Complete integration with IdleEngineRuntime:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import {\n  createAutomationSystem,\n  getAutomationState,\n  IdleEngineRuntime,\n} from '@idle-engine/core';\n\n// Load content pack\nconst contentPack = await import('@idle-engine/sample-pack');\n\n// Create runtime\nconst runtime = new IdleEngineRuntime({\n  stepDurationMs: 100,\n  contentPack,\n});\n\n// Create automation system\nconst automationSystem = createAutomationSystem({\n  automations: contentPack.automations,\n  stepDurationMs: 100,\n  commandQueue: runtime.getCommandQueue(),\n  resourceState: progressionCoordinator.resourceState,\n  initialState: loadedState?.automationState,\n});\n\n// Register system\nruntime.addSystem(automationSystem);\n\n// Start runtime\nruntime.start();\n\n// Later: Extract state for save file\nconst automationState = getAutomationState(automationSystem);\nconst saveData = {\n  progression: progressionCoordinator.getState(),\n  automationState: Array.from(automationState.entries()).reduce(\n    (acc, [id, state]) => ({ ...acc, [id]: state }),\n    {}\n  ),\n};\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Tick Budget:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Automation evaluation must complete within per-tick budget (<2ms for 100 automations)"}),"\n",(0,s.jsx)(n.li,{children:"Use lazy evaluation: skip locked/disabled automations early"}),"\n",(0,s.jsx)(n.li,{children:"Prefer Map lookups over array scans for O(1) performance"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Memory:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Automation state memory usage <1KB per automation"}),"\n",(0,s.jsx)(n.li,{children:"State is compact: booleans, numbers, no deep nesting"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Determinism:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Trigger evaluation must be pure (same inputs \u2192 same outputs)"}),"\n",(0,s.jsxs)(n.li,{children:["No ",(0,s.jsx)(n.code,{children:"Date.now()"})," or ",(0,s.jsx)(n.code,{children:"Math.random()"})," in trigger logic"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"context.step"})," and ",(0,s.jsx)(n.code,{children:"context.timestamp"})," for timing"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Design Document: ",(0,s.jsx)(n.code,{children:"docs/automation-execution-system-design.md"})]}),"\n",(0,s.jsxs)(n.li,{children:["Content Schema: ",(0,s.jsx)(n.code,{children:"packages/content-schema/src/modules/automations.ts"})]}),"\n",(0,s.jsxs)(n.li,{children:["Implementation: ",(0,s.jsx)(n.code,{children:"packages/core/src/automation-system.ts"})]}),"\n",(0,s.jsxs)(n.li,{children:["Tests: ",(0,s.jsx)(n.code,{children:"packages/core/src/automation-system.test.ts"})]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);