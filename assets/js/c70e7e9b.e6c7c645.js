"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[25],{2269:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"issue-812-design","title":"renderer-webgpu: prevent atlas UV bleeding (Issue 812)","description":"Document Control","source":"@site/../../docs/issue-812-design.md","sourceDirName":".","slug":"/issue-812-design","permalink":"/Idle-Game-Engine/issue-812-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/issue-812-design.md","tags":[],"version":"current","sidebarPosition":99,"frontMatter":{"title":"renderer-webgpu: prevent atlas UV bleeding (Issue 812)","sidebar_position":99}}');var r=s(5270),l=s(7678);const t={title:"renderer-webgpu: prevent atlas UV bleeding (Issue 812)",sidebar_position:99},d="renderer-webgpu: prevent atlas UV bleeding (Issue 812)",a={},c=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Open Questions",id:"13-open-questions",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"renderer-webgpu-prevent-atlas-uv-bleeding-issue-812",children:"renderer-webgpu: prevent atlas UV bleeding (Issue 812)"})}),"\n",(0,r.jsx)(n.h2,{id:"document-control",children:"Document Control"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Title"}),": Prevent sprite atlas UV bleeding (half-texel inset + optional padding extrusion)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authors"}),": Codex (AI)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reviewers"}),": @hansjm10"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Status"}),": Draft"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Last Updated"}),": 2026-01-24"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Related Issues"}),": ",(0,r.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/812",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/812"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"@idle-engine/renderer-webgpu"})," currently computes atlas UVs on texel edges for both sprite images and bitmap font glyphs. Under common scaling/transform scenarios, interpolated UVs can drift across atlas entry boundaries, causing visible bleeding/fringing from adjacent atlas entries (even with ",(0,r.jsx)(n.code,{children:"nearest"})," sampling). This design updates UV generation to sample texel centers via a half-texel inset, and optionally extrudes atlas entry edge pixels into the existing packing padding to further reduce bleeding on implementations with different precision/rounding behavior."]}),"\n",(0,r.jsx)(n.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Background"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})," builds a packed texture atlas (",(0,r.jsx)(n.code,{children:"packAtlas(...)"})," + ",(0,r.jsx)(n.code,{children:"copyExternalImageToTexture"}),") and renders sprites/text as instanced quads."]}),"\n",(0,r.jsxs)(n.li,{children:["The quad shader computes per-fragment UVs as ",(0,r.jsx)(n.code,{children:"mix(instanceUvRect.xy, instanceUvRect.zw, localUv)"})," and samples the atlas via ",(0,r.jsx)(n.code,{children:"textureSample(...)"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["The sprite sampler is configured with ",(0,r.jsx)(n.code,{children:"nearest"})," for both ",(0,r.jsx)(n.code,{children:"magFilter"})," and ",(0,r.jsx)(n.code,{children:"minFilter"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["UV rectangles are currently expressed as exact atlas entry edges (e.g. ",(0,r.jsx)(n.code,{children:"u0 = x / atlasWidth"}),", ",(0,r.jsx)(n.code,{children:"u1 = (x + width) / atlasWidth"}),")."]}),"\n",(0,r.jsx)(n.li,{children:"When a quad is transformed/scaled, interpolation and floating point error can push fragment UVs across the intended boundary, causing sampling from neighboring atlas entries."}),"\n",(0,r.jsx)(n.li,{children:"Bitmap font glyph UVs have the same edge-based issue at glyph sub-rect boundaries within a font image."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forces"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keep behavior deterministic across platforms and runs."}),"\n",(0,r.jsx)(n.li,{children:"Avoid changes to the renderer contract; treat this as an internal renderer correctness fix."}),"\n",(0,r.jsxs)(n.li,{children:["Maintain support for ",(0,r.jsx)(n.code,{children:"paddingPx: 0"})," (minimal atlas footprint) while still fixing the root cause."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Goals"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Compute sprite and glyph UV rectangles using a half-texel inset (texel center coordinates) to avoid sampling outside the intended rectangle."}),"\n",(0,r.jsx)(n.li,{children:"(Optional) Extrude atlas entry edge pixels into padding when available to further reduce bleeding due to precision drift."}),"\n",(0,r.jsx)(n.li,{children:"Add deterministic unit tests that fail if UV rect generation regresses (for both sprite images and bitmap fonts)."}),"\n",(0,r.jsxs)(n.li,{children:["Keep ",(0,r.jsx)(n.code,{children:"WebGpuAtlasLayout"})," and ",(0,r.jsx)(n.code,{children:"atlasLayoutHash"})," semantics unchanged."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Non-Goals"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Switching the default sampler to linear filtering or introducing mipmaps."}),"\n",(0,r.jsx)(n.li,{children:"Introducing a new texture packing format or per-sprite textures/texture arrays."}),"\n",(0,r.jsx)(n.li,{children:"Building a golden-image rendering harness (can be follow-up work)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Primary Stakeholders"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Renderer maintainers (",(0,r.jsx)(n.code,{children:"packages/renderer-webgpu"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Host apps rendering scaled sprites/text (",(0,r.jsx)(n.code,{children:"packages/shell-desktop"}),", future web shells)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Agent Roles"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Docs Agent"}),": Maintain this design doc and track decisions/open questions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Renderer Implementation Agent"}),": Implement UV inset and (optional) extrusion during atlas upload."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test Agent"}),": Add regression tests for UV generation and (if implemented) extrusion behavior."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Affected Packages/Services"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})," (UV math, atlas upload)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})," (regression tests)"]}),"\n",(0,r.jsxs)(n.li,{children:["(Optional) ",(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/atlas-packer.ts"})," (if extrusion requires packer changes later)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compatibility Considerations"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No renderer-contract changes."}),"\n",(0,r.jsx)(n.li,{children:"Rendered output will change slightly at sprite/glyph edges, but only to eliminate visible artifacts."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Atlas UVs for packed sprite images are generated by ",(0,r.jsx)(n.code,{children:"buildUvByAssetId(...)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"u0 = entry.x / atlasWidthPx"}),", ",(0,r.jsx)(n.code,{children:"u1 = (entry.x + entry.width) / atlasWidthPx"})," (same for ",(0,r.jsx)(n.code,{children:"v"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Bitmap font glyph UVs are generated in ",(0,r.jsx)(n.code,{children:"buildBitmapFontRuntimeGlyph(...)"})," using the same edge-based approach after offsetting by the packed font atlas entry."]}),"\n",(0,r.jsxs)(n.li,{children:["Atlas upload (",(0,r.jsx)(n.code,{children:"#createAtlasTextureAndUpload"}),") copies each external source image directly into the atlas at ",(0,r.jsx)(n.code,{children:"(entry.x, entry.y)"})," and does not populate the surrounding padding pixels (padding is effectively transparent/undefined unless explicitly written)."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,r.jsx)(n.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Replace edge-based UV rectangles with texel-center UV rectangles (half-texel inset) for:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["sprite atlas entries (",(0,r.jsx)(n.code,{children:"buildUvByAssetId"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["bitmap font glyph sub-rects (",(0,r.jsx)(n.code,{children:"buildBitmapFontRuntimeGlyph"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Optionally, when the atlas packing ",(0,r.jsx)(n.code,{children:"paddingPx"})," is large enough (default is ",(0,r.jsx)(n.code,{children:"2"}),"), extrude each atlas entry\u2019s edge pixels into the padding region during atlas upload. This reduces visible fringes if UVs drift slightly outside the intended rectangle due to interpolation or precision."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Changes"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Introduce a small pure helper to convert a pixel-space rectangle to a ",(0,r.jsx)(n.code,{children:"SpriteUvRect"})," using half-texel inset:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"u0 = (x + 0.5) / atlasWidthPx"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"u1 = (x + width - 0.5) / atlasWidthPx"})}),"\n",(0,r.jsxs)(n.li,{children:["Same for ",(0,r.jsx)(n.code,{children:"v0/v1"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["For bitmap fonts, handle glyphs with ",(0,r.jsx)(n.code,{children:"width <= 1"})," or ",(0,r.jsx)(n.code,{children:"height <= 1"})," by collapsing the UV range to the glyph center (glyphs with ",(0,r.jsx)(n.code,{children:"widthPx <= 0 || heightPx <= 0"})," are already skipped during instance emission, but UV generation should remain well-defined)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optional padding extrusion"})," (recommended when ",(0,r.jsx)(n.code,{children:"paddingPx >= 2"}),"):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["During ",(0,r.jsx)(n.code,{children:"#createAtlasTextureAndUpload"}),", after copying the full source image, additionally copy 1-pixel strips from the source edges into the adjacent padding pixels (where in-bounds)."]}),"\n",(0,r.jsxs)(n.li,{children:["Gate extrusion behind ",(0,r.jsx)(n.code,{children:"packed.paddingPx >= 2"})," to avoid overwriting adjacent entries when packing is dense."]}),"\n",(0,r.jsx)(n.li,{children:"Keep UV rects referencing the original image region (not the extruded pixels); extrusion is purely a safety buffer for edge sampling drift."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data & Schemas"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["No schema changes. ",(0,r.jsx)(n.code,{children:"WebGpuAtlasLayout.schemaVersion"})," remains ",(0,r.jsx)(n.code,{children:"1"}),"; ",(0,r.jsx)(n.code,{children:"paddingPx"})," continues to describe packing gaps."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"atlasLayoutHash"})," remains derived solely from the atlas layout (not UV policies)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"APIs & Contracts"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["No required API changes. If future hosts need to toggle extrusion, add an optional ",(0,r.jsx)(n.code,{children:"WebGpuRendererLoadAssetsOptions.extrudePx?: 0 | 1"})," (TBD; see Open Questions)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tooling & Automation"}),": N/A."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deployment"}),": Patch-level renderer change."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Telemetry & Observability"}),": N/A (no new logging; keep test output clean for ",(0,r.jsx)(n.code,{children:"vitest-llm-reporter"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security & Compliance"}),": N/A."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,r.jsx)(n.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Issue Title"}),(0,r.jsx)(n.th,{children:"Scope Summary"}),(0,r.jsx)(n.th,{children:"Proposed Assignee/Agent"}),(0,r.jsx)(n.th,{children:"Dependencies"}),(0,r.jsx)(n.th,{children:"Acceptance Criteria"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bug(renderer-webgpu): half-texel inset atlas UVs"})}),(0,r.jsx)(n.td,{children:"Update sprite + glyph UV rect generation to use texel centers"}),(0,r.jsx)(n.td,{children:"Renderer Implementation Agent"}),(0,r.jsx)(n.td,{children:"Design approval"}),(0,r.jsx)(n.td,{children:"No visible atlas bleeding; unit tests assert inset UV values"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"test(renderer-webgpu): regression tests for UV rects"})}),(0,r.jsx)(n.td,{children:"Add deterministic unit coverage for sprite + font UV rects (via instance buffer inspection)"}),(0,r.jsx)(n.td,{children:"Test Agent"}),(0,r.jsx)(n.td,{children:"UV implementation"}),(0,r.jsx)(n.td,{children:"Tests fail on edge-based UVs and pass on inset UVs"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bug(renderer-webgpu): (optional) extrude atlas entry padding"})}),(0,r.jsxs)(n.td,{children:["Populate packing padding by extruding entry edge pixels when ",(0,r.jsx)(n.code,{children:"paddingPx >= 2"})]}),(0,r.jsx)(n.td,{children:"Renderer Implementation Agent"}),(0,r.jsx)(n.td,{children:"UV implementation"}),(0,r.jsx)(n.td,{children:"Manual scaling shows reduced fringes; tests cover copy patterns where feasible"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase 1"}),": Implement half-texel inset UVs + deterministic tests."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase 2"}),": Add padding extrusion (if needed after Phase 1 validation) + targeted tests."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hand-off Package"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Issue 812: ",(0,r.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/812",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/812"})]}),"\n",(0,r.jsxs)(n.li,{children:["UV generation sites: ",(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})]}),"\n",(0,r.jsxs)(n.li,{children:["Atlas packing: ",(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/atlas-packer.ts"})]}),"\n",(0,r.jsxs)(n.li,{children:["WebGPU stub harness + tests: ",(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Communication Cadence"}),": Single reviewer pass once tests cover the new UV policy."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Context Packets"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Read Issue 812 body and inspect the UV generation codepaths for both sprites and bitmap fonts."}),"\n",(0,r.jsxs)(n.li,{children:["Verify how instance data is encoded (",(0,r.jsx)(n.code,{children:"QuadInstanceWriter"}),") so tests can assert UV payloads deterministically."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prompting & Constraints"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Do not edit checked-in ",(0,r.jsx)(n.code,{children:"dist/**"})," outputs by hand."]}),"\n",(0,r.jsx)(n.li,{children:"Avoid console output in tests (Vitest LLM reporter requires clean output)."}),"\n",(0,r.jsx)(n.li,{children:"Prefer pure functions for UV math; share helper logic between sprite and font paths."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety Rails"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Ensure UVs remain finite and within ",(0,r.jsx)(n.code,{children:"(0, 1)"})," for valid atlas rectangles."]}),"\n",(0,r.jsxs)(n.li,{children:["For optional extrusion: only write into padding when it cannot overlap adjacent entries (gate on ",(0,r.jsx)(n.code,{children:"paddingPx >= 2"})," and bounds checks)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation Hooks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"pnpm test --filter @idle-engine/renderer-webgpu"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pnpm lint --filter @idle-engine/renderer-webgpu"})," (or ",(0,r.jsx)(n.code,{children:"pnpm lint"}),")"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Increase ",(0,r.jsx)(n.code,{children:"paddingPx"})," only"]}),": Rejected; does not fix edge-based UV interpolation drift and can still produce sampling artifacts."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clamp UVs in shader"}),": Requires per-instance clamp bounds and still doesn\u2019t fully address precision drift; adds shader complexity."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use separate textures per sprite / texture arrays"}),": Higher complexity and API surface; undermines the current deterministic atlas design."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rely on host-side transforms to align pixels"}),": Not feasible; engine must render correctly under arbitrary transforms/scales."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unit / Integration"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Add tests that render a single sprite and assert the uploaded instance buffer contains inset UVs for a known atlas size."}),"\n",(0,r.jsxs)(n.li,{children:["Add tests that render bitmap text and assert glyph UVs are inset for both a glyph at ",(0,r.jsx)(n.code,{children:"(0,0)"})," and a glyph at a non-zero atlas offset."]}),"\n",(0,r.jsxs)(n.li,{children:["If extrusion is implemented: add tests that assert the WebGPU queue receives additional ",(0,r.jsx)(n.code,{children:"copyExternalImageToTexture"})," calls only when ",(0,r.jsx)(n.code,{children:"paddingPx >= 2"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": N/A (small per-asset-load cost if extrusion is enabled; no per-frame cost)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tooling / A11y"}),": Manual validation in a WebGPU host (Electron shell) by scaling sprites/text and confirming no visible fringes."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Off-by-one UV bugs causing cropping"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Mitigation: unit tests for expected UVs with known atlas dimensions; validate both sprites and glyphs."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Font glyph edge cases (zero-sized glyphs)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Mitigation: keep UV generation well-defined for ",(0,r.jsx)(n.code,{children:"width/height <= 1"})," and rely on existing instance emission guards."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optional extrusion overwriting neighboring entries"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Mitigation: gate on ",(0,r.jsx)(n.code,{children:"paddingPx >= 2"})," and perform bounds checks; skip extrusion when unsafe."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Milestones"}),": Land as a patch-level fix to ",(0,r.jsx)(n.code,{children:"@idle-engine/renderer-webgpu"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Migration Strategy"}),": None."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Communication"}),": Note in release notes / issue comment that atlas UVs now use half-texel inset to prevent bleeding."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"13-open-questions",children:"13. Open Questions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Should padding extrusion ship as part of Issue 812, or only if half-texel inset alone is insufficient in real hosts?"}),"\n",(0,r.jsxs)(n.li,{children:["If extrusion is shipped, should it be a fixed internal policy (derived from ",(0,r.jsx)(n.code,{children:"paddingPx"}),") or exposed as an option on ",(0,r.jsx)(n.code,{children:"loadAssets(...)"}),"?"]}),"\n",(0,r.jsxs)(n.li,{children:["Do we want to expose the UV policy (inset/extrude) in ",(0,r.jsx)(n.code,{children:"WebGpuAtlasLayout"})," for debugging/inspection, even if it doesn\u2019t affect packing?"]}),"\n",(0,r.jsxs)(n.li,{children:["Is there a preferred manual repro scenario (specific sprites/fonts in ",(0,r.jsx)(n.code,{children:"packages/content-sample"}),") to validate before/after visually?"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Add a golden-image or GPU-readback based regression harness once a stable rendering test environment exists."}),"\n",(0,r.jsx)(n.li,{children:"Consider adding mipmaps + linear filtering support, which would likely require multi-pixel extrusion and/or per-mip border handling."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"15-references",children:"15. References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Issue 812: ",(0,r.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/812",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/812"})]}),"\n",(0,r.jsxs)(n.li,{children:["Renderer UV generation + atlas upload: ",(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})]}),"\n",(0,r.jsxs)(n.li,{children:["Atlas packing layout: ",(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/atlas-packer.ts"})]}),"\n",(0,r.jsxs)(n.li,{children:["Sprite UV type + batching: ",(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/sprite-batching.ts"})]}),"\n",(0,r.jsxs)(n.li,{children:["Renderer unit tests + WebGPU stubs: ",(0,r.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Atlas"}),": A single texture that contains multiple sprites/fonts packed into one image."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"UV"}),": Normalized texture coordinates in ",(0,r.jsx)(n.code,{children:"[0, 1]"})," used for sampling."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Texel"}),": A single pixel in a texture."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Half-texel inset"}),": Computing UVs using texel centers (",(0,r.jsx)(n.code,{children:"+0.5"})," and ",(0,r.jsx)(n.code,{children:"-0.5"})," pixel offsets) instead of texel edges."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Padding extrusion"}),": Copying edge texels into the surrounding atlas padding so out-of-bounds sampling still hits a similar color."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Date"}),(0,r.jsx)(n.th,{children:"Author"}),(0,r.jsx)(n.th,{children:"Change Summary"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2026-01-24"}),(0,r.jsx)(n.td,{children:"Codex (AI)"}),(0,r.jsx)(n.td,{children:"Initial draft"})]})})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},7678:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>d});var i=s(9430);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);