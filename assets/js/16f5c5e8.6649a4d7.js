"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[3986],{7564:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"runtime-transform-system-design-issue-523","title":"Runtime Transform System \u2014 Core Support for Content Transforms (issue-523)","description":"Document Control","source":"@site/../../docs/runtime-transform-system-design-issue-523.md","sourceDirName":".","slug":"/runtime-transform-system-design-issue-523","permalink":"/Idle-Game-Engine/runtime-transform-system-design-issue-523","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/runtime-transform-system-design-issue-523.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Runtime Transform System \u2014 Core Support for Content Transforms (issue-523)","sidebar_position":4}}');var r=s(5270),t=s(7678);const o={title:"Runtime Transform System \u2014 Core Support for Content Transforms (issue-523)",sidebar_position:4},c=void 0,d={},l=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Resolved Design Decisions",id:"13-resolved-design-decisions",level:2},{value:"13.1 Continuous Mode Semantics \u2713",id:"131-continuous-mode-semantics-",level:3},{value:"13.2 Event Trigger Multiplicity \u2713",id:"132-event-trigger-multiplicity-",level:3},{value:"13.3 Automation Trigger Support \u2713",id:"133-automation-trigger-support-",level:3},{value:"13.4 Safety Defaults and Caps \u2713",id:"134-safety-defaults-and-caps-",level:3},{value:"13.5 Command Authorization \u2713",id:"135-command-authorization-",level:3},{value:"13.6 Remaining Follow-Up Items",id:"136-remaining-follow-up-items",level:3},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"document-control",children:"Document Control"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Title"}),": Implement deterministic runtime support for content transforms (issue-523)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authors"}),": Idle Engine Design-Authoring Agent (AI)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reviewers"}),": Core Runtime Maintainers; Content Pipeline Maintainers; Shell-Web Maintainers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Status"}),": Draft"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Last Updated"}),": 2025-12-22"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Related Issues"}),": ",(0,r.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/523",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/523"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,r.jsxs)(n.p,{children:["GitHub issue #523 (\u201cfeat(core): implement runtime support for transforms\u201d) introduces deterministic runtime execution for content-authored ",(0,r.jsx)(n.code,{children:"transforms"}),", eliminating shell-specific implementations. The proposal adds a ",(0,r.jsx)(n.code,{children:"TransformSystem"})," to ",(0,r.jsx)(n.code,{children:"packages/core"})," that maintains transform runtime state (unlock/visibility, cooldown, and outstanding batches), executes atomic resource conversions according to ",(0,r.jsx)(n.code,{children:"mode"})," (",(0,r.jsx)(n.code,{children:"instant"}),", ",(0,r.jsx)(n.code,{children:"batch"}),", and later ",(0,r.jsx)(n.code,{children:"continuous"}),"), supports ",(0,r.jsx)(n.code,{children:"manual"})," transforms via a new runtime command, and supports at least one non-manual trigger path (",(0,r.jsx)(n.code,{children:"event"})," and/or ",(0,r.jsx)(n.code,{children:"condition"}),") by subscribing to the runtime event bus and evaluating ",(0,r.jsx)(n.code,{children:"ConditionContext"}),". The initiative includes save/load persistence and a snapshot view so shells can render transforms and drive manual execution, satisfying issue-523 acceptance criteria while preserving determinism, tick budget, and backward compatibility."]}),"\n",(0,r.jsx)(n.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Background"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Content schema already defines transforms (triggers, modes, formulas, safety guards) in ",(0,r.jsx)(n.code,{children:"packages/content-schema/src/modules/transforms.ts:42"})," and validates references in ",(0,r.jsx)(n.code,{children:"packages/content-schema/src/pack/validate-cross-references.ts"})," plus cycles in ",(0,r.jsx)(n.code,{children:"packages/content-schema/src/pack/validate-cycles.ts"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["The runtime tick loop executes commands, dispatches events, then ticks systems deterministically (",(0,r.jsx)(n.code,{children:"packages/core/src/index.ts:309"}),"), and already supports similar \u201cdefinition + system + persistence + snapshot\u201d patterns for automations (",(0,r.jsx)(n.code,{children:"packages/core/src/automation-system.ts:178"}),") and progression snapshots (",(0,r.jsx)(n.code,{children:"packages/core/src/progression.ts:232"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Shell-web\u2019s worker currently wires progression + automation only and emits ",(0,r.jsx)(n.code,{children:"STATE_UPDATE"})," without any transform state (",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:194"}),", ",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:317"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Problem"})," (issue-523):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Core has no ",(0,r.jsx)(n.code,{children:"TransformSystem"}),", no command type to manually run a transform (",(0,r.jsx)(n.code,{children:"packages/core/src/command.ts:107"}),"), no persistence for transform state (",(0,r.jsx)(n.code,{children:"packages/core/src/resource-state.ts:124"}),"), and no snapshot view for transforms (",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:317"}),")."]}),"\n",(0,r.jsx)(n.li,{children:"As a result, content packs cannot use transforms deterministically without bespoke shell code, undermining the \u201ccore runtime owns simulation\u201d constraint and blocking authored mechanics."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forces"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Determinism"}),": Transform execution must be replayable and stable across ticks and environments (align with command queue ordering in ",(0,r.jsx)(n.code,{children:"packages/core/src/index.ts:318"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Atomicity"}),": Multi-resource input spends must behave transactionally (all-or-nothing) using ",(0,r.jsx)(n.code,{children:"ResourceState.spendAmount"})," semantics (",(0,r.jsx)(n.code,{children:"packages/core/src/resource-state.ts:729"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety"}),": Runtime must enforce ",(0,r.jsx)(n.code,{children:"safety.maxRunsPerTick"})," and ",(0,r.jsx)(n.code,{children:"safety.maxOutstandingBatches"})," from schema (",(0,r.jsx)(n.code,{children:"packages/content-schema/src/modules/transforms.ts:149"}),") to prevent runaway loops."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compatibility"}),": Save schema additions must be backwards compatible and support step rebasing during restore (",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:835"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Trigger evaluation and formula evaluation must stay within the 100ms step budget for typical packs; avoid O(N*M) per tick when possible."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Goals"}),":","\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Deliver issue-523: add deterministic transform execution to ",(0,r.jsx)(n.code,{children:"@idle-engine/core"})," with a dedicated ",(0,r.jsx)(n.code,{children:"TransformSystem"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Support ",(0,r.jsx)(n.code,{children:"instant"})," + ",(0,r.jsx)(n.code,{children:"manual"})," transforms end-to-end via a new runtime command (spend inputs \u2192 produce outputs) and unit tests."]}),"\n",(0,r.jsxs)(n.li,{children:["Support at least one additional trigger path for issue-523 (",(0,r.jsx)(n.code,{children:"event"})," and/or ",(0,r.jsx)(n.code,{children:"condition"}),") using the existing runtime event bus (",(0,r.jsx)(n.code,{children:"packages/core/src/events/runtime-event-catalog.ts:61"}),") and ",(0,r.jsx)(n.code,{children:"ConditionContext"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/condition-evaluator.ts:39"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Enforce ",(0,r.jsx)(n.code,{children:"cooldown"})," and ",(0,r.jsx)(n.code,{children:"safety.maxRunsPerTick"})," deterministically; for batch transforms, enforce ",(0,r.jsx)(n.code,{children:"safety.maxOutstandingBatches"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Add save/load hooks for transform state and batch queues, including step rebasing on restore (patterned after ",(0,r.jsx)(n.code,{children:"AutomationSystem.restoreState"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Provide a snapshot view of transforms suitable for shell rendering and manual command issuance, and wire it into the worker ",(0,r.jsx)(n.code,{children:"STATE_UPDATE"})," envelope."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Non-Goals"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Delivering a complete shell-web UI for transforms (panels, layouts, animations) beyond exposing snapshot data and command wiring."}),"\n",(0,r.jsxs)(n.li,{children:["Implementing runtime execution for ",(0,r.jsx)(n.code,{children:"continuous"})," transforms beyond documenting semantics (requires follow-up work)."]}),"\n",(0,r.jsx)(n.li,{children:"Introducing generalized transactional resource operations beyond the transform system\u2019s atomic multi-spend logic."}),"\n",(0,r.jsx)(n.li,{children:"Expanding content DSL/schema (issue-523 assumes schema is authoritative and stable)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Primary Stakeholders"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Core Runtime Maintainers (deterministic runtime behavior, saves, commands)"}),"\n",(0,r.jsx)(n.li,{children:"Content Authors / Content Pipeline Maintainers (authoring transforms, validation, sample packs)"}),"\n",(0,r.jsx)(n.li,{children:"Shell-Web Maintainers (snapshot consumption, worker bridge contracts)"}),"\n",(0,r.jsx)(n.li,{children:"QA / Determinism Verification Owners (test stability, replay consistency)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Agent Roles"})," (AI-led execution for issue-523):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Runtime Implementation Agent: implement ",(0,r.jsx)(n.code,{children:"TransformSystem"}),", command handlers, and core unit tests in ",(0,r.jsx)(n.code,{children:"packages/core"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Persistence Agent: extend save schema and restore logic (resource-state export + worker snapshot/restore integration)."}),"\n",(0,r.jsx)(n.li,{children:"Event/Condition Trigger Agent: implement event subscriptions and condition evaluation trigger path."}),"\n",(0,r.jsx)(n.li,{children:"Snapshot/Contract Agent: define and wire transform snapshot view into worker messages and shell bridge typings."}),"\n",(0,r.jsx)(n.li,{children:"Content Authoring Agent: add minimal sample transform content and ensure compiler outputs are regenerated."}),"\n",(0,r.jsx)(n.li,{children:"Docs Agent: update authoring guidance to include runtime semantics and limitations for transforms."}),"\n",(0,r.jsxs)(n.li,{children:["CI/Validation Agent: run ",(0,r.jsx)(n.code,{children:"pnpm lint"}),", ",(0,r.jsx)(n.code,{children:"pnpm test"}),", and ",(0,r.jsx)(n.code,{children:"pnpm coverage:md"})," when coverage-affecting changes land; keep Vitest JSON summary intact."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Affected Packages/Services"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core"})," (new system, commands, persistence types, snapshot builder, tests)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/shell-web"})," (worker state envelope, session snapshot/restore integration)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/content-schema"})," (no schema changes expected; referenced for contracts)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/content-sample"})," (optional: add authored transforms to validate end-to-end usage)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"docs/"})," (this design + authoring semantics updates)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compatibility Considerations"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Additive command types and additive snapshot fields are backward compatible when gated by consumer capability checks."}),"\n",(0,r.jsxs)(n.li,{children:["Save format is extended additively (new optional ",(0,r.jsx)(n.code,{children:"transformState"})," field) to preserve compatibility with existing saves; restore must tolerate absence."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Transform definitions exist, but are inert at runtime:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Schema: ",(0,r.jsx)(n.code,{children:"packages/content-schema/src/modules/transforms.ts:97"})," defines ",(0,r.jsx)(n.code,{children:"mode"}),", ",(0,r.jsx)(n.code,{children:"trigger"}),", ",(0,r.jsx)(n.code,{children:"duration"}),", ",(0,r.jsx)(n.code,{children:"cooldown"}),", and ",(0,r.jsx)(n.code,{children:"safety"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Validation: pack cross-reference checks include transforms (",(0,r.jsx)(n.code,{children:"packages/content-schema/src/pack/validate-cross-references.ts"}),") and cycles (",(0,r.jsx)(n.code,{children:"packages/content-schema/src/pack/validate-cycles.ts"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Compiler: transforms are carried through into the normalized pack (",(0,r.jsx)(n.code,{children:"packages/content-compiler/src/runtime.ts:57"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Runtime execution infrastructure exists but does not include transforms:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Commands: no transform-related command identifiers exist (",(0,r.jsx)(n.code,{children:"packages/core/src/command.ts:107"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Systems: runtime ticks systems after dispatching command-produced events (",(0,r.jsx)(n.code,{children:"packages/core/src/index.ts:365"}),"), suitable for event-driven triggers."]}),"\n",(0,r.jsxs)(n.li,{children:["Conditions: shared ",(0,r.jsx)(n.code,{children:"ConditionContext"})," exists for unlock/visibility and trigger evaluation (",(0,r.jsx)(n.code,{children:"packages/core/src/condition-evaluator.ts:39"}),"), exposed by progression coordinator (",(0,r.jsx)(n.code,{children:"packages/core/src/progression-coordinator.ts:1226"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Persistence: resource save payload currently optionally embeds ",(0,r.jsx)(n.code,{children:"automationState"})," only (",(0,r.jsx)(n.code,{children:"packages/core/src/resource-state.ts:124"}),"); shell worker persists automation state but nothing for transforms (",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:939"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Shell-web state channel does not surface transforms:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Worker emits ",(0,r.jsx)(n.code,{children:"STATE_UPDATE"})," with progression snapshot only (",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:317"}),"), preventing shells from rendering transforms or issuing deterministic transform commands."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,r.jsx)(n.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Narrative"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Implement issue-523 by adding a deterministic ",(0,r.jsx)(n.code,{children:"TransformSystem"})," to ",(0,r.jsx)(n.code,{children:"packages/core"})," that owns transform runtime execution and state."]}),"\n",(0,r.jsxs)(n.li,{children:["Add a new runtime command (provisionally ",(0,r.jsx)(n.code,{children:"RUN_TRANSFORM"}),") for manual invocation. Command handlers call into ",(0,r.jsx)(n.code,{children:"TransformSystem"})," so command ordering remains authoritative relative to other commands in the same tick (",(0,r.jsx)(n.code,{children:"packages/core/src/index.ts:318"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Support at least one non-manual trigger path for issue-523:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event triggers"}),": ",(0,r.jsx)(n.code,{children:"TransformSystem.setup()"})," subscribes to relevant runtime events and records pending triggers, then executes transforms in ",(0,r.jsx)(n.code,{children:"tick()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Condition triggers"}),": ",(0,r.jsx)(n.code,{children:"TransformSystem.tick()"})," evaluates transform conditions via ",(0,r.jsx)(n.code,{children:"evaluateCondition"})," against the shared ",(0,r.jsx)(n.code,{children:"ConditionContext"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"TransformSystem"})," enforces safety guards deterministically per tick and persists its state (including batch queues) via additive save fields."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Diagram"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"TODO (Docs Agent): add a small diagram (Mermaid or SVG) showing command \u2192 dispatcher \u2192 transform system \u2192 resource state and event bus trigger flow."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Runtime Changes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Add ",(0,r.jsx)(n.code,{children:"packages/core/src/transform-system.ts"})," exporting:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"createTransformSystem(options)"})," returning a ",(0,r.jsx)(n.code,{children:"System"})," plus ",(0,r.jsx)(n.code,{children:"getState()"})," / ",(0,r.jsx)(n.code,{children:"restoreState()"})," and a ",(0,r.jsx)(n.code,{children:"runManualTransform()"})," method used by command handlers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"TransformState"})," (mutable internal) and ",(0,r.jsx)(n.code,{children:"SerializedTransformState"})," (JSON-safe, step-based scheduling fields)."]}),"\n",(0,r.jsxs)(n.li,{children:["Batch queue entries (e.g., ",(0,r.jsx)(n.code,{children:"TransformBatchState"}),") for ",(0,r.jsx)(n.code,{children:"mode === 'batch'"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Transform execution order and determinism:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Transform evaluation/execution order in ",(0,r.jsx)(n.code,{children:"tick()"})," is stable: sort by ",(0,r.jsx)(n.code,{children:"(order ?? 0, id)"})," using the transform definitions from the normalized pack (",(0,r.jsx)(n.code,{children:"packages/content-schema/src/modules/transforms.ts:69"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Pending event triggers are coalesced per transform per tick (boolean pending via ",(0,r.jsx)(n.code,{children:"Set<transformId>"}),"), matching the AutomationSystem pattern (see Section 13.2 for rationale)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Trigger semantics (issue-523):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"manual"}),": executed only via ",(0,r.jsx)(n.code,{children:"RUN_TRANSFORM"})," command handler; validates that ",(0,r.jsx)(n.code,{children:"trigger.kind === 'manual'"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"condition"}),": evaluated each tick; when true and transform is unlocked and not in cooldown, attempt one run (subject to safety)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"event"}),": when a subscribed event is received, mark transform as pending; ",(0,r.jsx)(n.code,{children:"tick()"})," attempts one run per pending transform per tick (subject to safety), preserving pending state when the run is blocked (locked/cooldown/insufficient inputs/safety)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"automation"}),": supported via ",(0,r.jsx)(n.code,{children:"automation:fired"})," events; when a referenced automation fires, mark the transform as pending and execute one run per pending transform per tick (subject to safety), retaining pending state when blocked."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Mode semantics (issue-523 \u201cschedule output application according to mode\u201d):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"instant"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Evaluate inputs/outputs formulas (see \u201cFormulas & Evaluation Context\u201d below)."}),"\n",(0,r.jsx)(n.li,{children:"Atomically spend all inputs; if any input is unaffordable, fail without applying cooldown."}),"\n",(0,r.jsx)(n.li,{children:"Apply outputs immediately (same command execution for manual; same tick for system-triggered runs)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"batch"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["On trigger, atomically spend inputs, then schedule outputs for delivery at ",(0,r.jsx)(n.code,{children:"completeAtStep = currentStep + ceil(durationMs / stepDurationMs)"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Enforce ",(0,r.jsx)(n.code,{children:"safety.maxOutstandingBatches"})," at scheduling time; reject/skip new batches when at cap."]}),"\n",(0,r.jsxs)(n.li,{children:["On ",(0,r.jsx)(n.code,{children:"tick()"}),", deliver outputs for due batches deterministically in FIFO order (ties broken by schedule time then id)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"continuous"})," (see Section 13.1 for rationale):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Amounts are ",(0,r.jsx)(n.strong,{children:"per-second rates"}),": ",(0,r.jsx)(n.code,{children:"amountThisTick = formula * deltaSeconds"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Each tick while trigger is active: evaluate input/output formulas as rates, multiply by ",(0,r.jsx)(n.code,{children:"deltaSeconds"}),", attempt spend/produce cycle."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"duration"})," is undefined: continuous transform remains active while trigger condition is true."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"duration"})," is specified: continuous transform remains active for ",(0,r.jsx)(n.code,{children:"durationMs"})," after trigger activation, even if trigger becomes false."]}),"\n",(0,r.jsx)(n.li,{children:"Fractional amounts accumulate across ticks using ProductionSystem-style accumulators to prevent integer truncation."}),"\n",(0,r.jsx)(n.li,{children:"Cooldown applies after each successful spend/produce cycle, not after duration expiration."}),"\n",(0,r.jsxs)(n.li,{children:["Subject to ",(0,r.jsx)(n.code,{children:"maxRunsPerTick"})," safety cap per tick."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Formulas & evaluation context:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Transform formulas (",(0,r.jsx)(n.code,{children:"inputs[].amount"}),", ",(0,r.jsx)(n.code,{children:"outputs[].amount"}),", ",(0,r.jsx)(n.code,{children:"duration"}),", ",(0,r.jsx)(n.code,{children:"cooldown"}),") use a ",(0,r.jsx)(n.code,{children:"FormulaEvaluationContext"})," consistent with existing runtime patterns:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Prefer reusing ",(0,r.jsx)(n.code,{children:"ProgressionCoordinator.createFormulaEvaluationContext"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/progression-coordinator.ts:1459"}),") or ",(0,r.jsx)(n.code,{children:"createAutomationFormulaEvaluationContext"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/automation-system.ts:46"}),") as the baseline (level=0, time/deltaTime from ",(0,r.jsx)(n.code,{children:"step"}),"/",(0,r.jsx)(n.code,{children:"stepDurationMs"}),", entities backed by ",(0,r.jsx)(n.code,{children:"ConditionContext"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Guardrails:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Non-finite evaluations (",(0,r.jsx)(n.code,{children:"NaN"}),", ",(0,r.jsx)(n.code,{children:"\xb1Infinity"}),") invalidate the run (no spend, no outputs, no cooldown), with deterministic telemetry/error codes."]}),"\n",(0,r.jsxs)(n.li,{children:["Negative evaluations are clamped to ",(0,r.jsx)(n.code,{children:"0"})," for costs/outputs/durations/cooldowns (consistent with automation resourceCost handling)."]}),"\n",(0,r.jsx)(n.li,{children:"Evaluate and normalize all input costs before spending; spend in a deterministic order to preserve atomicity and replay stability."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Unlock/visibility state:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"unlockCondition"})," (optional): evaluate via ",(0,r.jsx)(n.code,{children:"evaluateCondition"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/condition-evaluator.ts:122"}),") and apply ",(0,r.jsx)(n.strong,{children:"monotonically"})," (once unlocked, stay unlocked) to avoid regressions during replay and to match automation unlock persistence patterns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"visibilityCondition"})," (optional): evaluate per tick to compute ",(0,r.jsx)(n.code,{children:"visible"})," (default ",(0,r.jsx)(n.code,{children:"true"})," when undefined, consistent with progression coordinator visibility semantics at ",(0,r.jsx)(n.code,{children:"packages/core/src/progression-coordinator.ts:1455"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Execution gating: ",(0,r.jsx)(n.code,{children:"unlockCondition"})," gates execution; ",(0,r.jsx)(n.code,{children:"visibilityCondition"})," gates snapshot/UI only."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Safety enforcement (see Section 13.4 for rationale):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"maxRunsPerTick"}),": default ",(0,r.jsx)(n.code,{children:"10"}),", hard cap ",(0,r.jsx)(n.code,{children:"100"}),". When undefined, use ",(0,r.jsx)(n.code,{children:"DEFAULT_MAX_RUNS_PER_TICK = 10"}),". When authored value exceeds cap, clamp and record telemetry warning."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"maxOutstandingBatches"}),": default ",(0,r.jsx)(n.code,{children:"50"}),", hard cap ",(0,r.jsx)(n.code,{children:"1,000"}),". Enforced only for ",(0,r.jsx)(n.code,{children:"batch"})," mode; reject new batches when at cap."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Data & Schemas"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Add a new serialized transform state payload and embed it additively into the save payload:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Extend ",(0,r.jsx)(n.code,{children:"packages/core/src/resource-state.ts:124"})," with ",(0,r.jsx)(n.code,{children:"transformState?: readonly SerializedTransformState[]"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Keep ",(0,r.jsx)(n.code,{children:"PERSISTENCE_SCHEMA_VERSION"})," unchanged if the field is optional and restoration is backward compatible; bump only if a breaking change is introduced."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Serialized transform state (proposed):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"id: string"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"unlocked: boolean"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"cooldownExpiresStep: number"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pendingEvent?: boolean"})," (optional; not persisted if derived)"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"batches?: readonly { completeAtStep: number; outputs: readonly { resourceId: string; amount: number }[] }[]"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"continuous?: { enabled: boolean; activeUntilStep?: number }"})," (deferred until continuous semantics are confirmed)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Step rebasing on restore:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Mirror the automation restore strategy (",(0,r.jsx)(n.code,{children:"packages/core/src/automation-system.ts:242"}),"): adjust step-based fields by ",(0,r.jsx)(n.code,{children:"(currentStep - savedWorkerStep)"})," so cooldowns and batch completions preserve relative time across restores (",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:836"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"APIs & Contracts"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Add command type and payload (issue-523 manual trigger):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RUNTIME_COMMAND_TYPES.RUN_TRANSFORM = 'RUN_TRANSFORM'"})," in ",(0,r.jsx)(n.code,{children:"packages/core/src/command.ts:107"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RunTransformPayload = { transformId: string; runs?: number }"})," (runs default 1; capped by safety)."]}),"\n",(0,r.jsxs)(n.li,{children:["Authorization policy (see Section 13.5 for rationale): restrict to ",(0,r.jsx)(n.code,{children:"[PLAYER, SYSTEM]"})," priorities; block ",(0,r.jsx)(n.code,{children:"AUTOMATION"}),". Manual transforms are player-initiated; automatic transforms (event/condition triggers) bypass the command system."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Add ",(0,r.jsx)(n.code,{children:"registerTransformCommandHandlers({ dispatcher, transformSystem })"})," in ",(0,r.jsx)(n.code,{children:"packages/core"})," mirroring ",(0,r.jsx)(n.code,{children:"registerAutomationCommandHandlers"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/automation-command-handlers.ts:27"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Add a snapshot builder in ",(0,r.jsx)(n.code,{children:"packages/core"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"buildTransformSnapshot(step, publishedAt, { transforms, state, conditionContext, resourceState })"})," returning UI-ready transform views."]}),"\n",(0,r.jsxs)(n.li,{children:["Transform view fields (proposed minimal contract):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"id"}),", ",(0,r.jsx)(n.code,{children:"displayName"}),", ",(0,r.jsx)(n.code,{children:"description"}),", ",(0,r.jsx)(n.code,{children:"mode"}),", ",(0,r.jsx)(n.code,{children:"unlocked"}),", ",(0,r.jsx)(n.code,{children:"visible"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cooldownRemainingMs"}),", ",(0,r.jsx)(n.code,{children:"inputs"}),", ",(0,r.jsx)(n.code,{children:"outputs"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"outstandingBatches"})," and ",(0,r.jsx)(n.code,{children:"nextBatchReadyAtStep"})," (batch mode)"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Wire into shell-web worker state updates (issue-523 snapshot view):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Extend ",(0,r.jsx)(n.code,{children:"STATE_UPDATE.state"})," to include ",(0,r.jsx)(n.code,{children:"transforms"})," alongside ",(0,r.jsx)(n.code,{children:"progression"})," (",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:317"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Extend session snapshot capture/restore to include transform state:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Capture: include transform state in ",(0,r.jsx)(n.code,{children:"exportForSave"})," or as a sibling field (",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:939"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Restore: call ",(0,r.jsx)(n.code,{children:"transformSystem.restoreState(...)"})," if present (",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:835"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tooling & Automation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Unit tests:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Add colocated ",(0,r.jsx)(n.code,{children:"*.test.ts"})," under ",(0,r.jsx)(n.code,{children:"packages/core/src/"})," covering: manual instant success/failure, cooldown behavior, ",(0,r.jsx)(n.code,{children:"maxRunsPerTick"}),", and one additional trigger path (event or condition) per issue-523."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Determinism discipline:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Avoid console noise in tests to preserve ",(0,r.jsx)(n.code,{children:"vitest-llm-reporter"})," JSON summary output (repo guidelines in ",(0,r.jsx)(n.code,{children:"AGENTS.md"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Coverage:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If tests meaningfully change workspace coverage, regenerate ",(0,r.jsx)(n.code,{children:"docs/coverage/index.md"})," via ",(0,r.jsx)(n.code,{children:"pnpm coverage:md"})," (do not edit manually)."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deployment"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core"})," publishes additive APIs (system + command types). Shells must consume the new snapshot field and command(s) before transforms are usable end-to-end."]}),"\n",(0,r.jsx)(n.li,{children:"Roll out in phases with feature-gated UI exposure; core support can land first without enabling authored transforms in sample content."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Telemetry & Observability"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Add telemetry counters/errors for: invalid transform command payloads, unknown transform ids, insufficient resources, cooldown blocked, safety clamped, batch overflow."}),"\n",(0,r.jsxs)(n.li,{children:["Optionally publish runtime events for transform execution (e.g., ",(0,r.jsx)(n.code,{children:"transform:executed"}),") as a follow-up, ensuring event catalogue updates remain deterministic (",(0,r.jsx)(n.code,{children:"packages/core/src/events/runtime-event-manifest.generated.ts:52"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security & Compliance"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["No PII in transform state/snapshots. Persist only ids and numeric scheduling/amount data. Validate all command payloads defensively (pattern in ",(0,r.jsx)(n.code,{children:"packages/core/src/automation-command-handlers.ts:52"}),")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,r.jsx)(n.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,r.jsx)(n.p,{children:"Populate the table as the canonical source for downstream GitHub issues."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Issue Title"}),(0,r.jsx)(n.th,{children:"Scope Summary"}),(0,r.jsx)(n.th,{children:"Proposed Assignee/Agent"}),(0,r.jsx)(n.th,{children:"Dependencies"}),(0,r.jsx)(n.th,{children:"Acceptance Criteria"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"docs: author runtime transform system design (issue-523)"})}),(0,r.jsx)(n.td,{children:"Finalize this design doc and confirm open questions for issue-523 scope."}),(0,r.jsx)(n.td,{children:"Docs Agent"}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsx)(n.td,{children:"Doc approved; defaults/semantics agreed; issue map accepted."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feat(core): add TransformSystem scaffolding + state (issue-523)"})}),(0,r.jsxs)(n.td,{children:["Create ",(0,r.jsx)(n.code,{children:"TransformSystem"})," with unlock/visibility, cooldown fields, deterministic ordering, and APIs for execution."]}),(0,r.jsx)(n.td,{children:"Runtime Implementation Agent"}),(0,r.jsx)(n.td,{children:"Design approved"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"createTransformSystem"})," exists; state tracked; no regressions in core tests."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feat(core): add RUN_TRANSFORM command + handler (issue-523)"})}),(0,r.jsxs)(n.td,{children:["Add ",(0,r.jsx)(n.code,{children:"RUN_TRANSFORM"})," to command catalog, payload typing, authorization policy, and handler that executes ",(0,r.jsx)(n.code,{children:"instant"})," manual transforms atomically."]}),(0,r.jsx)(n.td,{children:"Runtime Implementation Agent"}),(0,r.jsx)(n.td,{children:"TransformSystem scaffold"}),(0,r.jsx)(n.td,{children:"Manual instant transform works end-to-end; invalid payloads fail with stable error codes; unit tests pass."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feat(core): implement trigger path (condition or event) (issue-523)"})}),(0,r.jsxs)(n.td,{children:["Implement at least one non-manual trigger path using ",(0,r.jsx)(n.code,{children:"ConditionContext"})," and/or event subscriptions."]}),(0,r.jsx)(n.td,{children:"Event/Condition Trigger Agent"}),(0,r.jsx)(n.td,{children:"TransformSystem scaffold"}),(0,r.jsx)(n.td,{children:"At least one trigger path works; unit tests cover trigger activation + cooldown interaction."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feat(core): implement batch scheduling + maxOutstandingBatches (issue-523)"})}),(0,r.jsx)(n.td,{children:"Add batch queue, duration scheduling, output delivery, and safety cap enforcement."}),(0,r.jsx)(n.td,{children:"Runtime Implementation Agent"}),(0,r.jsx)(n.td,{children:"TransformSystem scaffold"}),(0,r.jsx)(n.td,{children:"Batch transforms schedule and deliver outputs deterministically; cap enforced; unit tests cover queue + cap."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feat(core): persist transform state + restore rebasing (issue-523)"})}),(0,r.jsxs)(n.td,{children:["Extend ",(0,r.jsx)(n.code,{children:"SerializedResourceState"})," with ",(0,r.jsx)(n.code,{children:"transformState"}),", export/import helpers, and step rebasing on restore."]}),(0,r.jsx)(n.td,{children:"Persistence Agent"}),(0,r.jsx)(n.td,{children:"Transform state defined"}),(0,r.jsx)(n.td,{children:"Save includes transform state; restore rebases steps correctly; integration test covers round-trip."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feat(shell-web): surface transform snapshot + save/restore wiring (issue-523)"})}),(0,r.jsxs)(n.td,{children:["Extend worker ",(0,r.jsx)(n.code,{children:"STATE_UPDATE"})," to include transform snapshot and ensure session snapshot/restore includes transform state."]}),(0,r.jsx)(n.td,{children:"Snapshot/Contract Agent"}),(0,r.jsx)(n.td,{children:"Core snapshot API + persistence"}),(0,r.jsx)(n.td,{children:"Worker emits transforms snapshot; restore rehydrates state; existing worker tests updated and pass."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"feat(content-sample): add minimal transforms exercising runtime (issue-523)"})}),(0,r.jsx)(n.td,{children:"Add at least one transform to sample content to validate wiring; regenerate compiled artifacts."}),(0,r.jsx)(n.td,{children:"Content Authoring Agent"}),(0,r.jsx)(n.td,{children:"Core support landed"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"pnpm generate"})," clean; sample pack includes transform; optional integration smoke test passes."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"docs: update transform authoring guidance (issue-523)"})}),(0,r.jsx)(n.td,{children:"Document runtime semantics (manual/event/condition, cooldown, batch scheduling, safety defaults)."}),(0,r.jsx)(n.td,{children:"Docs Agent"}),(0,r.jsx)(n.td,{children:"Core semantics finalized"}),(0,r.jsx)(n.td,{children:"Docs updated; references to code paths and limitations included."})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase 1"}),": MVP for issue-523 acceptance criteria","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Deliver ",(0,r.jsx)(n.code,{children:"TransformSystem"})," + ",(0,r.jsx)(n.code,{children:"RUN_TRANSFORM"})," for ",(0,r.jsx)(n.code,{children:"instant"})," manual transforms, cooldown, ",(0,r.jsx)(n.code,{children:"maxRunsPerTick"}),", and one additional trigger path (event or condition), with unit tests."]}),"\n",(0,r.jsxs)(n.li,{children:["Gate: ",(0,r.jsx)(n.code,{children:"pnpm test --filter @idle-engine/core"})," green; deterministic behavior verified via repeated runs."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase 2"}),": Batch mode and persistence/snapshot completeness","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Deliver batch scheduling, ",(0,r.jsx)(n.code,{children:"maxOutstandingBatches"}),", save/load of transform state, and shell worker snapshot wiring."]}),"\n",(0,r.jsx)(n.li,{children:"Gate: session snapshot/restore integration test green; no regressions in worker bridge."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase 3"}),": Continuous mode support (automation triggers landed in #539)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Resolve semantics, implement continuous execution, and add determinism/performance tests."}),"\n",(0,r.jsx)(n.li,{children:"Gate: performance budget verified; additional tests for continuous determinism."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hand-off Package"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Issue scope: ",(0,r.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/523",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/523"})]}),"\n",(0,r.jsxs)(n.li,{children:["Contracts: ",(0,r.jsx)(n.code,{children:"packages/content-schema/src/modules/transforms.ts:97"}),", ",(0,r.jsx)(n.code,{children:"docs/content-dsl-schema-design.md:738"})]}),"\n",(0,r.jsxs)(n.li,{children:["Runtime patterns: ",(0,r.jsx)(n.code,{children:"packages/core/src/automation-system.ts:178"}),", ",(0,r.jsx)(n.code,{children:"packages/core/src/index.ts:309"}),", ",(0,r.jsx)(n.code,{children:"packages/core/src/resource-state.ts:124"})]}),"\n",(0,r.jsxs)(n.li,{children:["Shell worker wiring: ",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:194"}),", ",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:939"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Communication Cadence"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Daily status updates on issue-523 with: completed issues, failing tests, and next agent assignment."}),"\n",(0,r.jsx)(n.li,{children:"Review checkpoints at end of each phase; do not begin the next phase until reviewers sign off on the prior phase\u2019s acceptance criteria."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Context Packets"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Read: ",(0,r.jsx)(n.code,{children:"docs/content-dsl-schema-design.md:738"})," (transform schema intent), ",(0,r.jsx)(n.code,{children:"docs/content-dsl-usage-guidelines.md:288"})," (cycle/safety notes), and issue-523 body."]}),"\n",(0,r.jsxs)(n.li,{children:["Load code context: ",(0,r.jsx)(n.code,{children:"packages/content-schema/src/modules/transforms.ts"}),", ",(0,r.jsx)(n.code,{children:"packages/core/src/automation-system.ts"}),", ",(0,r.jsx)(n.code,{children:"packages/core/src/resource-state.ts"}),", ",(0,r.jsx)(n.code,{children:"packages/core/src/events/runtime-event-catalog.ts"}),", ",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prompting & Constraints"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Canonical implementation prompt (Runtime Implementation Agent):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u201cImplement issue-523 by adding ",(0,r.jsx)(n.code,{children:"TransformSystem"})," and ",(0,r.jsx)(n.code,{children:"RUN_TRANSFORM"})," support in ",(0,r.jsx)(n.code,{children:"packages/core"}),". Follow existing automation patterns for determinism, defensive validation, and persistence. Keep changes minimal, add colocated Vitest tests, and avoid console output.\u201d"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Canonical integration prompt (Shell Agent):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u201cExtend worker ",(0,r.jsx)(n.code,{children:"STATE_UPDATE"})," to include transform snapshot data and ensure session snapshot/restore persists transform state. Maintain backwards compatibility with older snapshots.\u201d"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Repo constraints:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use type-only imports/exports (",(0,r.jsx)(n.code,{children:"@typescript-eslint/consistent-type-imports/exports"})," is enforced)."]}),"\n",(0,r.jsxs)(n.li,{children:["Do not edit checked-in ",(0,r.jsx)(n.code,{children:"dist/"})," outputs by hand; regenerate via workspace scripts if required."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety Rails"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Do not reset git history, rewrite tags, or modify unrelated packages."}),"\n",(0,r.jsxs)(n.li,{children:["Avoid adding non-deterministic sources (Date.now in core logic); use runtime ",(0,r.jsx)(n.code,{children:"step"}),"/",(0,r.jsx)(n.code,{children:"timestamp"})," only when explicitly required."]}),"\n",(0,r.jsx)(n.li,{children:"Treat event-trigger backlogs defensively (coalesce by default) to avoid unbounded memory growth."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation Hooks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"pnpm lint"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"pnpm test --filter @idle-engine/core"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pnpm test --filter shell-web"})," (when worker contracts change)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"pnpm coverage:md"})," (only when coverage-affecting tests/code land; commit ",(0,r.jsx)(n.code,{children:"docs/coverage/index.md"}),")"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shell-only transforms"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Rejected: violates the deterministic-core architecture and fragments authored mechanics across shells; contradicts issue-523 goal."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Model transforms as generators (reuse ProductionSystem)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pros: continuous transforms become \u201crates\u201d naturally; can reuse accumulation and scaling."}),"\n",(0,r.jsxs)(n.li,{children:["Cons: awkward mapping for ",(0,r.jsx)(n.code,{children:"instant"})," and ",(0,r.jsx)(n.code,{children:"batch"})," semantics; introduces coupling and potentially leaks generator assumptions into transforms. Keep as a potential implementation strategy for ",(0,r.jsx)(n.code,{children:"continuous"})," only."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execute transforms exclusively via commands (no system)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pros: preserves command ordering and simplifies determinism."}),"\n",(0,r.jsx)(n.li,{children:"Cons: cannot naturally support event/condition triggers without synthesizing commands; batch delivery requires scheduled command emission anyway. A system remains the clearest owner for scheduled/batched work."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Evaluate batch outputs at completion instead of start"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pros: allows outputs to reflect late-bound state changes."}),"\n",(0,r.jsx)(n.li,{children:"Cons: makes player-facing previews harder and complicates deterministic save/restore (requires re-evaluating formulas at completion). Prefer evaluating and freezing outputs at scheduling time for issue-523."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unit / Integration"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/core/src/transform-system.test.ts"})," (new): manual instant run success/failure, cooldown behavior, ",(0,r.jsx)(n.code,{children:"maxRunsPerTick"}),", and one trigger path (",(0,r.jsx)(n.code,{children:"event"})," or ",(0,r.jsx)(n.code,{children:"condition"}),") per issue-523."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.test.ts"})," updates: assert ",(0,r.jsx)(n.code,{children:"STATE_UPDATE"})," includes transform snapshot when enabled; session snapshot/restore round-trips transform state."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Add a targeted benchmark or test harness in ",(0,r.jsx)(n.code,{children:"packages/core/benchmarks/"})," if transform evaluation becomes hot; validate no material regression versus baseline tick loop."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tooling / A11y"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["No UI changes required for issue-523 MVP; if shell UI is extended to display transforms, run ",(0,r.jsx)(n.code,{children:"pnpm test:a11y"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Issue-523 scope drift (modes/triggers)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Mitigation: gate implementation by Phase 1 acceptance criteria; split ",(0,r.jsx)(n.code,{children:"continuous"})," mode into an explicit follow-up issue if semantics are not confirmed."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ambiguous continuous semantics"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Mitigation: explicitly confirm continuous semantics before implementation (Open Questions); stage continuous as Phase 3 if needed."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event-trigger backlog growth"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Mitigation: coalesce event triggers per transform per tick; keep pending state on blocked runs; add hard cap if counts are later introduced."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Non-atomic multi-resource spends"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Mitigation: precompute and validate all input costs before spending; spend in a deterministic order (sorted by resource id/index) and fail fast without partial application."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Save/restore step drift"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Mitigation: rebase step-based fields using savedWorkerStep/currentStep (patterned after automation restore); add tests covering rebasing."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance regression with many transforms"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Mitigation: evaluate unlock/visibility lazily for non-visible transforms; avoid recomputing quotes for hidden transforms; keep formula evaluation bounded."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Milestones"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Phase 1: land core scaffolding + manual instant + one extra trigger path + tests."}),"\n",(0,r.jsx)(n.li,{children:"Phase 2: land batch + persistence + snapshot wiring to shell-web worker."}),"\n",(0,r.jsx)(n.li,{children:"Phase 3: land continuous mode support (automation triggers landed in #539)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Migration Strategy"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Additive save field ",(0,r.jsx)(n.code,{children:"transformState"})," only; restore tolerates absence; no migration required for existing saves."]}),"\n",(0,r.jsxs)(n.li,{children:["If later changes require non-additive updates, bump ",(0,r.jsx)(n.code,{children:"PERSISTENCE_SCHEMA_VERSION"})," and add migration transforms per ",(0,r.jsx)(n.code,{children:"docs/persistence-migration-guide.md"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Communication"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Update issue-523 with phase completion notes and commands run."}),"\n",(0,r.jsx)(n.li,{children:"Provide a short shell-web changelog entry when worker state envelope changes to ensure consumer alignment."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"13-resolved-design-decisions",children:"13. Resolved Design Decisions"}),"\n",(0,r.jsx)(n.p,{children:"The following questions were researched against existing codebase patterns, schema definitions, and idle game best practices. Each resolution includes rationale and references."}),"\n",(0,r.jsx)(n.h3,{id:"131-continuous-mode-semantics-",children:"13.1 Continuous Mode Semantics \u2713"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision"}),": For ",(0,r.jsx)(n.code,{children:"continuous"})," transforms, ",(0,r.jsx)(n.code,{children:"inputs/outputs[].amount"})," formulas evaluate to ",(0,r.jsx)(n.strong,{children:"per-second rates"})," (not per-tick amounts). The ",(0,r.jsx)(n.code,{children:"duration"})," field, when specified, defines an ",(0,r.jsx)(n.strong,{children:"active window"})," in milliseconds."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rationale"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ProductionSystem establishes per-second rates as the engine standard (",(0,r.jsx)(n.code,{children:"packages/core/src/production-system.ts:83-92"}),"): ",(0,r.jsx)(n.code,{children:"production = rate * owned * multiplier * deltaSeconds * consumptionRatio"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Formula evaluation context already provides ",(0,r.jsx)(n.code,{children:"deltaTime"})," (seconds per step) for rate-to-amount conversion (",(0,r.jsx)(n.code,{children:"packages/core/src/automation-system.ts:46-99"}),")."]}),"\n",(0,r.jsx)(n.li,{children:"Per-second rates enable consistent scaling across varying tick durations and support accumulator patterns for fractional amounts."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation semantics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Each tick while trigger is active: ",(0,r.jsx)(n.code,{children:"amountThisTick = formula * deltaSeconds"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"duration"})," is undefined: continuous transform remains active while trigger condition is true."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"duration"})," is specified: continuous transform remains active for ",(0,r.jsx)(n.code,{children:"durationMs"})," after trigger activation, even if trigger becomes false."]}),"\n",(0,r.jsx)(n.li,{children:"Cooldown applies after each successful run (spend + produce cycle), not after duration expiration."}),"\n",(0,r.jsx)(n.li,{children:"Fractional amounts should accumulate across ticks (reuse ProductionSystem accumulator pattern) to prevent integer truncation."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"132-event-trigger-multiplicity-",children:"13.2 Event Trigger Multiplicity \u2713"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision"}),": Multiple events of the same type firing in one tick are ",(0,r.jsx)(n.strong,{children:"coalesced"})," to a single trigger activation per transform (boolean pending state, not counted)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rationale"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The AutomationSystem establishes coalescing as the engine pattern (",(0,r.jsx)(n.code,{children:"packages/core/src/automation-system.ts:220, 307"}),"): pending triggers are tracked via ",(0,r.jsx)(n.code,{children:"Set<string>"})," (idempotent adds), not counted."]}),"\n",(0,r.jsx)(n.li,{children:"Coalescing prevents unbounded transform runs if many events fire in a burst."}),"\n",(0,r.jsx)(n.li,{children:"Pending state is retained across ticks when execution is blocked (cooldown, insufficient resources), preventing event loss without counting."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation semantics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"TransformSystem"})," maintains ",(0,r.jsx)(n.code,{children:"pendingEventTriggers: Set<transformId>"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Event subscription: ",(0,r.jsx)(n.code,{children:"events.on(eventId, () => pendingEventTriggers.add(transformId))"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tick()"})," attempts one run per pending transform per tick (subject to safety caps)."]}),"\n",(0,r.jsx)(n.li,{children:"On successful run: remove from pending set."}),"\n",(0,r.jsx)(n.li,{children:"On blocked run (cooldown, resources, safety): retain in pending set for next tick."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"133-automation-trigger-support-",children:"13.3 Automation Trigger Support \u2713"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision"}),": ",(0,r.jsx)(n.code,{children:"trigger.kind === 'automation'"})," is ",(0,r.jsx)(n.strong,{children:"supported"})," via the ",(0,r.jsx)(n.code,{children:"automation:fired"})," runtime event."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rationale"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"automation:fired"})," is published when an automation successfully executes, matching author expectations."]}),"\n",(0,r.jsx)(n.li,{children:"The event-driven path preserves determinism and reuses the existing coalescing model."}),"\n",(0,r.jsxs)(n.li,{children:["Content schema already requires an ",(0,r.jsx)(n.code,{children:"automation"})," reference that matches the trigger automation id."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation semantics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AutomationSystem"})," publishes ",(0,r.jsx)(n.code,{children:"automation:fired"})," with ",(0,r.jsx)(n.code,{children:"{ automationId, triggerKind, step }"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"TransformSystem.setup()"})," subscribes to ",(0,r.jsx)(n.code,{children:"automation:fired"})," and marks matching transforms as pending by ",(0,r.jsx)(n.code,{children:"automationId"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Execution follows the same pending/coalescing rules as ",(0,r.jsx)(n.code,{children:"event"})," triggers."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"134-safety-defaults-and-caps-",children:"13.4 Safety Defaults and Caps \u2713"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision"}),": Canonical defaults and hard caps are established as follows:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Hard Cap"}),(0,r.jsx)(n.th,{children:"Rationale"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"maxRunsPerTick"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"10"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"100"})}),(0,r.jsx)(n.td,{children:"Matches condition depth cap (100); prevents runaway loops while allowing controlled cascades."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"maxOutstandingBatches"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"50"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"1,000"})}),(0,r.jsx)(n.td,{children:"Proportional to command queue cap (10,000); prevents memory exhaustion from queued batches."})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rationale"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"MAX_CONDITION_DEPTH = 100"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/condition-evaluator.ts:34"}),") establishes 100 as a safe recursion/iteration bound."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"DEFAULT_MAX_QUEUE_SIZE = 10_000"})," (",(0,r.jsx)(n.code,{children:"packages/core/src/command-queue.ts:27"}),") establishes queue overflow semantics."]}),"\n",(0,r.jsx)(n.li,{children:"Most idle games process 5-20 actions per tick; 10 is conservative for defaults while 100 allows intentional high-throughput designs."}),"\n",(0,r.jsxs)(n.li,{children:["Each outstanding batch stores ",(0,r.jsx)(n.code,{children:"{ completeAtStep, outputs[] }"}),"; 1,000 batches \u2248 50-100KB (negligible memory)."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation semantics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["When ",(0,r.jsx)(n.code,{children:"safety.maxRunsPerTick"})," is undefined: use ",(0,r.jsx)(n.code,{children:"DEFAULT_MAX_RUNS_PER_TICK = 10"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["When authored value exceeds hard cap: clamp to ",(0,r.jsx)(n.code,{children:"HARD_CAP_MAX_RUNS_PER_TICK = 100"})," and record telemetry warning."]}),"\n",(0,r.jsxs)(n.li,{children:["Apply same pattern for ",(0,r.jsx)(n.code,{children:"maxOutstandingBatches"})," with defaults 50/1000."]}),"\n",(0,r.jsx)(n.li,{children:"Non-finite or non-positive authored values fall back to defaults."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"135-command-authorization-",children:"13.5 Command Authorization \u2713"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision"}),": ",(0,r.jsx)(n.code,{children:"RUN_TRANSFORM"})," is restricted to ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"[PLAYER, SYSTEM]"})})," priorities. ",(0,r.jsx)(n.code,{children:"AUTOMATION"})," priority is blocked."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rationale"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Manual transforms (via ",(0,r.jsx)(n.code,{children:"RUN_TRANSFORM"}),") are player-initiated or system-driven, matching the ",(0,r.jsx)(n.code,{children:"PRESTIGE_RESET"})," pattern (",(0,r.jsx)(n.code,{children:"packages/core/src/command.ts:275-281"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Automatic transforms (event/condition triggers) execute within ",(0,r.jsx)(n.code,{children:"TransformSystem.tick()"}),", bypassing the command system entirely\u2014no priority gating needed."]}),"\n",(0,r.jsxs)(n.li,{children:["Automation-triggered transforms use the event trigger path (not routed through ",(0,r.jsx)(n.code,{children:"RUN_TRANSFORM"}),"), keeping concerns separated."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation semantics"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"RUN_TRANSFORM: {\n  type: RUNTIME_COMMAND_TYPES.RUN_TRANSFORM,\n  allowedPriorities: Object.freeze([CommandPriority.SYSTEM, CommandPriority.PLAYER]),\n  rationale: 'Manual transforms are player-initiated or system-driven; automation trigger path is implemented separately.',\n  unauthorizedEvent: 'UnauthorizedTransformCommand',\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"136-remaining-follow-up-items",children:"13.6 Remaining Follow-Up Items"}),"\n",(0,r.jsx)(n.p,{children:"No unresolved questions remain for issue-523 MVP scope. The following items are tracked as explicit follow-up work:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Continuous mode accumulator pattern"}),": Confirm whether to reuse ProductionSystem's accumulator or implement transform-specific fractional handling."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transform execution events"}),": Consider publishing ",(0,r.jsx)(n.code,{children:"transform:executed"})," events for observability (requires event manifest update)."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Implement/confirm ",(0,r.jsx)(n.code,{children:"continuous"})," mode behavior and add dedicated tests/benchmarks (new issue if split)."]}),"\n",(0,r.jsx)(n.li,{children:"Add optional runtime events for transform execution and wire into event manifest tooling (requires manifest regeneration and schema updates)."}),"\n",(0,r.jsx)(n.li,{children:"Build shell-web UI surfaces for transforms (panel, affordance/disabled states, cooldown timers)."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"15-references",children:"15. References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["GitHub issue #523: ",(0,r.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/523",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/523"})]}),"\n",(0,r.jsxs)(n.li,{children:["Transform schema: ",(0,r.jsx)(n.code,{children:"packages/content-schema/src/modules/transforms.ts:97"})]}),"\n",(0,r.jsxs)(n.li,{children:["Transform validation + cycles: ",(0,r.jsx)(n.code,{children:"packages/content-schema/src/pack/validate-cycles.ts"})]}),"\n",(0,r.jsxs)(n.li,{children:["Runtime tick ordering: ",(0,r.jsx)(n.code,{children:"packages/core/src/index.ts:309"})]}),"\n",(0,r.jsxs)(n.li,{children:["Condition evaluation context: ",(0,r.jsx)(n.code,{children:"packages/core/src/condition-evaluator.ts:39"})]}),"\n",(0,r.jsxs)(n.li,{children:["Event catalogue / channels: ",(0,r.jsx)(n.code,{children:"packages/core/src/events/runtime-event-catalog.ts:61"})]}),"\n",(0,r.jsxs)(n.li,{children:["Worker runtime wiring + state update: ",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:194"})]}),"\n",(0,r.jsxs)(n.li,{children:["Worker snapshot capture: ",(0,r.jsx)(n.code,{children:"packages/shell-web/src/runtime.worker.ts:939"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transform (issue-523)"}),": A content-authored conversion that spends input resources and produces output resources under a trigger and mode (",(0,r.jsx)(n.code,{children:"packages/content-schema/src/modules/transforms.ts:97"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mode"}),": Execution style of a transform: ",(0,r.jsx)(n.code,{children:"instant"})," (immediate), ",(0,r.jsx)(n.code,{children:"batch"})," (delayed completion), ",(0,r.jsx)(n.code,{children:"continuous"})," (per-second rate semantics documented; runtime support pending)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trigger"}),": Activation mechanism for a transform: ",(0,r.jsx)(n.code,{children:"manual"}),", ",(0,r.jsx)(n.code,{children:"condition"}),", ",(0,r.jsx)(n.code,{children:"event"}),", ",(0,r.jsx)(n.code,{children:"automation"})," (",(0,r.jsx)(n.code,{children:"packages/content-schema/src/modules/transforms.ts:115"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cooldown"}),": Minimum time between successful transform starts; computed deterministically in steps from a ",(0,r.jsx)(n.code,{children:"NumericFormula"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Outstanding batch"}),": A queued batch transform instance waiting to deliver outputs at a scheduled future step."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Date"}),(0,r.jsx)(n.th,{children:"Author"}),(0,r.jsx)(n.th,{children:"Change Summary"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2025-12-16"}),(0,r.jsx)(n.td,{children:"Idle Engine Design-Authoring Agent (AI)"}),(0,r.jsx)(n.td,{children:"Initial draft for issue-523: TransformSystem, commands, triggers, persistence, snapshot plan."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2025-12-16"}),(0,r.jsx)(n.td,{children:"Claude Code (AI)"}),(0,r.jsx)(n.td,{children:"Resolved all 5 open questions with codebase research: continuous mode semantics (per-second rates), event coalescing (Set-based), automation triggers (deferred), safety caps (10/100, 50/1000), command auth (PLAYER+SYSTEM only). Updated Section 13 with rationale and implementation semantics."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2025-12-22"}),(0,r.jsx)(n.td,{children:"Codex (AI)"}),(0,r.jsx)(n.td,{children:"Updated automation-trigger support status after issue #539 landed."})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},7678:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var i=s(9430);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);