"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[6455],{1767:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"issue-846-design","title":"renderer-webgpu: improve texture usage flags (Issue 846)","description":"Document Control","source":"@site/../../docs/issue-846-design.md","sourceDirName":".","slug":"/issue-846-design","permalink":"/Idle-Game-Engine/issue-846-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/issue-846-design.md","tags":[],"version":"current","sidebarPosition":99,"frontMatter":{"title":"renderer-webgpu: improve texture usage flags (Issue 846)","sidebar_position":99}}');var i=s(5270),t=s(7678);const l={title:"renderer-webgpu: improve texture usage flags (Issue 846)",sidebar_position:99},d="renderer-webgpu: improve texture usage flags (Issue 846)",a={},c=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Open Questions",id:"13-open-questions",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"renderer-webgpu-improve-texture-usage-flags-issue-846",children:"renderer-webgpu: improve texture usage flags (Issue 846)"})}),"\n",(0,i.jsx)(n.h2,{id:"document-control",children:"Document Control"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Title"}),": Ensure WebGPU texture usage flags are cross-backend compatible for ",(0,i.jsx)(n.code,{children:"copyExternalImageToTexture"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authors"}),": Codex (AI)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reviewers"}),": @hansjm10"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Draft"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Last Updated"}),": 2026-01-26"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Related Issues"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/846",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/846"})," (triggered by runtime bitmap font generation in #841)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"@idle-engine/renderer-webgpu"})," uploads packed atlas images via ",(0,i.jsx)(n.code,{children:"GPUQueue.copyExternalImageToTexture(...)"}),". Chrome\u2019s WebGPU implementation (Dawn) may internally execute this copy via a render pass, which requires the destination texture to include ",(0,i.jsx)(n.code,{children:"RENDER_ATTACHMENT"})," usage in addition to ",(0,i.jsx)(n.code,{children:"COPY_DST"}),". Today the atlas texture is created with ",(0,i.jsx)(n.code,{children:"TEXTURE_BINDING | COPY_DST"}),", which can trigger repeated runtime errors and prevent asset loading. This design centralizes texture-usage requirements behind a small helper, documents cross-backend differences, and adds regression tests to keep atlas texture usage compatible across WebGPU backends."]}),"\n",(0,i.jsx)(n.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Background"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})," packs images/fonts into a single atlas (",(0,i.jsx)(n.code,{children:"packAtlas(...)"}),") and uploads each packed entry using ",(0,i.jsx)(n.code,{children:"device.queue.copyExternalImageToTexture(...)"})," in ",(0,i.jsx)(n.code,{children:"#createAtlasTextureAndUpload(...)"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The atlas texture is sampled in the sprite/text pipelines, so it also needs ",(0,i.jsx)(n.code,{children:"TEXTURE_BINDING"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The renderer\u2019s unit tests run in Node without WebGPU globals, so ",(0,i.jsx)(n.code,{children:"webgpu-renderer.ts"})," maintains small numeric fallbacks for usage enums (",(0,i.jsx)(n.code,{children:"GPU_TEXTURE_USAGE"}),", ",(0,i.jsx)(n.code,{children:"GPU_BUFFER_USAGE"}),", etc.)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["On Chrome/Dawn, ",(0,i.jsx)(n.code,{children:"copyExternalImageToTexture"})," may throw unless the destination texture has both ",(0,i.jsx)(n.code,{children:"COPY_DST"})," and ",(0,i.jsx)(n.code,{children:"RENDER_ATTACHMENT"})," usage:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"Destination texture needs to have CopyDst and RenderAttachment usage."})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["The current atlas texture descriptor uses ",(0,i.jsx)(n.code,{children:"TEXTURE_BINDING | COPY_DST"})," only, so the renderer can fail to load assets on Chromium-based hosts."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Forces"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keep the renderer contract stable (no schema changes)."}),"\n",(0,i.jsx)(n.li,{children:"Keep behavior deterministic and testable in a WebGPU-less environment."}),"\n",(0,i.jsx)(n.li,{children:"Prefer a robust, centralized policy over scattering backend-specific workarounds."}),"\n",(0,i.jsx)(n.li,{children:"Avoid premature runtime backend detection unless it materially reduces risk/cost."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goals"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Ensure textures used as the destination for ",(0,i.jsx)(n.code,{children:"copyExternalImageToTexture"})," are created with the required usage flags across backends (at minimum ",(0,i.jsx)(n.code,{children:"COPY_DST | RENDER_ATTACHMENT"}),")."]}),"\n",(0,i.jsx)(n.li,{children:"Centralize the policy so future external-copy destinations don\u2019t regress or copy/paste a partial usage mask."}),"\n",(0,i.jsx)(n.li,{children:"Add deterministic unit tests that assert atlas texture usage includes required flags."}),"\n",(0,i.jsx)(n.li,{children:"Document the known backend variance so future contributors understand why the flag set is a superset."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Non-Goals"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Perfectly minimizing texture usage flags per backend/driver."}),"\n",(0,i.jsx)(n.li,{children:"Adding runtime backend detection unless needed for correctness."}),"\n",(0,i.jsx)(n.li,{children:"Introducing new atlas formats, render-target textures, or a broad WebGPU abstraction layer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Primary Stakeholders"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Renderer maintainers (",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Host apps embedding WebGPU (",(0,i.jsx)(n.code,{children:"packages/shell-desktop"}),", future web shells)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Agent Roles"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Docs Agent"}),": Maintain this design doc, ensure references are current."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Renderer Implementation Agent"}),": Implement centralized texture usage helpers and migrate call sites."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test Agent"}),": Extend the existing WebGPU stubs and add regression tests for usage flags."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Affected Packages/Services"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})," (atlas texture creation)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})," (WebGPU stub + new tests)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/README.md"})," (documentation note; optional)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compatibility Considerations"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No renderer-contract changes."}),"\n",(0,i.jsx)(n.li,{children:"Texture usage becomes a conservative superset for atlas uploads; this should be accepted by all conforming implementations."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Atlas upload is implemented in ",(0,i.jsx)(n.code,{children:"WebGpuRenderer.#createAtlasTextureAndUpload(...)"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Creates a single atlas texture with ",(0,i.jsx)(n.code,{children:"usage: TEXTURE_BINDING | COPY_DST"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Calls ",(0,i.jsx)(n.code,{children:"device.queue.copyExternalImageToTexture(...)"})," for each atlas entry."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"webgpu-renderer.ts"})," defines a minimal ",(0,i.jsx)(n.code,{children:"GPU_TEXTURE_USAGE"})," fallback for non-WebGPU runtimes, but it currently does not include ",(0,i.jsx)(n.code,{children:"RENDER_ATTACHMENT"}),", making it easy for the renderer and tests to drift from real WebGPU requirements."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,i.jsx)(n.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Introduce a small \u201cusage policy\u201d helper for textures used as destinations of ",(0,i.jsx)(n.code,{children:"copyExternalImageToTexture"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Update atlas texture creation to use the helper and always include ",(0,i.jsx)(n.code,{children:"RENDER_ATTACHMENT"})," in addition to existing needs (",(0,i.jsx)(n.code,{children:"TEXTURE_BINDING | COPY_DST"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Extend ",(0,i.jsx)(n.code,{children:"GPU_TEXTURE_USAGE"})," fallback constants to include ",(0,i.jsx)(n.code,{children:"RENDER_ATTACHMENT"})," so Node-based unit tests can validate the bitmask deterministically."]}),"\n",(0,i.jsx)(n.li,{children:"Document the rationale (Chrome/Dawn behavior, links to spec discussions) near the helper and/or in package docs."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime Changes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Add a helper in ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/"})," (new module or colocated near atlas upload) with a narrow, explicit intent, for example:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"getCopyExternalImageToTextureDestinationUsage(baseUsage: number): number"})}),"\n",(0,i.jsxs)(n.li,{children:["or ",(0,i.jsx)(n.code,{children:"createCopyExternalImageDestinationTexture(device, descriptor): GPUTexture"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Update ",(0,i.jsx)(n.code,{children:"#createAtlasTextureAndUpload(...)"})," to use the helper so the atlas texture is always compatible with ",(0,i.jsx)(n.code,{children:"copyExternalImageToTexture"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Extend ",(0,i.jsx)(n.code,{children:"GPU_TEXTURE_USAGE"})," to include ",(0,i.jsx)(n.code,{children:"RENDER_ATTACHMENT"})," (from ",(0,i.jsx)(n.code,{children:"globalThis.GPUTextureUsage"})," when available, otherwise a numeric fallback)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data & Schemas"}),": No changes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"APIs & Contracts"}),": No public API changes; helper is internal to ",(0,i.jsx)(n.code,{children:"@idle-engine/renderer-webgpu"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tooling & Automation"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Add or extend unit tests that assert ",(0,i.jsx)(n.code,{children:"device.createTexture(...)"})," receives a descriptor with ",(0,i.jsx)(n.code,{children:"COPY_DST | RENDER_ATTACHMENT"})," when the texture is used as an external-copy destination."]}),"\n",(0,i.jsxs)(n.li,{children:["(Optional) Add a short note to ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/README.md"})," under ",(0,i.jsx)(n.strong,{children:"Environment"})," or a new ",(0,i.jsx)(n.strong,{children:"Implementation Notes"})," section explaining the flag choice."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deployment"}),": Ships as a patch-level renderer fix; no migration required."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Telemetry & Observability"}),": N/A (the error is thrown by the WebGPU implementation; fixing it removes console/device errors during ",(0,i.jsx)(n.code,{children:"loadAssets()"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security & Compliance"}),": No new security surface; no new data handling."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,i.jsx)(n.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Issue Title"}),(0,i.jsx)(n.th,{children:"Scope Summary"}),(0,i.jsx)(n.th,{children:"Proposed Assignee/Agent"}),(0,i.jsx)(n.th,{children:"Dependencies"}),(0,i.jsx)(n.th,{children:"Acceptance Criteria"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"feat(renderer-webgpu): centralize texture usage for external copies"})}),(0,i.jsxs)(n.td,{children:["Add a helper that applies required usage flags for ",(0,i.jsx)(n.code,{children:"copyExternalImageToTexture"})," destinations; update atlas texture creation and usage enum fallbacks accordingly."]}),(0,i.jsx)(n.td,{children:"Renderer Implementation Agent"}),(0,i.jsx)(n.td,{children:"Doc approval"}),(0,i.jsx)(n.td,{children:"Atlas texture is created with `COPY_DST"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"test(renderer-webgpu): assert atlas texture usage flags"})}),(0,i.jsxs)(n.td,{children:["Add regression tests verifying ",(0,i.jsx)(n.code,{children:"createTexture"})," is called with the expected usage mask when ",(0,i.jsx)(n.code,{children:"loadAssets()"})," uploads an atlas via ",(0,i.jsx)(n.code,{children:"copyExternalImageToTexture"}),"."]}),(0,i.jsx)(n.td,{children:"Test Agent"}),(0,i.jsx)(n.td,{children:"Implementation"}),(0,i.jsxs)(n.td,{children:["New tests fail if ",(0,i.jsx)(n.code,{children:"RENDER_ATTACHMENT"})," is omitted; tests run deterministically in Node with the existing WebGPU stubs."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"docs(renderer-webgpu): document copyExternalImageToTexture backend variance"})}),(0,i.jsxs)(n.td,{children:["Add a short rationale and reference links (GPUWeb issue, MDN/spec notes) explaining why ",(0,i.jsx)(n.code,{children:"RENDER_ATTACHMENT"})," is included for external-copy destination textures."]}),(0,i.jsx)(n.td,{children:"Docs Agent"}),(0,i.jsx)(n.td,{children:"Implementation"}),(0,i.jsx)(n.td,{children:"Documentation exists either as code comments near the helper or as a package doc entry; references are linked."})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 1"}),": Helper + atlas usage update + tests + documentation note (single PR)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 2"})," (optional): Extend the helper/policy if new texture upload paths are added (e.g., ",(0,i.jsx)(n.code,{children:"copyBufferToTexture"}),", ",(0,i.jsx)(n.code,{children:"writeTexture"}),", render targets) so each operation has an explicit, documented usage requirement."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hand-off Package"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Issue context + backend discussion links are in Issue 846."}),"\n",(0,i.jsxs)(n.li,{children:["Atlas upload path: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})," (",(0,i.jsx)(n.code,{children:"#createAtlasTextureAndUpload"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:["Test harness: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Communication Cadence"}),": One reviewer pass after tests and docs land; follow-up comment on Issue 846 with the shipped policy."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Context Packets"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Read Issue 846 and inspect ",(0,i.jsx)(n.code,{children:"#createAtlasTextureAndUpload(...)"})," call sites of ",(0,i.jsx)(n.code,{children:"copyExternalImageToTexture"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Validate how usage constants are defined for Node-based tests (fallback enum values)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prompting & Constraints"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Do not edit checked-in ",(0,i.jsx)(n.code,{children:"dist/**"})," outputs by hand."]}),"\n",(0,i.jsx)(n.li,{children:"Avoid console output in tests (Vitest LLM reporter expects clean output)."}),"\n",(0,i.jsx)(n.li,{children:"Prefer a small helper with a narrow name/contract over a generic \u201ckitchen sink\u201d WebGPU wrapper."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety Rails"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Limit ",(0,i.jsx)(n.code,{children:"RENDER_ATTACHMENT"})," usage widening to textures that are actually used as external-copy destinations (atlas today)."]}),"\n",(0,i.jsx)(n.li,{children:"Keep tests resilient by asserting only what is required for correctness."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation Hooks"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pnpm test --filter @idle-engine/renderer-webgpu"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pnpm lint --filter @idle-engine/renderer-webgpu"})," (or ",(0,i.jsx)(n.code,{children:"pnpm lint"}),")"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inline fix at atlas creation"})," (",(0,i.jsx)(n.code,{children:"usage |= RENDER_ATTACHMENT"}),"): Works, but encourages repeating backend knowledge at call sites and makes future regressions more likely."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime backend detection"})," (only add the flag on Dawn): Avoids superset usage, but adds complexity and likely requires non-portable adapter/UA checks."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Staging upload path"})," (copy via buffer instead of external image copy): Adds overhead and complexity; does not address the core \u201cusage requirements vary\u201d problem."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Wait for implementation changes"}),": Not acceptable; the renderer must be robust across the hosts we support today."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unit / Integration"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Extend ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})," so a ",(0,i.jsx)(n.code,{children:"loadAssets()"})," call asserts the atlas texture was created with ",(0,i.jsx)(n.code,{children:"COPY_DST | RENDER_ATTACHMENT"})," (and still includes ",(0,i.jsx)(n.code,{children:"TEXTURE_BINDING"})," for sampling)."]}),"\n",(0,i.jsx)(n.li,{children:"(Optional) Add a focused unit test for the helper itself if extracted into its own module."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": N/A (one-time texture creation flags)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tooling / A11y"}),": Manual validation in Chromium-based hosts (Electron shell): load assets that trigger runtime bitmap font generation and confirm no Dawn validation errors occur."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Superset usage flags change allocation/perf characteristics"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Mitigation: apply the superset only where needed (external-copy destinations), and keep the policy centralized for future tuning."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backend variance expands (additional required flags)"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Mitigation: document the rationale and keep the helper as the single place to encode requirements."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tests become brittle due to numeric flag values"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Mitigation: assert bit inclusion (mask contains required bits) rather than full equality where appropriate, and keep fallback constants aligned with spec values."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Milestones"}),": Land as a patch-level fix to ",(0,i.jsx)(n.code,{children:"@idle-engine/renderer-webgpu"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Migration Strategy"}),": None."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Communication"}),": Comment on Issue 846 noting that atlas textures created for ",(0,i.jsx)(n.code,{children:"copyExternalImageToTexture"})," now include ",(0,i.jsx)(n.code,{children:"RENDER_ATTACHMENT"})," for cross-backend compatibility."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"13-open-questions",children:"13. Open Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Should the helper live in a dedicated ",(0,i.jsx)(n.code,{children:"webgpu-texture-*.ts"})," module, or remain in ",(0,i.jsx)(n.code,{children:"webgpu-renderer.ts"})," until more call sites exist?"]}),"\n",(0,i.jsx)(n.li,{children:"Do we want to assert \u201cbit inclusion\u201d or \u201cexact mask equality\u201d in tests (to allow future additions without churn)?"}),"\n",(0,i.jsxs)(n.li,{children:["Should we document this as code comments only, or also add a short \u201cbackend variance\u201d note in ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/README.md"}),"?"]}),"\n",(0,i.jsx)(n.li,{children:"Is there a preferred manual repro path (Electron shell flow) to validate before/after on Chromium/Dawn?"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Extend the usage helper/policy as additional texture operations are introduced (render targets, depth textures, buffer-to-texture uploads)."}),"\n",(0,i.jsx)(n.li,{children:"Track Firefox WebGPU behavior when it becomes available and update docs/tests if requirements differ."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"15-references",children:"15. References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Issue 846: ",(0,i.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/846",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/846"})]}),"\n",(0,i.jsxs)(n.li,{children:["GPUWeb discussion: ",(0,i.jsx)(n.a,{href:"https://github.com/gpuweb/gpuweb/issues/3357",children:"https://github.com/gpuweb/gpuweb/issues/3357"})]}),"\n",(0,i.jsxs)(n.li,{children:["MDN: ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/GPUQueue/copyExternalImageToTexture",children:"https://developer.mozilla.org/en-US/docs/Web/API/GPUQueue/copyExternalImageToTexture"})]}),"\n",(0,i.jsxs)(n.li,{children:["Atlas upload path: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Renderer unit tests: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage flags"}),": Bitmask on ",(0,i.jsx)(n.code,{children:"GPUTextureDescriptor.usage"})," describing how a texture will be used (copy, sampling, render attachment, etc.)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dawn"}),": Chromium\u2019s WebGPU implementation layer (used by Chrome/Electron)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"copyExternalImageToTexture"})}),": WebGPU API for copying from an external image source (e.g., ",(0,i.jsx)(n.code,{children:"ImageBitmap"}),", ",(0,i.jsx)(n.code,{children:"HTMLImageElement"}),") into a GPU texture."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Date"}),(0,i.jsx)(n.th,{children:"Author"}),(0,i.jsx)(n.th,{children:"Change Summary"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2026-01-26"}),(0,i.jsx)(n.td,{children:"Codex (AI)"}),(0,i.jsx)(n.td,{children:"Initial draft"})]})})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},7678:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>d});var r=s(9430);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);