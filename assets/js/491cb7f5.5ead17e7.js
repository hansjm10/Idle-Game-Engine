"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[1956],{415:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"issue-811-design","title":"renderer-webgpu: Destroy GPU resources on dispose (Issue 811)","description":"Document Control","source":"@site/../../docs/issue-811-design.md","sourceDirName":".","slug":"/issue-811-design","permalink":"/Idle-Game-Engine/issue-811-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/issue-811-design.md","tags":[],"version":"current","sidebarPosition":99,"frontMatter":{"title":"renderer-webgpu: Destroy GPU resources on dispose (Issue 811)","sidebar_position":99}}');var i=n(5270),d=n(7678);const l={title:"renderer-webgpu: Destroy GPU resources on dispose (Issue 811)",sidebar_position:99},t="renderer-webgpu: Destroy GPU resources on dispose (Issue 811)",c={},o=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Open Questions",id:"13-open-questions",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function a(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"renderer-webgpu-destroy-gpu-resources-on-dispose-issue-811",children:"renderer-webgpu: Destroy GPU resources on dispose (Issue 811)"})}),"\n",(0,i.jsx)(s.h2,{id:"document-control",children:"Document Control"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Title"}),": Destroy owned WebGPU textures/buffers on renderer dispose"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Authors"}),": Codex (AI)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Reviewers"}),": @hansjm10"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Status"}),": Draft"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Last Updated"}),": 2026-01-21"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Related Issues"}),": ",(0,i.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/811",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/811"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"@idle-engine/renderer-webgpu"})," allocates GPU resources (sprite atlas texture and multiple GPU buffers) but does not currently destroy them. ",(0,i.jsx)(s.code,{children:"dispose()"})," only flips a flag, and the atlas texture created in ",(0,i.jsx)(s.code,{children:"loadAssets()"})," is not retained anywhere, making it impossible to free later. This design introduces explicit ownership tracking for GPU textures/buffers and adds deterministic cleanup: destroy owned resources in ",(0,i.jsx)(s.code,{children:"dispose()"}),", destroy the previous atlas when replacing it in ",(0,i.jsx)(s.code,{children:"loadAssets()"}),", and destroy the old instance buffer when the renderer grows it."]}),"\n",(0,i.jsx)(s.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Background"}),": ",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})," implements ",(0,i.jsx)(s.code,{children:"WebGpuRenderer"})," by creating a sprite pipeline (sampler, bind groups, vertex/index buffers, uniform buffer) and building an atlas texture during ",(0,i.jsx)(s.code,{children:"loadAssets(...)"}),". Rendering uploads per-frame instance data into a GPU instance buffer via ",(0,i.jsx)(s.code,{children:"device.queue.writeBuffer(...)"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Problem"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The atlas texture is created and uploaded in ",(0,i.jsx)(s.code,{children:"#createAtlasTextureAndUpload(...)"})," and is used to create a bind group, but the texture reference itself is not stored, so it cannot be destroyed later."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"#ensureInstanceBuffer(...)"})," may allocate a new ",(0,i.jsx)(s.code,{children:"GPUBuffer"})," when required capacity increases, but does not destroy the prior buffer when replacing it."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"dispose()"})," currently only sets ",(0,i.jsx)(s.code,{children:"#disposed = true"})," and does not call ",(0,i.jsx)(s.code,{children:".destroy()"})," on any textures/buffers."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Forces"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Some hosts may call ",(0,i.jsx)(s.code,{children:"loadAssets()"})," multiple times (content reload, recovery/recreate loops); leaks can accumulate GPU memory and cause instability on some drivers."]}),"\n",(0,i.jsxs)(s.li,{children:["Cleanup must be deterministic and not depend on GC timing; ",(0,i.jsx)(s.code,{children:".destroy()"})," should be invoked on resources the renderer owns."]}),"\n",(0,i.jsx)(s.li,{children:"The external renderer contract should not change; this should be a safe, internal behavior fix."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Goals"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Ensure ",(0,i.jsx)(s.code,{children:"dispose()"})," destroys owned ",(0,i.jsx)(s.code,{children:"GPUTexture"}),"/",(0,i.jsx)(s.code,{children:"GPUBuffer"})," resources and is safe to call multiple times."]}),"\n",(0,i.jsxs)(s.li,{children:["Ensure repeated ",(0,i.jsx)(s.code,{children:"loadAssets()"})," calls do not leak atlas textures (destroy the previous atlas before/when replacing it)."]}),"\n",(0,i.jsxs)(s.li,{children:["Ensure instance buffer growth (",(0,i.jsx)(s.code,{children:"#ensureInstanceBuffer"}),") does not leak prior buffers."]}),"\n",(0,i.jsxs)(s.li,{children:["Add/update unit tests to assert ",(0,i.jsx)(s.code,{children:".destroy()"})," is invoked on stubbed textures/buffers where applicable."]}),"\n",(0,i.jsx)(s.li,{children:"Avoid behavioral changes in rendered output and public APIs (except stronger cleanup semantics)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Non-Goals"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Adding new public APIs such as ",(0,i.jsx)(s.code,{children:"unloadAssets()"})," (could be follow-up work)."]}),"\n",(0,i.jsx)(s.li,{children:"Attempting to \u201cdestroy everything\u201d (e.g., pipelines/bind groups/samplers), since WebGPU does not expose explicit destruction for all object types."}),"\n",(0,i.jsx)(s.li,{children:"Implementing GPU memory telemetry or driver-specific leak detection beyond unit tests."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Primary Stakeholders"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Renderer maintainers (",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:["Host applications embedding WebGPU (",(0,i.jsx)(s.code,{children:"packages/shell-desktop"}),", future web shells) that may reload assets or recreate renderers."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Agent Roles"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Docs Agent"}),": Maintain this design doc and track open questions."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Renderer Implementation Agent"}),": Implement resource ownership tracking and cleanup logic."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Test Agent"}),": Extend the WebGPU stub harness and add regression tests for ",(0,i.jsx)(s.code,{children:".destroy()"})," calls."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Affected Packages/Services"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})," (resource creation, replacement, disposal)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})," (stub WebGPU environment + new tests)"]}),"\n",(0,i.jsxs)(s.li,{children:["(Optional) ",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/README.md"})," (document stronger dispose semantics)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Compatibility Considerations"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["No changes to ",(0,i.jsx)(s.code,{children:"WebGpuRenderer"})," interface shape are required; only stronger guarantees for ",(0,i.jsx)(s.code,{children:"dispose()"})," and repeated ",(0,i.jsx)(s.code,{children:"loadAssets()"}),"."]}),"\n",(0,i.jsx)(s.li,{children:"Ensure cleanup does not affect rendering correctness when the renderer is still in use (e.g., do not destroy the currently-bound atlas until the replacement is fully set)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,i.jsxs)(s.p,{children:["Today, ",(0,i.jsx)(s.code,{children:"WebGpuRendererImpl"})," owns several long-lived resources but does not treat them as owned for cleanup:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Pipeline setup (",(0,i.jsx)(s.code,{children:"#ensureSpritePipeline"}),") allocates:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"#spriteUniformBuffer"}),", ",(0,i.jsx)(s.code,{children:"#spriteVertexBuffer"}),", ",(0,i.jsx)(s.code,{children:"#spriteIndexBuffer"}),", ",(0,i.jsx)(s.code,{children:"#spriteSampler"}),", and bind groups."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Instance uploads allocate/grow an instance buffer in ",(0,i.jsx)(s.code,{children:"#ensureInstanceBuffer(requiredBytes)"}),".","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["When capacity is insufficient, a new ",(0,i.jsx)(s.code,{children:"GPUBuffer"})," is created and assigned to ",(0,i.jsx)(s.code,{children:"#spriteInstanceBuffer"}),", overwriting the prior reference without destroying it."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Atlas loading (",(0,i.jsx)(s.code,{children:"loadAssets"}),") creates an atlas texture and writes image data into it:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"const atlasTexture = this.#createAtlasTextureAndUpload(...)"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"this.#spriteTextureBindGroup = this.#createSpriteAtlasBindGroup(atlasTexture)"})}),"\n",(0,i.jsxs)(s.li,{children:["The ",(0,i.jsx)(s.code,{children:"atlasTexture"})," is not retained on the class after ",(0,i.jsx)(s.code,{children:"loadAssets"})," returns."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Disposal:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"dispose(): void { this.#disposed = true; }"})}),"\n",(0,i.jsxs)(s.li,{children:["No ",(0,i.jsx)(s.code,{children:".destroy()"})," calls are issued for textures/buffers."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The existing test harness stubs WebGPU objects but does not currently model ",(0,i.jsx)(s.code,{children:".destroy()"})," calls, so resource cleanup is untested."]}),"\n",(0,i.jsx)(s.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,i.jsx)(s.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,i.jsxs)(s.p,{children:["Introduce a simple \u201cowned resources\u201d model inside ",(0,i.jsx)(s.code,{children:"WebGpuRendererImpl"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Any ",(0,i.jsx)(s.code,{children:"GPUTexture"}),"/",(0,i.jsx)(s.code,{children:"GPUBuffer"})," created by this renderer instance is considered owned."]}),"\n",(0,i.jsxs)(s.li,{children:["Owned resources are:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"stored on the renderer instance so they can be explicitly destroyed later, and"}),"\n",(0,i.jsxs)(s.li,{children:["destroyed in two scenarios:","\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"On replace"})," (e.g., atlas texture and resizable instance buffer), and"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"On dispose"})," (final cleanup)."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This keeps cleanup local and explicit without adding a general-purpose resource manager."}),"\n",(0,i.jsx)(s.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Runtime Changes"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Track the atlas texture:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Add a private field (name TBD): ",(0,i.jsx)(s.code,{children:"#atlasTexture: GPUTexture | undefined"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["In ",(0,i.jsx)(s.code,{children:"loadAssets(...)"}),", before replacing the atlas:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["destroy any previous ",(0,i.jsx)(s.code,{children:"#atlasTexture"})," (best-effort) and clear it."]}),"\n",(0,i.jsxs)(s.li,{children:["create the new atlas, assign ",(0,i.jsx)(s.code,{children:"#atlasTexture = atlasTexture"}),", then rebuild ",(0,i.jsx)(s.code,{children:"#spriteTextureBindGroup"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Fix instance buffer growth:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["In ",(0,i.jsx)(s.code,{children:"#ensureInstanceBuffer(requiredBytes)"}),", when reallocating:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["hold ",(0,i.jsx)(s.code,{children:"const prior = this.#spriteInstanceBuffer"}),", create the new buffer, then call ",(0,i.jsx)(s.code,{children:"prior?.destroy()"})," after the new assignment is complete."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Keep ",(0,i.jsx)(s.code,{children:"#spriteInstanceBufferSize"})," in sync with the active buffer."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Destroy owned buffers/textures on dispose:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Update ",(0,i.jsx)(s.code,{children:"dispose()"})," to:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"be idempotent (if already disposed, return),"}),"\n",(0,i.jsxs)(s.li,{children:["call ",(0,i.jsx)(s.code,{children:".destroy()"})," on:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"#atlasTexture"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"#spriteUniformBuffer"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"#spriteVertexBuffer"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"#spriteIndexBuffer"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"#spriteInstanceBuffer"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["clear references (",(0,i.jsx)(s.code,{children:"undefined"}),") so subsequent code paths cannot accidentally use destroyed resources."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Continue to set ",(0,i.jsx)(s.code,{children:"#disposed = true"})," so ",(0,i.jsx)(s.code,{children:"render/resize"})," stay no-op and so device-lost handling remains suppressed after dispose."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Defensive error handling:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Prefer best-effort cleanup that does not throw from ",(0,i.jsx)(s.code,{children:"dispose()"})," (wrap per-resource ",(0,i.jsx)(s.code,{children:".destroy()"})," in ",(0,i.jsx)(s.code,{children:"try/catch"})," if needed to keep shutdown paths safe in both real WebGPU and test stubs)."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Data & Schemas"}),": N/A."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"APIs & Contracts"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["No changes to ",(0,i.jsx)(s.code,{children:"WebGpuRenderer"})," or renderer-contract types are required."]}),"\n",(0,i.jsxs)(s.li,{children:["Optional documentation update: clarify in ",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/README.md"})," that ",(0,i.jsx)(s.code,{children:"dispose()"})," destroys owned textures/buffers (not only \u201cstops future GPU work\u201d)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Tooling & Automation"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Extend the WebGPU stub environment in ",(0,i.jsx)(s.code,{children:"webgpu-renderer.test.ts"})," so:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"device.createBuffer()"})," returns objects that include a ",(0,i.jsx)(s.code,{children:"destroy"})," spy, and"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"device.createTexture()"})," returns objects that include a ",(0,i.jsx)(s.code,{children:"destroy"})," spy."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Add tests that:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["create a renderer, run ",(0,i.jsx)(s.code,{children:"loadAssets(...)"}),", call ",(0,i.jsx)(s.code,{children:"dispose()"}),", and assert the atlas texture and buffers\u2019 ",(0,i.jsx)(s.code,{children:"destroy"})," spies were called once."]}),"\n",(0,i.jsxs)(s.li,{children:["call ",(0,i.jsx)(s.code,{children:"loadAssets(...)"})," twice and assert the first atlas texture ",(0,i.jsx)(s.code,{children:"destroy()"})," is called when replaced."]}),"\n",(0,i.jsxs)(s.li,{children:["trigger instance buffer growth across renders (or by rendering enough instances) and assert the prior instance buffer ",(0,i.jsx)(s.code,{children:"destroy()"})," is called on resize."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Deployment"}),": Internal behavior change; no migration. Improvement is realized when hosts call ",(0,i.jsx)(s.code,{children:"dispose()"})," (e.g., on teardown or renderer replacement)."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Telemetry & Observability"}),": N/A. Avoid adding logging in hot paths or shutdown paths."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Security & Compliance"}),": N/A (no new data surfaces)."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,i.jsx)(s.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Issue Title"}),(0,i.jsx)(s.th,{children:"Scope Summary"}),(0,i.jsx)(s.th,{children:"Proposed Assignee/Agent"}),(0,i.jsx)(s.th,{children:"Dependencies"}),(0,i.jsx)(s.th,{children:"Acceptance Criteria"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"bug(renderer-webgpu): track and destroy atlas texture"})}),(0,i.jsxs)(s.td,{children:["Store atlas ",(0,i.jsx)(s.code,{children:"GPUTexture"})," and destroy prior atlas on replacement"]}),(0,i.jsx)(s.td,{children:"Renderer Implementation Agent"}),(0,i.jsx)(s.td,{children:"None"}),(0,i.jsxs)(s.td,{children:["Calling ",(0,i.jsx)(s.code,{children:"loadAssets()"})," multiple times does not leak atlas textures; tests assert ",(0,i.jsx)(s.code,{children:".destroy()"})," calls"]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"bug(renderer-webgpu): destroy buffers on dispose"})}),(0,i.jsxs)(s.td,{children:["Destroy owned buffers (",(0,i.jsx)(s.code,{children:"uniform"}),", ",(0,i.jsx)(s.code,{children:"vertex"}),", ",(0,i.jsx)(s.code,{children:"index"}),", ",(0,i.jsx)(s.code,{children:"instance"}),") in ",(0,i.jsx)(s.code,{children:"dispose()"})]}),(0,i.jsx)(s.td,{children:"Renderer Implementation Agent"}),(0,i.jsx)(s.td,{children:"None"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"dispose()"})," calls ",(0,i.jsx)(s.code,{children:".destroy()"})," once per owned buffer and is idempotent"]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"bug(renderer-webgpu): destroy resized instance buffer"})}),(0,i.jsxs)(s.td,{children:["Destroy prior ",(0,i.jsx)(s.code,{children:"#spriteInstanceBuffer"})," when growing it"]}),(0,i.jsx)(s.td,{children:"Renderer Implementation Agent"}),(0,i.jsx)(s.td,{children:"Buffer tracking"}),(0,i.jsxs)(s.td,{children:["Instance buffer growth does not leak old buffers; tests assert ",(0,i.jsx)(s.code,{children:".destroy()"})," calls"]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"test(renderer-webgpu): assert destroy calls via stubs"})}),(0,i.jsx)(s.td,{children:"Extend stubs and add regression tests for disposal/replacement"}),(0,i.jsx)(s.td,{children:"Test Agent"}),(0,i.jsx)(s.td,{children:"Implementation"}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"pnpm test --filter @idle-engine/renderer-webgpu"})," passes; new tests fail on regressions"]})]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Phase 1"}),": Implement atlas texture tracking + dispose buffer/texture destruction, update stubs, add unit coverage."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Phase 2"}),": Verify replacement paths (second ",(0,i.jsx)(s.code,{children:"loadAssets"}),", instance buffer growth) and add targeted regression tests."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Hand-off Package"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Issue 811: ",(0,i.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/811",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/811"})]}),"\n",(0,i.jsxs)(s.li,{children:["Primary file: ",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})]}),"\n",(0,i.jsxs)(s.li,{children:["Test harness: ",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Communication Cadence"}),": One reviewer pass once unit tests cover the new cleanup behavior."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Context Packets"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Issue 811 and the two code references in the issue body."}),"\n",(0,i.jsxs)(s.li,{children:["WebGPU resource creation sites in ",(0,i.jsx)(s.code,{children:"webgpu-renderer.ts"})," (",(0,i.jsx)(s.code,{children:"createTexture"}),", ",(0,i.jsx)(s.code,{children:"createBuffer"}),", ",(0,i.jsx)(s.code,{children:"#ensureInstanceBuffer"}),", ",(0,i.jsx)(s.code,{children:"dispose"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:["Stub WebGPU environment in ",(0,i.jsx)(s.code,{children:"webgpu-renderer.test.ts"})," (used to validate ",(0,i.jsx)(s.code,{children:".destroy()"})," calls)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Prompting & Constraints"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Do not edit generated ",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/dist/**"})," by hand."]}),"\n",(0,i.jsx)(s.li,{children:"Keep behavior deterministic and avoid console output in tests (Vitest LLM reporter expects clean output)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Safety Rails"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Only destroy resources created/owned by the renderer instance."}),"\n",(0,i.jsxs)(s.li,{children:["Do not attempt to destroy ",(0,i.jsx)(s.code,{children:"context.getCurrentTexture()"})," or any external image sources."]}),"\n",(0,i.jsxs)(s.li,{children:["Ensure ",(0,i.jsx)(s.code,{children:"dispose()"})," remains safe to call during teardown even if ",(0,i.jsx)(s.code,{children:"device.lost"})," has resolved."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Validation Hooks"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"pnpm test --filter @idle-engine/renderer-webgpu"})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"pnpm lint --filter @idle-engine/renderer-webgpu"})," (or workspace ",(0,i.jsx)(s.code,{children:"pnpm lint"})," if needed)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Do nothing / rely on GC"}),": Rejected; GPU resources can outlive JS references, and relying on GC timing risks long-lived GPU memory growth."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Create a new renderer instance instead of reloading assets"}),": Not always viable for hosts; still requires explicit cleanup of the prior instance to avoid leaking buffers/textures."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Central \u201cresource manager\u201d registry"}),": Overkill for the current surface area; explicit fields and targeted cleanup are simpler and easier to reason about."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"FinalizationRegistry-based cleanup"}),": Rejected; non-deterministic and unreliable for ensuring timely GPU resource reclamation."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Unit / Integration"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Extend ",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})," stubs so ",(0,i.jsx)(s.code,{children:"GPUBuffer"}),"/",(0,i.jsx)(s.code,{children:"GPUTexture"})," expose ",(0,i.jsx)(s.code,{children:".destroy()"})," spies."]}),"\n",(0,i.jsxs)(s.li,{children:["Add tests for:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:".dispose()"})," destroys the atlas texture and buffers."]}),"\n",(0,i.jsxs)(s.li,{children:["Repeated ",(0,i.jsx)(s.code,{children:"loadAssets()"})," destroys the previous atlas texture."]}),"\n",(0,i.jsx)(s.li,{children:"Instance buffer growth destroys the previous instance buffer."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Performance"}),": N/A (behavioral fix). Optional manual validation in a real WebGPU host: repeatedly call ",(0,i.jsx)(s.code,{children:"loadAssets()"})," and monitor GPU memory/driver stability."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Tooling / A11y"}),": N/A."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Destroying resources still in use by the GPU"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Mitigation: only destroy on ",(0,i.jsx)(s.code,{children:"dispose()"})," or when atomically swapping to a replacement atlas/buffer. WebGPU destruction is designed to be safe as long as the application does not continue using the destroyed resource."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Double-destroy / idempotency bugs"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Mitigation: clear references after destruction and guard ",(0,i.jsx)(s.code,{children:"dispose()"})," to run once."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Device lost behavior differences across implementations"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Mitigation: keep cleanup best-effort and non-throwing; maintain existing ",(0,i.jsx)(s.code,{children:"#lost"})," gating for render/resize."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Test harness drift from real WebGPU"}),":","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Mitigation: only stub ",(0,i.jsx)(s.code,{children:".destroy()"})," for textures/buffers; avoid inventing behavior for pipeline/bind group objects."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Milestones"}),": Land as a patch-level bug fix within ",(0,i.jsx)(s.code,{children:"@idle-engine/renderer-webgpu"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Migration Strategy"}),": None. Hosts should already call ",(0,i.jsx)(s.code,{children:"dispose()"})," on teardown; this change makes it effective for GPU memory."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Communication"}),": Note in release notes (or issue comment) that ",(0,i.jsx)(s.code,{children:"dispose()"})," now actively destroys GPU textures/buffers and that repeated ",(0,i.jsx)(s.code,{children:"loadAssets()"})," no longer leaks atlas textures."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"13-open-questions",children:"13. Open Questions"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["Should ",(0,i.jsx)(s.code,{children:"loadAssets()"})," destroy the previous atlas texture ",(0,i.jsx)(s.em,{children:"before"})," or ",(0,i.jsx)(s.em,{children:"after"})," creating the replacement (trade-off: minimal peak memory vs. avoiding a transient \u201cno atlas\u201d state if creation fails)?"]}),"\n",(0,i.jsxs)(s.li,{children:["Should ",(0,i.jsx)(s.code,{children:"dispose()"})," attempt to destroy resources even if the device has already been lost, or should it short-circuit when ",(0,i.jsx)(s.code,{children:"#lost"})," is true?"]}),"\n",(0,i.jsxs)(s.li,{children:["Do we want to document a stronger lifecycle recommendation for hosts (e.g., always call ",(0,i.jsx)(s.code,{children:"dispose()"})," before abandoning a renderer instance)?"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Consider adding a public ",(0,i.jsx)(s.code,{children:"unloadAssets()"})," method to free the atlas without disposing the entire renderer (if host workflows need it)."]}),"\n",(0,i.jsxs)(s.li,{children:["Consider tracking/destroying additional WebGPU resource types if added later (e.g., ",(0,i.jsx)(s.code,{children:"GPUQuerySet"}),"), using the same owned-resource approach."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"15-references",children:"15. References"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Issue 811: ",(0,i.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/811",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/811"})]}),"\n",(0,i.jsxs)(s.li,{children:["Renderer implementation: ",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})]}),"\n",(0,i.jsxs)(s.li,{children:["Renderer tests/stubs: ",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})]}),"\n",(0,i.jsxs)(s.li,{children:["Renderer package docs: ",(0,i.jsx)(s.code,{children:"packages/renderer-webgpu/README.md"})]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"WebGPU"}),": Modern GPU API for the web; exposes devices, queues, buffers, textures, and pipelines."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"GPUTexture"}),": WebGPU resource representing an image/texture allocation; supports ",(0,i.jsx)(s.code,{children:".destroy()"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"GPUBuffer"}),": WebGPU resource representing a linear memory allocation; supports ",(0,i.jsx)(s.code,{children:".destroy()"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Atlas"}),": A packed texture containing multiple sprites/fonts for efficient batching."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Date"}),(0,i.jsx)(s.th,{children:"Author"}),(0,i.jsx)(s.th,{children:"Change Summary"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"2026-01-21"}),(0,i.jsx)(s.td,{children:"Codex (AI)"}),(0,i.jsx)(s.td,{children:"Initial draft"})]})})]})]})}function h(e={}){const{wrapper:s}={...(0,d.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},7678:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>t});var r=n(9430);const i={},d=r.createContext(i);function l(e){const s=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(d.Provider,{value:s},e.children)}}}]);