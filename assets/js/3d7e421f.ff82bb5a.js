"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[1889],{5786:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"persistence-migration-guide","title":"Persistence Migration Guide","description":"Last Updated: 2025-11-02","source":"@site/../../docs/persistence-migration-guide.md","sourceDirName":".","slug":"/persistence-migration-guide","permalink":"/Idle-Game-Engine/persistence-migration-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/persistence-migration-guide.md","tags":[],"version":"current","frontMatter":{}}');var t=i(5270),r=i(7678);const o={},a="Persistence Migration Guide",d={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Migration System Architecture",id:"migration-system-architecture",level:2},{value:"Storage Schema",id:"storage-schema",level:3},{value:"Key Version Fields",id:"key-version-fields",level:3},{value:"Execution Flow",id:"execution-flow",level:3},{value:"Content Digest System",id:"content-digest-system",level:2},{value:"What is a ResourceDefinitionDigest?",id:"what-is-a-resourcedefinitiondigest",level:3},{value:"Validation Rules",id:"validation-rules",level:3},{value:"How Digest Changes Trigger Migrations",id:"how-digest-changes-trigger-migrations",level:3},{value:"Migration Authoring Workflow",id:"migration-authoring-workflow",level:2},{value:"Where to Place Migrations",id:"where-to-place-migrations",level:3},{value:"Versioning Expectations",id:"versioning-expectations",level:3},{value:"Testing Hooks",id:"testing-hooks",level:3},{value:"Writing Deterministic Migrations",id:"writing-deterministic-migrations",level:2},{value:"Principles for Safe Migrations",id:"principles-for-safe-migrations",level:3},{value:"Pattern: Resource Rename",id:"pattern-resource-rename",level:3},{value:"Pattern: Resource Merge",id:"pattern-resource-merge",level:3},{value:"Pattern: State Value Transformation",id:"pattern-state-value-transformation",level:3},{value:"Testing Determinism",id:"testing-determinism",level:3},{value:"Testing Migrations",id:"testing-migrations",level:2},{value:"Using Existing Test Infrastructure",id:"using-existing-test-infrastructure",level:3},{value:"1. Unit Tests for Migration Logic",id:"1-unit-tests-for-migration-logic",level:4},{value:"2. Integration Tests with SessionPersistenceAdapter",id:"2-integration-tests-with-sessionpersistenceadapter",level:4},{value:"3. Fixture-Based Testing",id:"3-fixture-based-testing",level:4},{value:"CLI Commands for Running Tests",id:"cli-commands-for-running-tests",level:3},{value:"Example Test Cases",id:"example-test-cases",level:3},{value:"When to Bump Schema Versions",id:"when-to-bump-schema-versions",level:2},{value:"PERSISTENCE_SCHEMA_VERSION",id:"persistence_schema_version",level:3},{value:"contentDigest",id:"contentdigest",level:3},{value:"runtimeVersion",id:"runtimeversion",level:3},{value:"Current Implementation Status &amp; Tooling Gaps",id:"current-implementation-status--tooling-gaps",level:2},{value:"What Works Today",id:"what-works-today",level:3},{value:"Known Limitations",id:"known-limitations",level:3},{value:"Follow-Up Tooling (Future Work)",id:"follow-up-tooling-future-work",level:3},{value:"References",id:"references",level:2},{value:"Design Documents",id:"design-documents",level:3},{value:"Implementation Files",id:"implementation-files",level:3},{value:"Test Files",id:"test-files",level:3},{value:"Related Issues",id:"related-issues",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"persistence-migration-guide",children:"Persistence Migration Guide"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Last Updated:"})," 2025-11-02\n",(0,t.jsx)(n.strong,{children:"Status:"})," \u2705 Migration execution fully implemented (Issue #155)"]}),"\n",(0,t.jsx)(n.p,{children:"This guide explains how to author migrations for persisted game state in the Idle Game Engine. It covers the migration system architecture, authoring workflow, testing practices, and current implementation status."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#migration-system-architecture",children:"Migration System Architecture"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#content-digest-system",children:"Content Digest System"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#migration-authoring-workflow",children:"Migration Authoring Workflow"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#writing-deterministic-migrations",children:"Writing Deterministic Migrations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#testing-migrations",children:"Testing Migrations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#when-to-bump-schema-versions",children:"When to Bump Schema Versions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#current-implementation-status--tooling-gaps",children:"Current Implementation Status & Tooling Gaps"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#references",children:"References"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The Idle Game Engine uses a ",(0,t.jsx)(n.strong,{children:"shell-managed persistence architecture"})," where the React shell handles all storage operations while the deterministic runtime worker remains isolated from I/O. This design ensures:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Determinism"}),": The worker never touches storage APIs directly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Testability"}),": Storage operations can be mocked independently"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Portability"}),": Different shells can implement different storage strategies"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Migrations are needed when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Content pack definitions change"})," (resources added, removed, or reordered)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistence schema format changes"})," (structure of ",(0,t.jsx)(n.code,{children:"StoredSessionSnapshot"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State transformation required"})," (data model evolution, fixes to corrupted saves)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Migrations run ",(0,t.jsx)(n.strong,{children:"before"})," calling ",(0,t.jsx)(n.code,{children:"bridge.restoreSession()"}),", allowing content packs to transform save data into a format compatible with current definitions."]}),"\n",(0,t.jsx)(n.h2,{id:"migration-system-architecture",children:"Migration System Architecture"}),"\n",(0,t.jsx)(n.h3,{id:"storage-schema",children:"Storage Schema"}),"\n",(0,t.jsxs)(n.p,{children:["Snapshots are stored in IndexedDB (",(0,t.jsx)(n.code,{children:"idle-engine.sessions"})," database) with the following structure:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface StoredSessionSnapshot {\n  readonly schemaVersion: number;          // Persistence schema version\n  readonly slotId: string;                 // Save slot identifier\n  readonly capturedAt: string;             // ISO timestamp\n  readonly workerStep: number;             // Runtime step counter\n  readonly monotonicMs: number;            // Monotonic clock reference\n  readonly state: SerializedResourceState; // Serialized game state\n  readonly runtimeVersion: string;         // @idle-engine/core version\n  readonly contentDigest: ResourceDefinitionDigest;  // Content pack hash\n  readonly flags?: {\n    readonly pendingMigration?: boolean;\n    readonly abortedRestore?: boolean;\n  };\n  readonly checksum?: string;              // SHA-256 for corruption detection\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-version-fields",children:"Key Version Fields"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Field"}),(0,t.jsx)(n.th,{children:"Purpose"}),(0,t.jsx)(n.th,{children:"Managed By"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PERSISTENCE_SCHEMA_VERSION"})}),(0,t.jsxs)(n.td,{children:["Format version of ",(0,t.jsx)(n.code,{children:"StoredSessionSnapshot"})]}),(0,t.jsx)(n.td,{children:"Engine maintainers"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"schemaVersion"})}),(0,t.jsx)(n.td,{children:"Instance value stored in each snapshot"}),(0,t.jsx)(n.td,{children:"Automatically set on save"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"runtimeVersion"})}),(0,t.jsxs)(n.td,{children:["Semantic version from ",(0,t.jsx)(n.code,{children:"@idle-engine/core"})]}),(0,t.jsx)(n.td,{children:"Automatically set from package.json"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"contentDigest"})}),(0,t.jsx)(n.td,{children:"Hash of resource IDs in content pack"}),(0,t.jsx)(n.td,{children:"Automatically computed on save/load"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"execution-flow",children:"Execution Flow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"1. SessionPersistenceAdapter.load(slotId)\n   \u2193\n2. Validate snapshot integrity (checksum, schema version)\n   \u2193\n3. reconcileSaveAgainstDefinitions(snapshot.state, liveDefinitions)\n   \u2193\n4. Check if migration required (digest mismatch, removed resources)\n   \u2193\n5. Apply content pack migrations (if registered)\n   \u2193\n6. bridge.restoreSession({ state, elapsedMs, resourceDeltas })\n"})}),"\n",(0,t.jsx)(n.h2,{id:"content-digest-system",children:"Content Digest System"}),"\n",(0,t.jsx)(n.h3,{id:"what-is-a-resourcedefinitiondigest",children:"What is a ResourceDefinitionDigest?"}),"\n",(0,t.jsx)(n.p,{children:"A content digest is a stable hash of all resource IDs in a content pack, used to detect when definitions have changed between save and load:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface ResourceDefinitionDigest {\n  readonly ids: readonly string[];  // Ordered resource IDs\n  readonly version: number;          // Count of resource IDs\n  readonly hash: string;            // FNV-1a hash of resource IDs\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The digest is computed using ",(0,t.jsx)(n.strong,{children:"FNV-1a hash"})," for determinism across environments (see ",(0,t.jsx)(n.code,{children:"createDefinitionDigest()"})," in ",(0,t.jsx)(n.code,{children:"packages/core/src/resource-state.ts"}),")."]}),"\n",(0,t.jsx)(n.h3,{id:"validation-rules",children:"Validation Rules"}),"\n",(0,t.jsx)(n.p,{children:"When loading a save, the engine compares the saved digest against the current content pack definitions:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{children:"Detection"}),(0,t.jsx)(n.th,{children:"Handling"}),(0,t.jsx)(n.th,{children:"Migration Needed?"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Resources added"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"addedIds.length > 0"})}),(0,t.jsx)(n.td,{children:"Gracefully handled (new resources initialize to defaults)"}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Resources removed"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"removedIds.length > 0"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"FAILS"})," validation"]}),(0,t.jsx)(n.td,{children:"Yes (must restore removed resources or migrate data)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Resources reordered"})}),(0,t.jsx)(n.td,{children:"Hash mismatch, same IDs"}),(0,t.jsx)(n.td,{children:"Warning logged, gracefully handled via remapping"}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Resources renamed"})}),(0,t.jsx)(n.td,{children:"Old ID removed, new ID added"}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"FAILS"})," validation"]}),(0,t.jsx)(n.td,{children:"Yes (migration must transform state)"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["Validation logic is implemented in ",(0,t.jsx)(n.code,{children:"reconcileSaveAgainstDefinitions()"})," in ",(0,t.jsx)(n.code,{children:"packages/core/src/resource-state.ts"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"how-digest-changes-trigger-migrations",children:"How Digest Changes Trigger Migrations"}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"reconcileSaveAgainstDefinitions()"})," detects incompatibility, it returns reconciliation results containing:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"addedIds"}),": Resources in current definitions but not in save"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"removedIds"}),": Resources in save but not in current definitions (triggers migration requirement)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"digestsMatch"}),": Whether the saved and current digests match"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The restore logic in ",(0,t.jsx)(n.code,{children:"session-restore.ts"})," uses these results to determine if migration is needed:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Migration is required when ",(0,t.jsx)(n.code,{children:"removedIds.length > 0"})," (resources were removed/renamed)"]}),"\n",(0,t.jsxs)(n.li,{children:["Migration can also be triggered by a pre-set ",(0,t.jsx)(n.code,{children:"snapshot.flags.pendingMigration"})," flag"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When migration is triggered:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Compare ",(0,t.jsx)(n.code,{children:"snapshot.contentDigest"})," against known content pack versions"]}),"\n",(0,t.jsx)(n.li,{children:"Find applicable migration transforms using the migration registry"}),"\n",(0,t.jsxs)(n.li,{children:["Apply transforms to ",(0,t.jsx)(n.code,{children:"snapshot.state"})," (amounts, capacities, flags arrays, etc.)"]}),"\n",(0,t.jsx)(n.li,{children:"Re-validate after transformation"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"migration-authoring-workflow",children:"Migration Authoring Workflow"}),"\n",(0,t.jsx)(n.h3,{id:"where-to-place-migrations",children:"Where to Place Migrations"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Current Status:"})," \u2705 Migration registration API is implemented and available."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," The ",(0,t.jsx)(n.code,{children:"registerMigration()"})," and ",(0,t.jsx)(n.code,{children:"findMigrationPath()"})," APIs are now available in ",(0,t.jsx)(n.code,{children:"@idle-engine/shell-web"}),". Content packs can register migrations at initialization time."]}),"\n",(0,t.jsx)(n.p,{children:"Content pack migrations should be registered at pack initialization:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Example: In your content pack's initialization code\nimport { registerMigration } from '@idle-engine/shell-web';\n\nregisterMigration({\n  // Unique identifier for this migration\n  id: 'my-pack-v2-resource-rename',\n\n  // Source content digest (before migration)\n  fromDigest: {\n    hash: 'fnv1a-abc123',\n    version: 2,\n    ids: ['old-resource-id', 'other-resource'],\n  },\n\n  // Target content digest (after migration)\n  toDigest: {\n    hash: 'fnv1a-def456',\n    version: 2,\n    ids: ['new-resource-id', 'other-resource'],\n  },\n\n  // Transform function\n  transform: (state: SerializedResourceState): SerializedResourceState => {\n    // Rename old-resource-id to new-resource-id in the state\n    return {\n      ...state,\n      ids: state.ids.map(id => id === 'old-resource-id' ? 'new-resource-id' : id),\n    };\n  },\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"versioning-expectations",children:"Versioning Expectations"}),"\n",(0,t.jsxs)(n.p,{children:["Migrations are ",(0,t.jsx)(n.strong,{children:"digest-driven"}),", not version-driven:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A migration transforms state from one content digest to another"}),"\n",(0,t.jsx)(n.li,{children:"Multiple migrations may form a chain (v1 \u2192 v2 \u2192 v3)"}),"\n",(0,t.jsx)(n.li,{children:"The shell will automatically compute the shortest migration path"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Do NOT"})," tie migrations to ",(0,t.jsx)(n.code,{children:"runtimeVersion"})," or ",(0,t.jsx)(n.code,{children:"schemaVersion"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"runtimeVersion"})," changes with engine updates (not content changes)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"schemaVersion"})," changes when ",(0,t.jsx)(n.code,{children:"StoredSessionSnapshot"})," format changes (handled separately by IndexedDB migrations)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"testing-hooks",children:"Testing Hooks"}),"\n",(0,t.jsxs)(n.p,{children:["Test migrations using the existing test infrastructure in ",(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Example: In your content pack's test suite\nimport { describe, it, expect } from 'vitest';\nimport { registerMigration, findMigrationPath, applyMigrations } from '@idle-engine/shell-web';\nimport type { ResourceDefinitionDigest, SerializedResourceState } from '@idle-engine/core';\n\ndescribe('resource rename migration', () => {\n  it('should transform old resource ID to new ID', () => {\n    const oldDigest: ResourceDefinitionDigest = {\n      hash: 'abc123...',\n      version: 2,\n      ids: ['old-resource-id', 'other-resource'],\n    };\n    const newDigest: ResourceDefinitionDigest = {\n      hash: 'def456...',\n      version: 2,\n      ids: ['new-resource-id', 'other-resource'],\n    };\n\n    registerMigration({\n      id: 'my-pack-v2-resource-rename',\n      fromDigest: oldDigest,\n      toDigest: newDigest,\n      transform: (state) => ({\n        ...state,\n        ids: state.ids.map((id) => (id === 'old-resource-id' ? 'new-resource-id' : id)),\n      }),\n    });\n\n    const oldState: SerializedResourceState = {\n      ids: ['old-resource-id', 'other-resource'],\n      amounts: [100, 200],\n      capacities: [1000, 2000],\n      flags: [0, 0],\n    };\n\n    const path = findMigrationPath(oldDigest, newDigest);\n    expect(path.found).toBe(true);\n\n    const newState = applyMigrations(oldState, path.migrations);\n\n    expect(newState.ids).toContain('new-resource-id');\n    expect(newState.ids).not.toContain('old-resource-id');\n    expect(newState.amounts[0]).toBe(100); // Value preserved\n  });\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"writing-deterministic-migrations",children:"Writing Deterministic Migrations"}),"\n",(0,t.jsx)(n.h3,{id:"principles-for-safe-migrations",children:"Principles for Safe Migrations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pure Transformations"}),": Migrations must be pure functions with no side effects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Idempotence"}),": Applying a migration twice should produce the same result"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lossless When Possible"}),": Preserve user data unless explicitly discarding"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fail Loudly"}),": Throw errors for unexpected state rather than silently corrupting data"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"pattern-resource-rename",children:"Pattern: Resource Rename"}),"\n",(0,t.jsx)(n.p,{children:"Renaming a resource requires migrating its ID and preserving all state arrays at the same index:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function migrateResourceRename(state: SerializedResourceState): SerializedResourceState {\n  const oldId = 'wood-gatherer';\n  const newId = 'lumber-gatherer';\n\n  const oldIndex = state.ids.indexOf(oldId);\n  if (oldIndex === -1) {\n    throw new Error(`Migration expected to find resource \"${oldId}\" but it was missing`);\n  }\n\n  // Clone and update IDs\n  const newIds = [...state.ids];\n  newIds[oldIndex] = newId;\n\n  // All other arrays (amounts, capacities, flags, etc.) remain unchanged\n  // since we're only renaming the ID, not changing the index position\n  return {\n    ...state,\n    ids: newIds,\n  };\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"IMPORTANT:"})," Do NOT manually set the ",(0,t.jsx)(n.code,{children:"definitionDigest"})," field in migration transforms. The digest is automatically stripped and recomputed by the engine during validation to ensure it matches the migrated IDs. If you include a stale digest, re-validation will fail."]}),"\n",(0,t.jsx)(n.h3,{id:"pattern-resource-merge",children:"Pattern: Resource Merge"}),"\n",(0,t.jsx)(n.p,{children:"Merging two resources into one requires combining state values from multiple arrays:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function migrateResourceMerge(state: SerializedResourceState): SerializedResourceState {\n  const sourceId1 = 'wood-gatherer';\n  const sourceId2 = 'stone-gatherer';\n  const targetId = 'resource-gatherer';\n\n  const idx1 = state.ids.indexOf(sourceId1);\n  const idx2 = state.ids.indexOf(sourceId2);\n\n  if (idx1 === -1 || idx2 === -1) {\n    throw new Error('Migration expected to find both source resources');\n  }\n\n  // Helper to remove elements at two indices and append a new value\n  const mergeArrays = <T>(arr: readonly T[], newValue: T): T[] => {\n    return arr.filter((_, i) => i !== idx1 && i !== idx2).concat([newValue]);\n  };\n\n  // Remove both old IDs, add new one\n  const newIds = mergeArrays(state.ids, targetId);\n\n  // Combine amounts (example: sum them)\n  const newAmounts = mergeArrays(\n    state.amounts,\n    state.amounts[idx1] + state.amounts[idx2]\n  );\n\n  // Combine capacities (example: take the maximum)\n  const capacity1 = state.capacities[idx1];\n  const capacity2 = state.capacities[idx2];\n  const mergedCapacity =\n    capacity1 == null || capacity2 == null\n      ? null\n      : Math.max(capacity1, capacity2);\n  const newCapacities = mergeArrays(state.capacities, mergedCapacity);\n\n  // Combine flags (example: bitwise OR)\n  const newFlags = mergeArrays(\n    state.flags,\n    state.flags[idx1] | state.flags[idx2]\n  );\n\n  // Handle optional arrays\n  const newUnlocked = state.unlocked\n    ? mergeArrays(state.unlocked, state.unlocked[idx1] || state.unlocked[idx2])\n    : undefined;\n\n  const newVisible = state.visible\n    ? mergeArrays(state.visible, state.visible[idx1] || state.visible[idx2])\n    : undefined;\n\n  return {\n    ids: newIds,\n    amounts: newAmounts,\n    capacities: newCapacities,\n    flags: newFlags,\n    ...(newUnlocked !== undefined && { unlocked: newUnlocked }),\n    ...(newVisible !== undefined && { visible: newVisible }),\n  };\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," When merging resources, carefully consider how to combine each field (sum amounts, max capacities, OR flags, etc.) based on your game's semantics."]}),"\n",(0,t.jsx)(n.h3,{id:"pattern-state-value-transformation",children:"Pattern: State Value Transformation"}),"\n",(0,t.jsx)(n.p,{children:"Transforming specific resource values (e.g., changing units, applying fixes):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function migrateStateStructure(state: SerializedResourceState): SerializedResourceState {\n  // Example: Converting elapsed-time resource from seconds to milliseconds\n  const timeResourceIndex = state.ids.indexOf('elapsed-time');\n\n  if (timeResourceIndex === -1) {\n    throw new Error('Migration expected to find \"elapsed-time\" resource');\n  }\n\n  // Transform the amount for the time resource\n  const newAmounts = state.amounts.map((amount, i) => {\n    if (i === timeResourceIndex) {\n      return amount * 1000; // Convert seconds to ms\n    }\n    return amount;\n  });\n\n  // If capacities also need scaling, transform them too\n  const newCapacities = state.capacities.map((capacity, i) => {\n    if (i === timeResourceIndex && capacity != null) {\n      return capacity * 1000;\n    }\n    return capacity;\n  });\n\n  return {\n    ...state,\n    amounts: newAmounts,\n    capacities: newCapacities,\n  };\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: Bulk transformation across all resources"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function migrateClampNegativeAmounts(state: SerializedResourceState): SerializedResourceState {\n  // Fix corrupted saves where amounts became negative\n  const newAmounts = state.amounts.map(amount => Math.max(0, amount));\n\n  return {\n    ...state,\n    amounts: newAmounts,\n  };\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"testing-determinism",children:"Testing Determinism"}),"\n",(0,t.jsx)(n.p,{children:"Ensure migrations are deterministic by running them multiple times and verifying identical output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"it('should produce identical results on repeated application', () => {\n  const originalState = createTestState();\n\n  // Get the registered migration\n  const path = findMigrationPath(oldDigest, newDigest);\n  expect(path.found).toBe(true);\n\n  const result1 = applyMigrations(originalState, path.migrations);\n  const result2 = applyMigrations(originalState, path.migrations);\n\n  expect(result1).toEqual(result2);\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing-migrations",children:"Testing Migrations"}),"\n",(0,t.jsx)(n.h3,{id:"using-existing-test-infrastructure",children:"Using Existing Test Infrastructure"}),"\n",(0,t.jsxs)(n.p,{children:["The engine provides comprehensive test utilities in ",(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/"}),":"]}),"\n",(0,t.jsx)(n.h4,{id:"1-unit-tests-for-migration-logic",children:"1. Unit Tests for Migration Logic"}),"\n",(0,t.jsx)(n.p,{children:"Test individual migration transforms in isolation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// my-pack-migrations.test.ts\nimport { describe, it, expect } from 'vitest';\n\ndescribe('resource rename migration', () => {\n  it('should rename resource ID while preserving values', () => {\n    const input: SerializedResourceState = {\n      ids: ['old-id', 'other-resource'],\n      amounts: [42, 100],\n      capacities: [1000, 2000],\n      flags: [0, 0],\n      definitionDigest: { hash: 'old-hash', version: 2, ids: ['old-id', 'other-resource'] },\n    };\n\n    const output = migrateResourceRename(input);\n\n    expect(output.ids).toEqual(['new-id', 'other-resource']);\n    expect(output.amounts).toEqual([42, 100]); // Values preserved\n    expect(output.capacities).toEqual([1000, 2000]);\n    expect(output.flags).toEqual([0, 0]);\n  });\n\n  it('should fail when expected resource is missing', () => {\n    const input: SerializedResourceState = {\n      ids: ['wrong-id'],\n      amounts: [0],\n      capacities: [100],\n      flags: [0],\n      definitionDigest: { hash: 'hash', version: 1, ids: ['wrong-id'] },\n    };\n\n    expect(() => migrateResourceRename(input)).toThrow('expected to find resource');\n  });\n});\n"})}),"\n",(0,t.jsx)(n.h4,{id:"2-integration-tests-with-sessionpersistenceadapter",children:"2. Integration Tests with SessionPersistenceAdapter"}),"\n",(0,t.jsx)(n.p,{children:"Test full save/migrate/restore flow (when migration execution is implemented):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// migration-integration.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport 'fake-indexeddb/auto'; // Mock IndexedDB\nimport { SessionPersistenceAdapter } from '../modules/session-persistence-adapter';\nimport { registerMigration } from '../modules/migration-registry'; // Placeholder - not yet implemented\n\ndescribe('migration integration', () => {\n  let adapter: SessionPersistenceAdapter;\n\n  beforeEach(() => {\n    adapter = new SessionPersistenceAdapter();\n  });\n\n  it('should apply migration when loading incompatible save', async () => {\n    // Helper to create old-format state\n    const createOldState = (): SerializedResourceState => ({\n      ids: ['old-resource-id'],\n      amounts: [999],\n      capacities: [1000],\n      flags: [0],\n      definitionDigest: {\n        hash: 'old-hash',\n        version: 1,\n        ids: ['old-resource-id']\n      },\n    });\n\n    // 1. Save state with old content digest\n    const oldSnapshot = {\n      schemaVersion: 1,\n      slotId: 'test-slot',\n      capturedAt: new Date().toISOString(),\n      workerStep: 100,\n      monotonicMs: 1000,\n      state: createOldState(),\n      runtimeVersion: '1.0.0',\n      contentDigest: {\n        hash: 'old-hash',\n        version: 1,\n        ids: ['old-resource-id']\n      },\n    };\n    await adapter.save(oldSnapshot);\n\n    // 2. Register migration (placeholder API)\n    const newDigest = { hash: 'new-hash', version: 1, ids: ['new-resource-id'] };\n    registerMigration({\n      id: 'test-migration',\n      fromDigest: oldSnapshot.contentDigest,\n      toDigest: newDigest,\n      transform: migrateResourceRename,\n    });\n\n    // 3. Load with new definitions (migration should auto-apply)\n    const newDefinitions = [/* new resource definitions */];\n    const loaded = await adapter.load('test-slot', newDefinitions);\n\n    // 4. Verify migration was applied\n    expect(loaded.state.ids).toContain('new-resource-id');\n    expect(loaded.state.ids).not.toContain('old-resource-id');\n    expect(loaded.state.amounts[0]).toBe(999); // Value preserved\n  });\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," Integration tests will work once the migration registry (Issue #155) is implemented."]}),"\n",(0,t.jsx)(n.h4,{id:"3-fixture-based-testing",children:"3. Fixture-Based Testing"}),"\n",(0,t.jsx)(n.p,{children:"Create fixture snapshots for regression testing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'// fixtures/saves/v1-to-v2-migration.json\n{\n  "schemaVersion": 1,\n  "slotId": "fixture-v1",\n  "state": {\n    "ids": ["old-resource-id"],\n    "amounts": [999],\n    "capacities": [1000],\n    "flags": [0],\n    "definitionDigest": {\n      "hash": "old-hash",\n      "version": 1,\n      "ids": ["old-resource-id"]\n    }\n  },\n  "runtimeVersion": "1.0.0",\n  "contentDigest": {\n    "hash": "old-hash",\n    "version": 1,\n    "ids": ["old-resource-id"]\n  },\n  "capturedAt": "2024-01-15T10:30:00.000Z",\n  "workerStep": 1000,\n  "monotonicMs": 60000\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Test against fixtures:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import fixtureV1 from './fixtures/saves/v1-to-v2-migration.json';\nimport { findMigrationPath, applyMigrations } from '@idle-engine/shell-web';\n\nit('should migrate v1 fixture to v2', () => {\n  const oldDigest = fixtureV1.contentDigest;\n  const newDigest = { hash: 'new-hash', version: 1, ids: ['new-resource-id'] };\n\n  const path = findMigrationPath(oldDigest, newDigest);\n  expect(path.found).toBe(true);\n\n  const migrated = applyMigrations(fixtureV1.state, path.migrations);\n\n  expect(migrated.ids).toEqual(['new-resource-id']);\n  expect(migrated.amounts).toEqual([999]); // Value preserved\n  expect(migrated.capacities).toEqual([1000]);\n  expect(migrated.flags).toEqual([0]);\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cli-commands-for-running-tests",children:"CLI Commands for Running Tests"}),"\n",(0,t.jsx)(n.p,{children:"Run migration tests using Vitest:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Run all migration tests\npnpm test migration\n\n# Run tests in watch mode during development\npnpm test --watch migration\n\n# Run specific test file\npnpm --filter @idle-engine/shell-web test my-pack-migrations\n\n# Generate coverage report\npnpm test --coverage migration\n"})}),"\n",(0,t.jsx)(n.h3,{id:"example-test-cases",children:"Example Test Cases"}),"\n",(0,t.jsx)(n.p,{children:"Comprehensive test cases should cover:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"describe('migration test suite', () => {\n  describe('correctness', () => {\n    it('should preserve all user data');\n    it('should update resource IDs correctly');\n    it('should recompute content digest');\n  });\n\n  describe('error handling', () => {\n    it('should throw when required resource is missing');\n    it('should throw on invalid state structure');\n    it('should provide clear error messages');\n  });\n\n  describe('determinism', () => {\n    it('should produce identical results on repeated runs');\n    it('should produce same hash across different environments');\n  });\n\n  describe('edge cases', () => {\n    it('should handle empty state arrays');\n    it('should handle maximum array sizes');\n    it('should handle special numeric values (NaN, Infinity)');\n  });\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/session-restore.test.ts"})," for real-world examples."]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-bump-schema-versions",children:"When to Bump Schema Versions"}),"\n",(0,t.jsx)(n.h3,{id:"persistence_schema_version",children:"PERSISTENCE_SCHEMA_VERSION"}),"\n",(0,t.jsxs)(n.p,{children:["Bump ",(0,t.jsx)(n.code,{children:"PERSISTENCE_SCHEMA_VERSION"})," (defined in ",(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/session-persistence-adapter.ts:10"}),") when:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The structure of ",(0,t.jsx)(n.code,{children:"StoredSessionSnapshot"})," changes"]}),"\n",(0,t.jsx)(n.li,{children:"New required fields are added to the snapshot"}),"\n",(0,t.jsx)(n.li,{children:"Field types change in a breaking way"}),"\n",(0,t.jsx)(n.li,{children:"IndexedDB schema migration is needed"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Do NOT bump"})," for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Content pack resource changes (use content migrations instead)"}),"\n",(0,t.jsx)(n.li,{children:"Runtime version updates"}),"\n",(0,t.jsx)(n.li,{children:"Non-breaking additions (new optional fields)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"When bumping, you must also implement an IndexedDB schema migration to handle existing snapshots."}),"\n",(0,t.jsx)(n.h3,{id:"contentdigest",children:"contentDigest"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"contentDigest"})," is ",(0,t.jsx)(n.strong,{children:"automatically computed"})," on every save and load. You don't manually bump it. Instead:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Change your resource definitions (add, remove, rename resources)"}),"\n",(0,t.jsx)(n.li,{children:"The digest will automatically update to reflect the new IDs"}),"\n",(0,t.jsx)(n.li,{children:"Write a content migration to handle saves with the old digest"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"runtimeversion",children:"runtimeVersion"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"runtimeVersion"})," is ",(0,t.jsx)(n.strong,{children:"automatically set"})," from ",(0,t.jsx)(n.code,{children:"@idle-engine/core"}),"'s ",(0,t.jsx)(n.code,{children:"package.json"}),". You don't manually control it. The engine records it for diagnostic purposes but doesn't use it for validation."]}),"\n",(0,t.jsx)(n.h2,{id:"current-implementation-status--tooling-gaps",children:"Current Implementation Status & Tooling Gaps"}),"\n",(0,t.jsx)(n.h3,{id:"what-works-today",children:"What Works Today"}),"\n",(0,t.jsxs)(n.p,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Session save/load to IndexedDB"})," - Full implementation in ",(0,t.jsx)(n.code,{children:"SessionPersistenceAdapter"}),"\n\u2705 ",(0,t.jsx)(n.strong,{children:"Content digest computation and validation"})," - Detects when definitions change\n\u2705 ",(0,t.jsx)(n.strong,{children:"Graceful handling of added resources"})," - New resources initialize to defaults\n\u2705 ",(0,t.jsx)(n.strong,{children:"Checksum validation"})," - Detects corrupted snapshots using SHA-256\n\u2705 ",(0,t.jsx)(n.strong,{children:"Telemetry for migration events"})," - ",(0,t.jsx)(n.code,{children:"PersistenceMigrationRequired"}),", ",(0,t.jsx)(n.code,{children:"PersistenceMigrationApplied"}),", ",(0,t.jsx)(n.code,{children:"PersistenceMigrationFailed"})," emitted\n\u2705 ",(0,t.jsx)(n.strong,{children:"Comprehensive test infrastructure"})," - Unit, integration, and fixture tests\n\u2705 ",(0,t.jsx)(n.strong,{children:"Migration registry"})," - ",(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/migration-registry.ts"})," with BFS pathfinding\n\u2705 ",(0,t.jsx)(n.strong,{children:"Migration execution"})," - ",(0,t.jsx)(n.code,{children:"session-restore.ts:attemptMigration()"})," applies transforms and re-validates\n\u2705 ",(0,t.jsx)(n.strong,{children:"Public API"})," - ",(0,t.jsx)(n.code,{children:"registerMigration()"}),", ",(0,t.jsx)(n.code,{children:"findMigrationPath()"}),", ",(0,t.jsx)(n.code,{children:"applyMigrations()"})," exported\n\u2705 ",(0,t.jsx)(n.strong,{children:"Content pack manifests"})," - ",(0,t.jsx)(n.code,{children:"StoredSessionSnapshot.contentPacks"})," field for tracking pack versions"]}),"\n",(0,t.jsx)(n.h3,{id:"known-limitations",children:"Known Limitations"}),"\n",(0,t.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"No CLI tooling"})," - No commands to generate migration scaffolds or validate determinism\n\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"No migration templates"})," - No example migrations in real content packs yet (coming soon)\n\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"No resourceDeltas support"})," - ",(0,t.jsx)(n.code,{children:"RESTORE_SESSION"})," message accepts deltas but they're never populated\n\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"Content pack manifest population"})," - ",(0,t.jsx)(n.code,{children:"StoredSessionSnapshot.contentPacks"})," field is defined but worker does not yet supply content pack metadata. Reserved for future multi-pack support in runtime."]}),"\n",(0,t.jsx)(n.h3,{id:"follow-up-tooling-future-work",children:"Follow-Up Tooling (Future Work)"}),"\n",(0,t.jsx)(n.p,{children:"Track these in future issues:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CLI scaffold generator"})," - ",(0,t.jsx)(n.code,{children:"npx idle-engine generate migration"})," command"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Checksum helpers"})," - Utilities for computing and verifying migration determinism"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Diagnostic tools"})," - CLI to inspect save files and test migrations offline"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Content pack manifest population"})," - Auto-populate ",(0,t.jsx)(n.code,{children:"contentPacks"})," during save operations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example migrations"})," - Add real migration examples to sample content pack"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsx)(n.h3,{id:"design-documents",children:"Design Documents"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/Idle-Game-Engine/runtime-react-worker-bridge-design",children:"Runtime-React-Worker-Bridge Design"})," - Section 14.1 covers persistence handoff"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/Idle-Game-Engine/resource-state-storage-design",children:"Resource State Storage Design"})," - Serialization format and digest computation"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-files",children:"Implementation Files"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/session-persistence-adapter.ts"})," - IndexedDB adapter API"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/session-restore.ts"})," - Validation and migration flow"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/migration-registry.ts"})," - Migration registration and pathfinding"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/core/src/resource-state.ts"})," - Digest computation (",(0,t.jsx)(n.code,{children:"createDefinitionDigest"}),") and reconciliation (",(0,t.jsx)(n.code,{children:"reconcileSaveAgainstDefinitions"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"test-files",children:"Test Files"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/session-persistence-adapter.test.ts"})," - Adapter unit tests"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/session-restore.test.ts"})," - Validation logic tests"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"packages/shell-web/src/modules/session-persistence-integration.test.ts"})," - Full round-trip tests"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"related-issues",children:"Related Issues"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Issue #273 - This documentation (migration authoring guide)"}),"\n",(0,t.jsx)(n.li,{children:"Issue #155 - Save file format with content pack manifests and migrations"}),"\n",(0,t.jsx)(n.li,{children:"Issue #271 - Session persistence adapter (completed)"}),"\n",(0,t.jsx)(n.li,{children:"Issue #16 - Original persistence tracking issue"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," The migration system is fully implemented as of Issue #155. The core registry, pathfinding, and execution logic are complete and tested. Content pack authors can register migrations using the ",(0,t.jsx)(n.code,{children:"registerMigration()"})," API. Remember that migration transforms should NOT manually set the ",(0,t.jsx)(n.code,{children:"definitionDigest"})," field - it is automatically stripped and recomputed during validation to ensure correctness."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},7678:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(9430);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);