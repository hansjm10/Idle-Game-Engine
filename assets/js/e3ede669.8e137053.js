"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[5118],{6344:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"issue-807-design","title":"shell-desktop: Use Monotonic Clock + Clamp deltaMs in Tick Loop (Issue 807)","description":"Document Control","source":"@site/../../docs/issue-807-design.md","sourceDirName":".","slug":"/issue-807-design","permalink":"/Idle-Game-Engine/issue-807-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/issue-807-design.md","tags":[],"version":"current","sidebarPosition":99,"frontMatter":{"title":"shell-desktop: Use Monotonic Clock + Clamp deltaMs in Tick Loop (Issue 807)","sidebar_position":99}}');var l=n(5270),t=n(7678);const d={title:"shell-desktop: Use Monotonic Clock + Clamp deltaMs in Tick Loop (Issue 807)",sidebar_position:99},r="shell-desktop: Use Monotonic Clock + Clamp deltaMs in Tick Loop (Issue 807)",c={},o=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Open Questions",id:"13-open-questions",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function a(e){const s={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(s.header,{children:(0,l.jsx)(s.h1,{id:"shell-desktop-use-monotonic-clock--clamp-deltams-in-tick-loop-issue-807",children:"shell-desktop: Use Monotonic Clock + Clamp deltaMs in Tick Loop (Issue 807)"})}),"\n",(0,l.jsx)(s.h2,{id:"document-control",children:"Document Control"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Title"}),": Use a monotonic clock and clamp ",(0,l.jsx)(s.code,{children:"deltaMs"})," in the desktop shell tick loop"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Authors"}),": Codex (AI)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Reviewers"}),": @hansjm10"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Status"}),": Draft"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Last Updated"}),": 2026-01-21"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Related Issues"}),": ",(0,l.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/807",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/807"})]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.code,{children:"@idle-engine/shell-desktop"})," drives the simulation worker via a 16ms ",(0,l.jsx)(s.code,{children:"setInterval"})," tick loop that derives ",(0,l.jsx)(s.code,{children:"deltaMs"})," from ",(0,l.jsx)(s.code,{children:"Date.now()"}),". Wall-clock adjustments (NTP, manual time changes, sleep/resume) can produce non-monotonic or very large deltas, which can hitch the sim and flood frames to the renderer. This design switches the tick loop to a monotonic time source and clamps unusually large deltas (e.g. ",(0,l.jsx)(s.code,{children:"MAX_TICK_DELTA_MS = 250"}),") so the sim stays stable even when the system clock jumps."]}),"\n",(0,l.jsx)(s.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Background"}),": The Electron main process creates a Node ",(0,l.jsx)(s.code,{children:"Worker"})," (",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"}),") that runs the deterministic runtime and emits ",(0,l.jsx)(s.code,{children:"RenderCommandBuffer"})," frames. The main process (",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"}),") periodically sends ",(0,l.jsx)(s.code,{children:"{ kind: 'tick', deltaMs }"})," messages to advance the sim and forwards frames to the renderer via IPC."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Problem"}),": The current tick loop uses ",(0,l.jsx)(s.code,{children:"Date.now()"})," to compute ",(0,l.jsx)(s.code,{children:"deltaMs"})," (",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"}),"). Because ",(0,l.jsx)(s.code,{children:"Date.now()"})," is wall-clock time, it can jump backwards/forwards. Backwards jumps can create zero/negative deltas (currently clamped to 0), while forward jumps can create unexpectedly large deltas, causing the worker to attempt to simulate a large amount of time in one tick and potentially emit many frames in quick succession."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Forces"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Preserve the existing worker protocol (",(0,l.jsx)(s.code,{children:"{ kind: 'tick', deltaMs: number }"}),") and avoid changes to the renderer contract."]}),"\n",(0,l.jsx)(s.li,{children:"Keep the desktop shell responsive and predictable under sleep/resume and clock adjustments."}),"\n",(0,l.jsx)(s.li,{children:"Ensure tests remain deterministic and do not depend on real time."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Goals"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Compute ",(0,l.jsx)(s.code,{children:"deltaMs"})," from a monotonic time source (unaffected by wall-clock adjustments)."]}),"\n",(0,l.jsxs)(s.li,{children:["Clamp ",(0,l.jsx)(s.code,{children:"deltaMs"})," to a bounded maximum (target: ",(0,l.jsx)(s.code,{children:"250ms"}),") and to a minimum of ",(0,l.jsx)(s.code,{children:"0ms"}),"."]}),"\n",(0,l.jsx)(s.li,{children:"Add a unit test that simulates a backwards jump and a large jump and asserts clamping behavior."}),"\n",(0,l.jsx)(s.li,{children:"Preserve existing behavior for steady-state ticks (no functional changes beyond time source + clamp)."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Non-Goals"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Redesigning the sim scheduling model (e.g., switching away from ",(0,l.jsx)(s.code,{children:"setInterval"}),")."]}),"\n",(0,l.jsxs)(s.li,{children:["Changing ",(0,l.jsx)(s.code,{children:"SimRuntime"})," stepping behavior in ",(0,l.jsx)(s.code,{children:"@idle-engine/core"}),"."]}),"\n",(0,l.jsx)(s.li,{children:"Adding telemetry/analytics infrastructure (beyond optional dev-only diagnostics if needed)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Primary Stakeholders"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Desktop shell maintainers (",(0,l.jsx)(s.code,{children:"packages/shell-desktop"}),")."]}),"\n",(0,l.jsx)(s.li,{children:"Runtime maintainers (indirectly impacted by tick cadence quality)."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Agent Roles"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Docs Agent"}),": Maintain this design doc and track open questions."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Shell Implementation Agent"}),": Update the main-process tick loop to use a monotonic clock + clamp deltas."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Test Agent"}),": Add deterministic unit coverage for clamping behavior."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Affected Packages/Services"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})," (tick loop time source + clamping)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"})," (new clamping test; updates to existing tick expectations if needed)"]}),"\n",(0,l.jsxs)(s.li,{children:["(Optional) ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/monotonic-time.ts"})," (shared monotonic clock helper for easy mocking)"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Compatibility Considerations"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Keep the tick message shape unchanged (",(0,l.jsx)(s.code,{children:"deltaMs: number"}),")."]}),"\n",(0,l.jsxs)(s.li,{children:["Prefer keeping ",(0,l.jsx)(s.code,{children:"deltaMs"})," an integer millisecond value to avoid subtle downstream behavior differences and to keep tests stable."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,l.jsxs)(s.p,{children:["The tick loop in ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})," is currently:"]}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"tickIntervalMs = 16"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"lastTickMs = Date.now()"})}),"\n",(0,l.jsxs)(s.li,{children:["On each interval:","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"nowMs = Date.now()"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"deltaMs = Math.max(0, nowMs - lastTickMs)"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"lastTickMs = nowMs"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"worker.postMessage({ kind: 'tick', deltaMs })"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.p,{children:["This partially guards against a backwards clock jump (negative delta becomes ",(0,l.jsx)(s.code,{children:"0"}),") but does not bound large deltas. The worker (",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"}),") only checks ",(0,l.jsx)(s.code,{children:"Number.isFinite(deltaMs)"})," and forwards ",(0,l.jsx)(s.code,{children:"deltaMs"})," into ",(0,l.jsx)(s.code,{children:"SimRuntime.tick(deltaMs)"})," (",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/sim/sim-runtime.ts"}),"), which ultimately calls ",(0,l.jsx)(s.code,{children:"IdleEngineRuntime.tick(deltaMs)"})," and can emit a frame per sim step via a demo ",(0,l.jsx)(s.code,{children:"frame-producer"})," system."]}),"\n",(0,l.jsxs)(s.p,{children:["The current tests in ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"})," use ",(0,l.jsx)(s.code,{children:"vi.useFakeTimers()"})," and ",(0,l.jsx)(s.code,{children:"vi.setSystemTime(...)"})," to assert tick cadence and expect exact ",(0,l.jsx)(s.code,{children:"deltaMs"})," values derived from ",(0,l.jsx)(s.code,{children:"Date.now()"}),". There is currently no coverage for large deltas or clamping behavior."]}),"\n",(0,l.jsx)(s.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,l.jsx)(s.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Narrative"}),": Replace wall-clock time in the main-process tick loop with a monotonic clock, and clamp computed deltas before posting tick messages to the sim worker. This is a localized change: the worker protocol and runtime remain unchanged, but receive more stable inputs."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Diagram"}),": N/A (small localized change to the existing main-process scheduler)."]}),"\n"]}),"\n",(0,l.jsx)(s.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Runtime Changes"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Update ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})," tick loop to use one of:","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"process.hrtime.bigint()"})," converted to integer milliseconds (preferred for integer deltas), or"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"performance.now()"})," with explicit rounding to integer milliseconds."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["Add ",(0,l.jsx)(s.code,{children:"MAX_TICK_DELTA_MS = 250"})," (constant local to ",(0,l.jsx)(s.code,{children:"main.ts"}),", or exported from a helper module)."]}),"\n",(0,l.jsxs)(s.li,{children:["Compute ",(0,l.jsx)(s.code,{children:"rawDeltaMs = nowMs - lastTickMs"})," and clamp:","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"deltaMs = clamp(rawDeltaMs, 0, MAX_TICK_DELTA_MS)"})}),"\n",(0,l.jsxs)(s.li,{children:["Always update ",(0,l.jsx)(s.code,{children:"lastTickMs = nowMs"})," (even when clamped) to prevent repeated clamping for a single jump."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["Optional hardening: if ",(0,l.jsx)(s.code,{children:"rawDeltaMs"})," is not finite, treat as ",(0,l.jsx)(s.code,{children:"0"})," and reset ",(0,l.jsx)(s.code,{children:"lastTickMs"})," (defensive only)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Data & Schemas"}),": N/A (no schema changes)."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"APIs & Contracts"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["No changes to ",(0,l.jsx)(s.code,{children:"SimWorkerTickMessage"})," (",(0,l.jsx)(s.code,{children:"deltaMs: number"}),") or IPC surfaces."]}),"\n",(0,l.jsxs)(s.li,{children:["Keep ",(0,l.jsx)(s.code,{children:"deltaMs"})," as an integer ms value to preserve existing expectations and avoid float-driven drift in accumulation logic."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Tooling & Automation"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["If introducing a helper module (e.g. ",(0,l.jsx)(s.code,{children:"src/monotonic-time.ts"}),"), keep it as a tiny pure utility so tests can ",(0,l.jsx)(s.code,{children:"vi.mock(...)"})," it without involving Electron mocks."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Deployment"}),": N/A (no service rollout; shipped with the desktop shell build)."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Telemetry & Observability"}),": Optional dev-only diagnostic log when ",(0,l.jsx)(s.code,{children:"rawDeltaMs"})," is clamped (rate-limited) to aid debugging. Default behavior should avoid console noise."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Security & Compliance"}),": N/A."]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,l.jsx)(s.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,l.jsxs)(s.table,{children:[(0,l.jsx)(s.thead,{children:(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.th,{children:"Issue Title"}),(0,l.jsx)(s.th,{children:"Scope Summary"}),(0,l.jsx)(s.th,{children:"Proposed Assignee/Agent"}),(0,l.jsx)(s.th,{children:"Dependencies"}),(0,l.jsx)(s.th,{children:"Acceptance Criteria"})]})}),(0,l.jsxs)(s.tbody,{children:[(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:(0,l.jsx)(s.code,{children:"bug(shell-desktop): use monotonic clock + clamp tick deltaMs"})}),(0,l.jsxs)(s.td,{children:["Replace ",(0,l.jsx)(s.code,{children:"Date.now()"})," tick timing with monotonic source; clamp ",(0,l.jsx)(s.code,{children:"deltaMs"})]}),(0,l.jsx)(s.td,{children:"Shell Implementation Agent"}),(0,l.jsx)(s.td,{children:"Design doc approved"}),(0,l.jsxs)(s.td,{children:[(0,l.jsx)(s.code,{children:"deltaMs"})," is non-negative and ",(0,l.jsx)(s.code,{children:"<= 250ms"}),"; existing behavior intact for normal ticks"]})]}),(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:(0,l.jsx)(s.code,{children:"test(shell-desktop): cover backwards/large clock jump clamping"})}),(0,l.jsx)(s.td,{children:"Add deterministic unit test for clamping"}),(0,l.jsx)(s.td,{children:"Test Agent"}),(0,l.jsx)(s.td,{children:"Tick loop change merged or mocked"}),(0,l.jsxs)(s.td,{children:["Test simulates backwards + large jumps and asserts clamping; ",(0,l.jsx)(s.code,{children:"pnpm test --filter @idle-engine/shell-desktop"})," passes"]})]})]})]}),"\n",(0,l.jsx)(s.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Phase 1"}),": Implement monotonic time + clamp in ",(0,l.jsx)(s.code,{children:"main.ts"}),", update existing tick-loop tests for deterministic behavior."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Phase 2"}),": Add explicit clamping tests and optional dev-only diagnostic logging (if desired)."]}),"\n"]}),"\n",(0,l.jsx)(s.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Hand-off Package"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Issue 807: ",(0,l.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/807",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/807"})]}),"\n",(0,l.jsxs)(s.li,{children:["Files: ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"}),", ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"}),", ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Communication Cadence"}),": Single reviewer pass once Phase 1+2 land together; clamping value decision confirmed in review."]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Context Packets"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Issue 807: ",(0,l.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/807",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/807"})]}),"\n",(0,l.jsxs)(s.li,{children:["Tick loop: ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})]}),"\n",(0,l.jsxs)(s.li,{children:["Worker tick handling: ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})]}),"\n",(0,l.jsxs)(s.li,{children:["Existing tests: ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"})]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Prompting & Constraints"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Do not edit generated ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/dist/**"})," outputs by hand."]}),"\n",(0,l.jsxs)(s.li,{children:["Preserve type-only imports/exports (",(0,l.jsx)(s.code,{children:"import type"})," / ",(0,l.jsx)(s.code,{children:"export type"}),")."]}),"\n",(0,l.jsx)(s.li,{children:"Keep tests deterministic: avoid real-time waits; use fake timers and/or mock the monotonic clock helper."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Safety Rails"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Ensure clamp logic does not accidentally \u201cfreeze\u201d the sim (e.g., by producing ",(0,l.jsx)(s.code,{children:"NaN"})," deltas)."]}),"\n",(0,l.jsx)(s.li,{children:"Avoid logging on every tick; only log when clamping occurs and only in dev/flagged mode (optional)."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Validation Hooks"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"pnpm test --filter @idle-engine/shell-desktop"})}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"pnpm lint --filter @idle-engine/shell-desktop"})," (if changing imports/modules)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsxs)(s.strong,{children:["Continue using ",(0,l.jsx)(s.code,{children:"Date.now()"})," and only clamp large deltas"]}),": Still vulnerable to backwards jumps and wall-clock discontinuities; \u201cmonotonic\u201d acceptance criterion not satisfied."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Clamp inside the worker/runtime only"}),": Helps limit damage but still lets wall-clock discontinuities into the system; better to sanitize at the source."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsxs)(s.strong,{children:["Drive the sim from renderer timing (",(0,l.jsx)(s.code,{children:"requestAnimationFrame"}),")"]}),": Ties sim cadence to UI and loses isolation benefits of the worker."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Catch-up loop instead of clamp"}),": Attempting to simulate \u201call missed time\u201d increases worst-case work and frame flooding; clamping is intentionally lossy to preserve responsiveness."]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Unit / Integration"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Add a unit test that controls the clock values and asserts:","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["backwards jump produces ",(0,l.jsx)(s.code,{children:"deltaMs = 0"}),","]}),"\n",(0,l.jsxs)(s.li,{children:["large jump produces ",(0,l.jsx)(s.code,{children:"deltaMs = MAX_TICK_DELTA_MS"})," (250)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["Recommended test strategy:","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["If ",(0,l.jsx)(s.code,{children:"main.ts"})," imports a helper like ",(0,l.jsx)(s.code,{children:"monotonicNowMs()"})," from ",(0,l.jsx)(s.code,{children:"src/monotonic-time.ts"}),", use ",(0,l.jsx)(s.code,{children:"vi.mock('./monotonic-time.js', ...)"})," to return a scripted sequence of times per tick."]}),"\n",(0,l.jsxs)(s.li,{children:["Use ",(0,l.jsx)(s.code,{children:"vi.useFakeTimers()"})," and ",(0,l.jsx)(s.code,{children:"vi.advanceTimersByTimeAsync(...)"})," to trigger interval callbacks without waiting."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["Update existing \u201cstarts the sim tick loop\u201d test to avoid depending on wall-clock ",(0,l.jsx)(s.code,{children:"Date.now()"})," behavior (use the same mocked monotonic clock)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Performance"}),": N/A (small scheduling change; no new hot path allocations)."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Tooling / A11y"}),": N/A."]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Risk"}),": Switching to a high-resolution clock introduces fractional deltas that change sim behavior.",(0,l.jsx)(s.br,{}),"\n",(0,l.jsx)(s.strong,{children:"Mitigation"}),": Use integer millisecond deltas (e.g., hrtime conversion or explicit rounding) to preserve current semantics."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Risk"}),": Clamp value too low causes the sim to run \u201cslow\u201d after long stalls (lost time).",(0,l.jsx)(s.br,{}),"\n",(0,l.jsx)(s.strong,{children:"Mitigation"}),": Confirm ",(0,l.jsx)(s.code,{children:"MAX_TICK_DELTA_MS"})," (250ms) is desired for UX; consider tying clamp to ",(0,l.jsx)(s.code,{children:"stepSizeMs"}),"/",(0,l.jsx)(s.code,{children:"maxStepsPerFrame"})," if needed."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Risk"}),": Tests become flaky if they depend on real time (hrtime/performance).",(0,l.jsx)(s.br,{}),"\n",(0,l.jsx)(s.strong,{children:"Mitigation"}),": Mock the monotonic clock source in tests; do not rely on real elapsed time."]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Milestones"}),":","\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Land the tick-loop clock + clamping change with updated tests."}),"\n",(0,l.jsx)(s.li,{children:"Land the explicit clamping test (and optional dev-only diagnostics)."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Migration Strategy"}),": None (internal behavior change only; no persisted data)."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Communication"}),": Note in the PR description that the desktop sim tick loop is now monotonic and bounded, preventing frame floods after clock jumps/sleep."]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"13-open-questions",children:"13. Open Questions"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Is ",(0,l.jsx)(s.code,{children:"MAX_TICK_DELTA_MS = 250"})," the preferred clamp value for the desktop shell, or should it be derived from ",(0,l.jsx)(s.code,{children:"stepSizeMs * maxStepsPerFrame"})," (or made configurable)?"]}),"\n",(0,l.jsxs)(s.li,{children:["Should we also clamp inside the worker (",(0,l.jsx)(s.code,{children:"sim-worker.ts"}),") as a defense-in-depth measure, even if the main process clamps?"]}),"\n",(0,l.jsx)(s.li,{children:"Should clamping emit a dev-only warning (rate-limited) to help diagnose sleep/resume behavior?"}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Consider a more robust scheduling model if frame flooding is still observed under heavy load (e.g., tick acknowledgements or adaptive cadence)."}),"\n",(0,l.jsx)(s.li,{children:"If needed, expose max delta as a debug setting/env var for experimentation."}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"15-references",children:"15. References"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Issue 807: ",(0,l.jsx)(s.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/807",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/807"})]}),"\n",(0,l.jsxs)(s.li,{children:["Tick loop implementation: ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.ts"})]}),"\n",(0,l.jsxs)(s.li,{children:["Worker tick handler: ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/sim-worker.ts"})]}),"\n",(0,l.jsxs)(s.li,{children:["Sim runtime tick: ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/sim/sim-runtime.ts"})]}),"\n",(0,l.jsxs)(s.li,{children:["Desktop shell tests: ",(0,l.jsx)(s.code,{children:"packages/shell-desktop/src/main.test.ts"})]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:(0,l.jsx)(s.code,{children:"deltaMs"})}),": The elapsed-time input (in milliseconds) sent from the main process to the sim worker each tick."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Monotonic clock"}),": A time source that never goes backwards and is not affected by wall-clock adjustments (e.g., ",(0,l.jsx)(s.code,{children:"process.hrtime.bigint()"}),", ",(0,l.jsx)(s.code,{children:"performance.now()"}),")."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.strong,{children:"Tick loop"}),": The main-process ",(0,l.jsx)(s.code,{children:"setInterval"})," loop that advances the sim worker by posting tick messages."]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,l.jsxs)(s.table,{children:[(0,l.jsx)(s.thead,{children:(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.th,{children:"Date"}),(0,l.jsx)(s.th,{children:"Author"}),(0,l.jsx)(s.th,{children:"Change Summary"})]})}),(0,l.jsx)(s.tbody,{children:(0,l.jsxs)(s.tr,{children:[(0,l.jsx)(s.td,{children:"2026-01-21"}),(0,l.jsx)(s.td,{children:"Codex (AI)"}),(0,l.jsx)(s.td,{children:"Initial draft for Issue 807"})]})})]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,l.jsx)(s,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},7678:(e,s,n)=>{n.d(s,{R:()=>d,x:()=>r});var i=n(9430);const l={},t=i.createContext(l);function d(e){const s=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:d(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);