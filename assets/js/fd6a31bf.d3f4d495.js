"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[5662],{4201:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"content-compiler-design","title":"Content Compiler Design Document","description":"Issue: #159","source":"@site/../../docs/content-compiler-design.md","sourceDirName":".","slug":"/content-compiler-design","permalink":"/Idle-Game-Engine/content-compiler-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/content-compiler-design.md","tags":[],"version":"current","frontMatter":{},"sidebar":"developerSidebar","previous":{"title":"Content DSL Usage Guidelines","permalink":"/Idle-Game-Engine/content-dsl-usage-guidelines"},"next":{"title":"Content Schema Rollout Decisions","permalink":"/Idle-Game-Engine/content-schema-rollout-decisions"}}');var s=i(5270),r=i(7678);const a={},o="Content Compiler Design Document",c={},l=[{value:"1. Problem Statement",id:"1-problem-statement",level:2},{value:"2. Goals",id:"2-goals",level:2},{value:"3. Non-Goals",id:"3-non-goals",level:2},{value:"4. Current State",id:"4-current-state",level:2},{value:"5. Target Architecture",id:"5-target-architecture",level:2},{value:"5.1 Package Layout &amp; Ownership",id:"51-package-layout--ownership",level:3},{value:"5.2 Public API Surface",id:"52-public-api-surface",level:3},{value:"5.3 Compilation Workflow",id:"53-compilation-workflow",level:3},{value:"5.5 Determinism &amp; Integrity",id:"55-determinism--integrity",level:3},{value:"5.5.1 Artifact Integrity Contract",id:"551-artifact-integrity-contract",level:3},{value:"5.6 Dependency Handling",id:"56-dependency-handling",level:3},{value:"5.7 Logging &amp; Telemetry",id:"57-logging--telemetry",level:3},{value:"5.8 Developer Experience &amp; Adoption",id:"58-developer-experience--adoption",level:3},{value:"6. Implementation Plan",id:"6-implementation-plan",level:2},{value:"Phase 1 - Package Foundations",id:"phase-1---package-foundations",level:3},{value:"Phase 2 - Artifact Emitters &amp; CLI Wiring",id:"phase-2---artifact-emitters--cli-wiring",level:3},{value:"Phase 3 - Developer Experience &amp; Adoption",id:"phase-3---developer-experience--adoption",level:3},{value:"7. Success Criteria",id:"7-success-criteria",level:2},{value:"8. Open Questions",id:"8-open-questions",level:2},{value:"9. References",id:"9-references",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"content-compiler-design-document",children:"Content Compiler Design Document"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Issue:"})," #159",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Workstream:"})," Content Pipeline",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Status:"})," Design",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Last Updated:"})," 2025-10-22"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Issue #12 unlocks the compiler stage of the content pipeline. With the schema in place, packs must be transformed into deterministic runtime-ready artifacts so the engine and tooling never depend on ad-hoc TypeScript exports."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"1-problem-statement",children:"1. Problem Statement"}),"\n",(0,s.jsxs)(n.p,{children:["The content DSL distributed through ",(0,s.jsx)(n.code,{children:"@idle-engine/content-schema"})," already returns fully normalized ",(0,s.jsx)(n.code,{children:"NormalizedContentPack"})," objects, yet every consumer still reparses authoring JSON at runtime. Each import of ",(0,s.jsx)(n.code,{children:"packages/content-sample"})," calls ",(0,s.jsx)(n.code,{children:"parseContentPack"}),", rebuilding lookup maps and re-running validation, the CLI (",(0,s.jsx)(n.code,{children:"tools/content-schema-cli/src/generate.js"}),") only validates packs while generating the runtime event manifest, and automation has no way to assert that generated artifacts match what is committed. Missing compiler outputs also block downstream tooling from consuming packs without pulling in the schema bundle."]}),"\n",(0,s.jsx)(n.h2,{id:"2-goals",children:"2. Goals"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Compile each discovered pack into a deterministic ",(0,s.jsx)(n.code,{children:"SerializedNormalizedContentPack"})," plus an ",(0,s.jsx)(n.code,{children:"artifactHash"})," so mutations can be detected without revalidation."]}),"\n",(0,s.jsxs)(n.li,{children:["Publish ",(0,s.jsx)(n.code,{children:"@idle-engine/content-compiler"})," with a Node entrypoint for the CLI and a browser-safe runtime entrypoint for consumers that only need rehydration helpers."]}),"\n",(0,s.jsxs)(n.li,{children:["Fold compilation into ",(0,s.jsx)(n.code,{children:"pnpm generate"})," so validation, manifest regeneration, and compilation happen in one command that supports watch mode, ",(0,s.jsx)(n.code,{children:"--check"}),", and ",(0,s.jsx)(n.code,{children:"--clean"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Emit TypeScript modules and JSON artifacts that runtime packages import instead of calling ",(0,s.jsx)(n.code,{children:"parseContentPack"}),", while exposing digests, warning metadata, and positional indices."]}),"\n",(0,s.jsx)(n.li,{children:"Surface structured JSON log events that follow data-pipeline logging best practices, enabling CI and observability tooling to gate builds on compiler health."}),"\n",(0,s.jsxs)(n.li,{children:["Track discovery metadata and prune stale outputs so committed artifacts align with the set of packs in ",(0,s.jsx)(n.code,{children:"packages/*/content/"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-non-goals",children:"3. Non-Goals"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Pre-evaluating or optimizing pack formulas into bytecode; formula execution remains a runtime responsibility (",(0,s.jsx)(n.code,{children:"docs/runtime-step-lifecycle.md"}),")."]}),"\n",(0,s.jsx)(n.li,{children:"Shipping content balance heuristics, localization exports, or asset bundling flows."}),"\n",(0,s.jsx)(n.li,{children:"Producing bespoke binary assets; JSON and TypeScript output is sufficient for this milestone."}),"\n",(0,s.jsx)(n.li,{children:"Replacing the runtime event manifest generator or altering digest semantics defined by the schema package."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"4-current-state",children:"4. Current State"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"packages/content-sample/src/index.ts"})," now imports the compiler's generated module (",(0,s.jsx)(n.code,{children:"src/generated/@idle-engine/sample-pack.generated.ts"}),"), re-exporting the rehydrated pack alongside digest, summary, and module indices. Earlier revisions called ",(0,s.jsx)(n.code,{children:"parseContentPack"})," on ",(0,s.jsx)(n.code,{children:"content/pack.json"})," during import, re-running schema validation for every consumer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tools/content-schema-cli/src/generate.js"})," builds the runtime event manifest and validates packs but does not write pack-level artifacts or logs."]}),"\n",(0,s.jsxs)(n.li,{children:["No package currently writes ",(0,s.jsx)(n.code,{children:"content/compiled/"})," or ",(0,s.jsx)(n.code,{children:"src/generated/"})," outputs; a search for those directories under ",(0,s.jsx)(n.code,{children:"packages/"})," returns nothing."]}),"\n",(0,s.jsx)(n.li,{children:"There is no shared digest registry, and Lefthook cannot assert that authored JSON matches committed outputs because none exist yet."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"5-target-architecture",children:"5. Target Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"51-package-layout--ownership",children:"5.1 Package Layout & Ownership"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@idle-engine/content-compiler"})," will live in ",(0,s.jsx)(n.code,{children:"packages/content-compiler"})," and provide two public entrypoints:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"index.ts"})," (Node-only) exposes compiler APIs and filesystem helpers."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"runtime.ts"})," (browser-safe) exposes rehydration utilities without importing ",(0,s.jsx)(n.code,{children:"node:"})," modules so web bundles stay lean."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Planned layout:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"packages/content-compiler/\n  package.json\n  src/\n    index.ts\n    runtime.ts\n    compiler/\n      pipeline.ts\n      context.ts\n    artifacts/\n      json.ts\n      module.ts\n      summary.ts\n    fs/\n      discovery.ts\n      writer.ts\n    hashing.ts\n    logging.ts\n    types.ts\n    __tests__/\n      compiler.test.ts\n      artifacts.test.ts\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"package.json"})," publishes an explicit ",(0,s.jsx)(n.code,{children:"exports"})," map to prevent bundlers from pulling Node code into browser builds:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "exports": {\n    ".": { "import": "./dist/index.js", "types": "./dist/index.d.ts" },\n    "./runtime": { "import": "./dist/runtime.js", "types": "./dist/runtime.d.ts" },\n    "./package.json": "./package.json"\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["To share digest logic without bundling the full schema implementation, ",(0,s.jsx)(n.code,{children:"@idle-engine/content-schema"})," now publishes a ",(0,s.jsx)(n.code,{children:"runtime-helpers"})," export that surfaces ",(0,s.jsx)(n.code,{children:"createContentPackDigest"}),", freeze helpers, and associated types. The compiler package depends on that entrypoint so hashing stays consistent across the workspace. Splitting orchestration from artifact emitters mirrors the manifest-driven content pipeline described in ",(0,s.jsx)(n.a,{href:"https://medium.com/@heinapurola/engine-internals-content-pipeline-1af34a117f1",children:"Engine Internals: Content Pipeline"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"52-public-api-surface",children:"5.2 Public API Surface"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@idle-engine/content-compiler"})," will export:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compileContentPack(document: ContentDocument, options: CompileOptions): Promise<PackArtifactResult>"})," \u2013 compile a single document and return artifact buffers plus metadata."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compileWorkspacePacks(fs: WorkspaceFS, options: CompileWorkspaceOptions): Promise<WorkspaceCompileResult>"})," \u2013 orchestrate discovery, compilation, pruning, logging, and summary emission for all packs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rehydrateNormalizedPack(serialized: SerializedNormalizedContentPack, options?: RehydrateOptions): NormalizedContentPack"})," \u2013 rebuild lookup structures in browser or server runtimes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"createModuleIndices(pack: NormalizedContentPack): Readonly<ModuleIndexTables>"})," \u2013 derive positional indices from frozen module arrays."]}),"\n",(0,s.jsxs)(n.li,{children:["Types for ",(0,s.jsx)(n.code,{children:"ContentDocument"}),", ",(0,s.jsx)(n.code,{children:"SerializedNormalizedContentPack"}),", ",(0,s.jsx)(n.code,{children:"CompileLogEvent"}),", and ",(0,s.jsx)(n.code,{children:"WorkspaceSummary"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ModuleIndexTables"})," is defined as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export interface ModuleIndexTables {\n  readonly resources: ReadonlyMap<string, number>;\n  readonly generators: ReadonlyMap<string, number>;\n  readonly upgrades: ReadonlyMap<string, number>;\n  readonly metrics: ReadonlyMap<string, number>;\n  readonly achievements: ReadonlyMap<string, number>;\n  readonly automations: ReadonlyMap<string, number>;\n  readonly transforms: ReadonlyMap<string, number>;\n  readonly prestigeLayers: ReadonlyMap<string, number>;\n  readonly guildPerks: ReadonlyMap<string, number>;\n  readonly runtimeEvents: ReadonlyMap<string, number>;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"createModuleIndices"})," preserves the ordering of the serialized module arrays, so each map's numeric value matches the zero-based offset in the corresponding array."]}),"\n",(0,s.jsx)(n.h3,{id:"53-compilation-workflow",children:"5.3 Compilation Workflow"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Discover packs"})," \u2013 scan ",(0,s.jsx)(n.code,{children:"packages/*/content/pack.json"}),", mirroring the manifest generator\u2019s discovery rules. Each file becomes a ",(0,s.jsx)(n.code,{children:"ContentDocument"})," with absolute path, POSIX-relative path, slug (derived from ",(0,s.jsx)(n.code,{children:"metadata.id"}),"), and parsed JSON:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface ContentDocument {\n  readonly absolutePath: string;\n  readonly relativePath: string;\n  readonly packSlug: string;\n  readonly document: unknown;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Duplicate slugs emit a ",(0,s.jsx)(n.code,{children:"content_pack.compilation_failed"})," event and abort the run before any artifacts are written so collisions cannot clobber outputs. Discovery also records every ",(0,s.jsx)(n.code,{children:"metadata.id"})," and source path in a collision registry used later when verifying digests, following the hash-audit guidance in ",(0,s.jsx)(n.a,{href:"https://cowboyprogramming.com/2007/01/04/practical-hash-ids/",children:"Practical Hash IDs"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Prepare context"})," \u2013 reuse the manifest definitions that ",(0,s.jsx)(n.code,{children:"tools/content-schema-cli"})," already constructs to populate ",(0,s.jsx)(n.code,{children:"ContentSchemaOptions"})," (",(0,s.jsx)(n.code,{children:"runtimeEventCatalogue"}),", ",(0,s.jsx)(n.code,{children:"knownPacks"}),", ",(0,s.jsx)(n.code,{children:"activePackIds"}),"). The CLI passes these definitions to the compiler so consumers do not import ",(0,s.jsx)(n.code,{children:"GENERATED_RUNTIME_EVENT_DEFINITIONS"})," directly."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Validate and normalize"})," \u2013 call ",(0,s.jsx)(n.code,{children:"parseContentPack(document, options)"})," exactly once per pack. Persist both the returned ",(0,s.jsx)(n.code,{children:"NormalizedContentPack"})," and the ",(0,s.jsx)(n.code,{children:"warnings"})," array so downstream steps can surface severities without re-running schema logic."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Serialize to compiled payloads"})," \u2013 convert each ",(0,s.jsx)(n.code,{children:"NormalizedContentPack"})," into a serializable shape:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface SerializedNormalizedContentPack {\n  readonly formatVersion: 1;\n  readonly metadata: NormalizedMetadata;\n  readonly warnings: readonly SerializedContentSchemaWarning[];\n  readonly modules: {\n    readonly resources: readonly NormalizedResource[];\n    readonly generators: readonly NormalizedGenerator[];\n    readonly upgrades: readonly NormalizedUpgrade[];\n    readonly metrics: readonly NormalizedMetric[];\n    readonly achievements: readonly NormalizedAchievement[];\n    readonly automations: readonly NormalizedAutomation[];\n    readonly transforms: readonly NormalizedTransform[];\n    readonly prestigeLayers: readonly NormalizedPrestigeLayer[];\n    readonly guildPerks: readonly NormalizedGuildPerk[];\n    readonly runtimeEvents: readonly NormalizedRuntimeEventContribution[];\n  };\n  readonly digest: NormalizedContentPack['digest'];\n  readonly artifactHash: string;\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\n `SerializedContentSchemaWarning` copies the schema warning properties onto plain data objects so JSON consumers can read them without prototype baggage. Lookup maps and positional indices are intentionally excluded; they are regenerated during rehydration to preserve referential identity.\n Dependency data remains anchored in `metadata.dependencies` so there is a single source of truth for downstream tooling ([What Is a Single Source of Truth?](https://maddevs.io/glossary/single-source-of-truth/)).\n\n5. **Emit artifacts** \u2013 hand each payload to dedicated emitters that produce:\n - Canonical JSON: `packages/<pack>/content/compiled/<packSlug>.normalized.json`.\n - Generated modules: `packages/<pack>/src/generated/<packSlug>.generated.ts`.\n - Workspace summary: `<repo>/content/compiled/index.json`.\n\n Before writing, the compiler compares the current discovery set against existing artifacts and removes any JSON/TypeScript files for packs that disappeared so stale outputs do not linger. Writes go through a temporary file in the target directory followed by an atomic rename to avoid torn files, per the recommendations in [Atomic file creation with temporary files](https://yakking.branchable.com/posts/atomic-file-creation-tmpfile/). If the newly generated bytes match what already exists, the writer skips the rename entirely to minimize churn and keep incremental builds fast, aligning with Unity's incremental pipeline guidance ([Unity Incremental Build Pipeline](https://docs.unity3d.com/Manual/incremental-build-pipeline.html)).\n\n If `compileContentPack` throws or returns a failure state, the compiler deletes any existing `content/compiled/<slug>.normalized.json` and `src/generated/<slug>.generated.ts` artifacts before moving on. A `--check` run surfaces the removal as a drift so CI fails visibly, and the workspace summary records the failure to stop automation from silently using stale modules.\n\n The CLI never lets compilation run ahead of validation. `pnpm generate` persists a validation failure summary and exits early when schema checks break, and `--check` mode flags the run as drifted whenever that summary would change. This sequencing guarantees validation remains the gatekeeper for every artifact write.\n\n6. **Log results** \u2013 emit machine-readable JSON events (`content_pack.compiled`, `content_pack.compilation_failed`, `content_pack.skipped`, `content_pack.pruned`) that include slug, duration, warning counts, and artifact paths. Validation emits its own `content_pack.validated` / `.validation_failed` events before compilation begins so log consumers can correlate outcomes end-to-end. Watch mode adds a `watch.run` event after each iteration with duration, trigger paths, and outcome to simplify monitoring. Logs follow structured logging practices that favor JSON key/value payloads for downstream parsing ([9 Logging Best Practices You Should Know](https://www.dash0.com/guides/logging-best-practices), [Best Practices for Analyzing Logs in Data Pipelines](https://blog.dreamfactory.com/best-practices-for-analyzing-logs-in-data-pipelines)).\n\n### 5.4 Artifact Contracts\n\n- **Normalized JSON (`content/compiled/*.normalized.json`)**\n- Contains the exact `SerializedNormalizedContentPack` shape with canonical key ordering and a trailing newline to keep diffs legible.\n- Serves as the source of truth for `pnpm generate --check`, documentation tooling, and automation that needs raw JSON.\n- Embeds `warnings`, `digest`, and `artifactHash` so checks can fail without invoking the compiler.\n- Files live beside their originating pack to keep review diffs local to the owning package.\n\n- **Generated TypeScript modules (`src/generated/*.generated.ts`)**\n\n```ts\nimport {\n  createModuleIndices,\n  rehydrateNormalizedPack,\n  type SerializedNormalizedContentPack,\n} from '@idle-engine/content-compiler/runtime';\n\nconst serialized: SerializedNormalizedContentPack = { /* inlined JSON */ };\n\nconst runtimeEnv = (globalThis as typeof globalThis & {\n  process?: { env?: Record<string, string | undefined> };\n}).process;\n\nconst shouldVerifyDigest = runtimeEnv?.env?.NODE_ENV !== 'production';\n\nexport const SAMPLE_PACK = rehydrateNormalizedPack(serialized, {\n  verifyDigest: shouldVerifyDigest,\n});\nexport const SAMPLE_PACK_DIGEST = serialized.digest;\nexport const SAMPLE_PACK_ARTIFACT_HASH = serialized.artifactHash;\nexport const SAMPLE_PACK_INDICES = createModuleIndices(SAMPLE_PACK);\nexport const SAMPLE_PACK_SUMMARY = Object.freeze({\n  slug: serialized.metadata.id,\n  version: serialized.metadata.version,\n  resourceIds: serialized.modules.resources.map((resource) => resource.id),\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"rehydrateNormalizedPack"})," (implemented in ",(0,s.jsx)(n.code,{children:"runtime.ts"}),") reconstructs lookup maps, freezes arrays, and\u2014when ",(0,s.jsx)(n.code,{children:"verifyDigest"})," is true\u2014recomputes the digest (artifact hash verification is planned as a follow-up in #159). ",(0,s.jsx)(n.code,{children:"createModuleIndices"})," iterates the frozen module arrays, asserts identifier uniqueness, and returns immutable lookup tables so runtime code can map identifiers to array offsets without recomputing them on startup. ",(0,s.jsx)(n.code,{children:"SAMPLE_PACK_INDICES.generators.get('starter-generator')"})," returns the array index inside ",(0,s.jsx)(n.code,{children:"SAMPLE_PACK.generators"}),", allowing consumers to map ids to offsets without recomputing lookup tables.\nThe ",(0,s.jsx)(n.code,{children:"verifyDigest"})," guard inspects ",(0,s.jsx)(n.code,{children:"globalThis.process?.env"})," when present instead of assuming ",(0,s.jsx)(n.code,{children:"import.meta.env"}),", preventing runtime errors in environments that do not expose the Vite-style global (",(0,s.jsx)(n.a,{href:"https://discourse.wicg.io/t/should-the-browser-consider-an-import-meta-env-object/4522/",children:"Should the browser consider an import.meta.env object?"}),").\n",(0,s.jsx)(n.code,{children:"@idle-engine/content-sample/src/index.ts"})," aliases these exports to ergonomic runtime names (",(0,s.jsx)(n.code,{children:"sampleContent"}),", ",(0,s.jsx)(n.code,{children:"sampleContentSummary"}),", ",(0,s.jsx)(n.code,{children:"sampleContentIndices"}),", etc.) and throws whenever the compiler recorded warnings so existing guardrails remain in place without reparsing authoring JSON."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Workspace summary (",(0,s.jsx)(n.code,{children:"content/compiled/index.json"}),")"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Resides at the repository root and lists every compiled pack with slug, version, digest, artifact hash, dependency set (sourced from ",(0,s.jsx)(n.code,{children:"metadata.dependencies"}),"), warning count, and artifact paths."]}),"\n",(0,s.jsxs)(n.li,{children:["Serves as the canonical workspace index for automation, docs, and runtime bootstrapping. Consumers must treat the file as stale whenever validation fails or the CLI reports drift and rerun ",(0,s.jsx)(n.code,{children:"pnpm generate"})," before relying on the data."]}),"\n",(0,s.jsx)(n.li,{children:"Doubles as the collision manifest: the compiler records when two packs share a digest or dependency and emits warnings immediately."}),"\n",(0,s.jsxs)(n.li,{children:["Drives documentation tooling and allows ",(0,s.jsx)(n.code,{children:"pnpm generate --check"})," to diff a single file to detect drift."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"55-determinism--integrity",children:"5.5 Determinism & Integrity"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["JSON emitters use a stable RFC-8785 compatible stringifier so repeated runs produce byte-identical output. The digest stays aligned with the schema package by deferring to ",(0,s.jsx)(n.code,{children:"createContentPackDigest"})," from the new ",(0,s.jsx)(n.code,{children:"runtime-helpers"})," export."]}),"\n",(0,s.jsxs)(n.li,{children:["Writers operate on temporary files located in the target directory and complete writes with ",(0,s.jsx)(n.code,{children:"fs.rename"}),", guaranteeing atomic replacements even when the process crashes mid-write (",(0,s.jsx)(n.a,{href:"https://yakking.branchable.com/posts/atomic-file-creation-tmpfile/",children:"Atomic file creation with temporary files"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pnpm generate --check"})," recompiles without writing files and exits with status ",(0,s.jsx)(n.code,{children:"1"})," if any artifact would change, enabling Lefthook and CI to fail fast on stale outputs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pnpm generate --clean"})," invalidates any cached comparisons and forces rewrites, providing the clean-build escape hatch recommended for incremental pipelines (",(0,s.jsx)(n.a,{href:"https://docs.unity3d.com/Manual/incremental-build-pipeline.html",children:"Unity Incremental Build Pipeline"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Nightly determinism checks rerun ",(0,s.jsx)(n.code,{children:"pnpm generate --check"})," twice in isolated working directories (incremental vs clean) and compare summary hashes, following the strategy outlined in ",(0,s.jsx)(n.a,{href:"https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html",children:"Deterministic builds with clang and lld"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The workspace summary omits wall-clock timestamps so artifacts remain byte-identical across runs, in line with reproducible-build guidance to remove timestamp variability (",(0,s.jsx)(n.a,{href:"https://reproducible-builds.org/docs/deterministic-build-systems/",children:"Deterministic build systems"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"551-artifact-integrity-contract",children:"5.5.1 Artifact Integrity Contract"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"artifactHash"})," is the lowercase hex encoding of the SHA-256 hash of the RFC-8785 canonical JSON representation of the complete ",(0,s.jsx)(n.code,{children:"SerializedNormalizedContentPack"}),", computed with ",(0,s.jsx)(n.code,{children:"artifactHash"})," temporarily set to the empty string.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The compiler canonicalizes a clone of the payload with the hash cleared, hashes those bytes, and then writes the emitted JSON with the computed hash reinserted. Integrity checks repeat the same \u201cblank then canonicalize\u201d procedure before hashing."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rehydrateNormalizedPack"})," recomputes the digest when ",(0,s.jsx)(n.code,{children:"verifyDigest"})," is enabled (artifact hash validation will land alongside the canonical serializer upgrades tracked in #159)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"formatVersion"})," changes whenever the serialized payload shape or canonicalization rules change. When ",(0,s.jsx)(n.code,{children:"formatVersion"})," increments, the compiler writes new artifacts and the runtime refuses to rehydrate packs whose ",(0,s.jsx)(n.code,{children:"formatVersion"})," it does not understand."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"digest"})," remains the schema-defined content identity (used for dependency tracking, change detection, and collision reporting). ",(0,s.jsx)(n.code,{children:"artifactHash"})," guarantees the integrity of the compiled artifact itself. Automation treats ",(0,s.jsx)(n.code,{children:"digest"})," drift as a semantic change in content, while ",(0,s.jsx)(n.code,{children:"artifactHash"})," mismatches indicate corrupted or stale build output."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"56-dependency-handling",children:"5.6 Dependency Handling"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The compiler resolves pack order with a topological sort on ",(0,s.jsx)(n.code,{children:"metadata.dependencies.requires"}),", ensuring dependants always compile after their prerequisites (",(0,s.jsx)(n.a,{href:"https://ipython-books.github.io/143-resolving-dependencies-in-a-directed-acyclic-graph-with-a-topological-sort/",children:"IPython Cookbook - Resolving dependencies in a directed acyclic graph"}),")."]}),"\n",(0,s.jsx)(n.li,{children:"Missing dependencies trigger warnings and mark the pack as failed; the summary captures the failure so automation can highlight the gap."}),"\n",(0,s.jsxs)(n.li,{children:["Dependency cycles emit a single ",(0,s.jsx)(n.code,{children:"content_pack.compilation_failed"})," event listing every slug in the loop and aborting the run before artifacts are written."]}),"\n",(0,s.jsx)(n.li,{children:"The workspace summary records dependency digests so CI can detect mismatches when a referenced pack changed but a dependant did not rebuild."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"57-logging--telemetry",children:"5.7 Logging & Telemetry"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Every compiler run writes structured JSON lines to stdout; human-friendly pretty-printing remains opt-in via ",(0,s.jsx)(n.code,{children:"--pretty"}),". Each event includes an ISO timestamp, event name, slug, duration, warning count, and file paths. Structured payloads make it trivial for log processors to filter on keys rather than regex parsing (",(0,s.jsx)(n.a,{href:"https://www.dash0.com/guides/logging-best-practices",children:"9 Logging Best Practices You Should Know"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Event schema:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"content_pack.compiled"}),": success path with ",(0,s.jsx)(n.code,{children:"artifacts"}),", ",(0,s.jsx)(n.code,{children:"warnings"}),", ",(0,s.jsx)(n.code,{children:"durationMs"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"content_pack.compilation_failed"}),": failure details with ",(0,s.jsx)(n.code,{children:"message"}),", ",(0,s.jsx)(n.code,{children:"path"}),", ",(0,s.jsx)(n.code,{children:"issues"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"content_pack.pruned"}),": emitted when stale artifacts are deleted."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"content_pack.skipped"}),": emitted when ",(0,s.jsx)(n.code,{children:"--check"})," detects no changes."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Logs integrate with existing CI parsers and future observability services without additional adapters."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"58-developer-experience--adoption",children:"5.8 Developer Experience & Adoption"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tools/content-schema-cli"})," gains a ",(0,s.jsx)(n.code,{children:"compile"})," command (",(0,s.jsx)(n.code,{children:"pnpm --filter @idle-engine/content-validation-cli run compile"}),") and updates ",(0,s.jsx)(n.code,{children:"generate"})," to execute manifest regeneration \u2192 validation \u2192 compilation in order."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"--watch"})," uses ",(0,s.jsx)(n.code,{children:"chokidar"})," to observe authoring JSON and schema inputs, debouncing writes and ignoring compiler-owned outputs (",(0,s.jsx)(n.code,{children:"**/content/compiled/**"}),", ",(0,s.jsx)(n.code,{children:"**/src/generated/*.generated.ts"}),") to avoid loops."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"packages/content-sample"})," switches to importing the generated module, keeping the direct JSON import only as a fallback test helper."]}),"\n",(0,s.jsxs)(n.li,{children:["Documentation (",(0,s.jsx)(n.code,{children:"docs/content-schema-rollout-decisions.md"}),", ",(0,s.jsx)(n.code,{children:"docs/implementation-plan.md"}),") and READMEs will be updated once the compiler ships, so contributors know to run ",(0,s.jsx)(n.code,{children:"pnpm generate"})," after editing content."]}),"\n",(0,s.jsxs)(n.li,{children:["Lefthook gains a ",(0,s.jsx)(n.code,{children:"content"})," hook that runs ",(0,s.jsx)(n.code,{children:"pnpm generate --check"})," to guard against stale artifacts before commit."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"6-implementation-plan",children:"6. Implementation Plan"}),"\n",(0,s.jsx)(n.h3,{id:"phase-1---package-foundations",children:"Phase 1 - Package Foundations"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Scaffold ",(0,s.jsx)(n.code,{children:"packages/content-compiler"}),", add build tooling, exports map, and baseline tests."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Add ",(0,s.jsx)(n.code,{children:"runtime-helpers"})," export to ",(0,s.jsx)(n.code,{children:"@idle-engine/content-schema"})," with shared digest utilities."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement discovery, context preparation, and single-pack compilation APIs."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-2---artifact-emitters--cli-wiring",children:"Phase 2 - Artifact Emitters & CLI Wiring"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement canonical JSON and TypeScript emitters with stable ordering, digest calculation, and atomic writes."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Extend ",(0,s.jsx)(n.code,{children:"tools/content-schema-cli"})," with the new compiler command, integrate logs, and update ",(0,s.jsx)(n.code,{children:"pnpm generate"})," to run validation and compilation sequentially."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Persist structured warnings in per-pack artifacts and the workspace summary."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"--check"}),", ",(0,s.jsx)(n.code,{children:"--clean"}),", and artifact pruning; ensure Lefthook/CI adopt the new verification step."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-3---developer-experience--adoption",children:"Phase 3 - Developer Experience & Adoption"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement watch mode with debounced recompilation and change detection."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Update ",(0,s.jsx)(n.code,{children:"packages/content-sample"})," (and any other consumers) to import generated artifacts."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Backfill documentation and onboarding guides with compiler usage and troubleshooting tips."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"7-success-criteria",children:"7. Success Criteria"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Every pack produces ",(0,s.jsx)(n.code,{children:"content/compiled/*.normalized.json"})," and ",(0,s.jsx)(n.code,{children:"src/generated/*.generated.ts"})," without manual intervention."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pnpm generate"})," emits ",(0,s.jsx)(n.code,{children:"content_pack.*"})," events, fails when artifacts drift, and ",(0,s.jsx)(n.code,{children:"--check"})," exits non-zero on stale outputs."]}),"\n",(0,s.jsxs)(n.li,{children:["Runtime consumers no longer call ",(0,s.jsx)(n.code,{children:"parseContentPack"})," at import time; they rely on generated modules and rehydration helpers."]}),"\n",(0,s.jsx)(n.li,{children:"Consecutive compiler runs with unchanged inputs produce no git diffs and skip file rewrites."}),"\n",(0,s.jsx)(n.li,{children:"Removing a pack deletes its compiled artifacts within the same run that detects the removal."}),"\n",(0,s.jsxs)(n.li,{children:["Compiler unit tests and CLI smoke tests run under ",(0,s.jsx)(n.code,{children:"pnpm test"})," and ",(0,s.jsx)(n.code,{children:"pnpm lint"}),"; CI passes with the determinism check enabled."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"8-open-questions",children:"8. Open Questions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Formula precomputation:"})," Is there value in capturing precomputed coefficients for common formula types during compilation, or should that remain a separate optimization pass?"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Artifact granularity:"})," Do documentation tools need per-module JSON (e.g., ",(0,s.jsx)(n.code,{children:"resources.json"}),") in addition to the consolidated pack payload?"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bundle outputs:"})," Should the compiler emit optional multi-pack bundles (e.g., seasonal content sets), or is the workspace summary sufficient for the current roadmap?"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"9-references",children:"9. References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"docs/content-dsl-schema-design.md"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"docs/content-schema-rollout-decisions.md"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"docs/idle-engine-design.md"})," \xa76.2"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"docs/runtime-command-queue-design.md"})," \xa713"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"tools/content-schema-cli/src/generate.js"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"packages/content-schema/src/pack.ts"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"packages/content-sample/src/index.ts"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.unity3d.com/Manual/incremental-build-pipeline.html",children:"Unity Incremental Build Pipeline"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://cowboyprogramming.com/2007/01/04/practical-hash-ids/",children:"Practical Hash IDs (Cowboy Programming)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://blog.llvm.org/2019/11/deterministic-builds-with-clang-and-lld.html",children:"Deterministic builds with clang and lld"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://blog.dreamfactory.com/best-practices-for-analyzing-logs-in-data-pipelines",children:"Best Practices for Analyzing Logs in Data Pipelines"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.dash0.com/guides/logging-best-practices",children:"9 Logging Best Practices You Should Know"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://yakking.branchable.com/posts/atomic-file-creation-tmpfile/",children:"Atomic file creation with temporary files"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://ipython-books.github.io/143-resolving-dependencies-in-a-directed-acyclic-graph-with-a-topological-sort/",children:"IPython Cookbook - Resolving dependencies in a directed acyclic graph with a topological sort"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://medium.com/@heinapurola/engine-internals-content-pipeline-1af34a117f1",children:"Engine Internals: Content Pipeline"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reproducible-builds.org/docs/deterministic-build-systems/",children:"Deterministic build systems"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://maddevs.io/glossary/single-source-of-truth/",children:"What Is a Single Source of Truth?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://discourse.wicg.io/t/should-the-browser-consider-an-import-meta-env-object/4522/",children:"Should the browser consider an import.meta.env object?"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},7678:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(9430);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);