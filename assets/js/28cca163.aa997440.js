"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[9384],{2158:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"tick-accumulator-coverage-design","title":"Tick Accumulator Edge Case Coverage","description":"Issue: #10","source":"@site/../../docs/tick-accumulator-coverage-design.md","sourceDirName":".","slug":"/tick-accumulator-coverage-design","permalink":"/Idle-Game-Engine/tick-accumulator-coverage-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/tick-accumulator-coverage-design.md","tags":[],"version":"current","frontMatter":{},"sidebar":"developerSidebar","previous":{"title":"Runtime Event Manifest Authoring","permalink":"/Idle-Game-Engine/runtime-event-manifest-authoring"},"next":{"title":"Resource State Storage Design","permalink":"/Idle-Game-Engine/resource-state-storage-design"}}');var i=s(5270),r=s(7678);const c={},a="Tick Accumulator Edge Case Coverage",o={},l=[{value:"1. Problem Statement",id:"1-problem-statement",level:2},{value:"2. Goals",id:"2-goals",level:2},{value:"3. Non-Goals",id:"3-non-goals",level:2},{value:"4. Current State",id:"4-current-state",level:2},{value:"5. Proposed Tests",id:"5-proposed-tests",level:2},{value:"5.1 Clamp backlog telemetry",id:"51-clamp-backlog-telemetry",level:3},{value:"5.2 Backlog drain sequence",id:"52-backlog-drain-sequence",level:3},{value:"5.3 Fractional step precision",id:"53-fractional-step-precision",level:3},{value:"6. Implementation Notes",id:"6-implementation-notes",level:2},{value:"7. Risks &amp; Mitigations",id:"7-risks--mitigations",level:2},{value:"8. Rollout Steps",id:"8-rollout-steps",level:2},{value:"9. Open Questions",id:"9-open-questions",level:2},{value:"10. Acceptance Criteria",id:"10-acceptance-criteria",level:2}];function d(e){const t={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"tick-accumulator-edge-case-coverage",children:"Tick Accumulator Edge Case Coverage"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Issue:"})," #10",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.strong,{children:"Workstream:"})," Runtime Core",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.strong,{children:"Status:"})," Design",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.strong,{children:"Last Updated:"})," 2025-10-18"]}),"\n",(0,i.jsx)(t.h2,{id:"1-problem-statement",children:"1. Problem Statement"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The fixed-step accumulator in ",(0,i.jsx)(t.code,{children:"IdleEngineRuntime.tick"})," (packages/core/src/index.ts) keeps the simulation deterministic when host frame timings jitter, yet only basic happy-path behaviour is currently exercised."]}),"\n",(0,i.jsxs)(t.li,{children:["Existing tests confirm command execution order and simple fractional carry-over, but they never validate the backlog telemetry or precision guarantees that ",(0,i.jsx)(t.code,{children:"docs/idle-engine-design.md"})," \xa79.1 depends on."]}),"\n",(0,i.jsx)(t.li,{children:"Without explicit coverage of clamp and drift scenarios, scheduler or diagnostics changes could silently break offline catch-up, spiral-of-death protections, or the devtools timeline consumers rely on."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"2-goals",children:"2. Goals"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Assert that when ",(0,i.jsx)(t.code,{children:"maxStepsPerFrame"})," clamps execution, the accumulator remainder reported through diagnostics matches the mathematical expectation."]}),"\n",(0,i.jsx)(t.li,{children:"Prove that backlog debt drains deterministically once host delta stabilises, preventing unbounded carry-over."}),"\n",(0,i.jsx)(t.li,{children:"Verify that fractional step sizes (e.g., 1000 / 60 ms) do not accumulate floating-point drift across many frames and keep backlog within a tight tolerance."}),"\n",(0,i.jsx)(t.li,{children:"Exercise the diagnostics delta reader so regressions in timeline metadata emission are caught by the unit suite."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"3-non-goals",children:"3. Non-Goals"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Introduce new runtime configuration knobs or observable API changes."}),"\n",(0,i.jsx)(t.li,{children:"Cover worker bridge, shell UI integration, or command queue correctness beyond what is required for accumulator checks."}),"\n",(0,i.jsx)(t.li,{children:"Benchmark performance or profile timeline overhead; this effort is test-only."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"4-current-state",children:"4. Current State"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"packages/core/src/index.test.ts"})," already verifies step clamping, command scheduling, and a basic ",(0,i.jsx)(t.code,{children:'"accumulates fractional time"'})," scenario, but never inspects accumulator state or diagnostics output."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"packages/core/src/devtools/diagnostics.test.ts"})," formats backlog metadata with mocked entries; no test ensures the runtime actually emits that data."]}),"\n",(0,i.jsxs)(t.li,{children:["The diagnostics controller (",(0,i.jsx)(t.code,{children:"packages/core/src/diagnostics/runtime-diagnostics-controller.ts"}),") forwards ",(0,i.jsx)(t.code,{children:"setAccumulatorBacklogMs"}),", yet no assertion fails if the value drifts or disappears."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"5-proposed-tests",children:"5. Proposed Tests"}),"\n",(0,i.jsx)(t.h3,{id:"51-clamp-backlog-telemetry",children:"5.1 Clamp backlog telemetry"}),"\n",(0,i.jsxs)(t.p,{children:["Instantiate an ",(0,i.jsx)(t.code,{children:"IdleEngineRuntime"})," with ",(0,i.jsx)(t.code,{children:"stepSizeMs: 10"}),", ",(0,i.jsx)(t.code,{children:"maxStepsPerFrame: 2"}),", and the diagnostics timeline enabled (capacity \u2265 8, deterministic ",(0,i.jsx)(t.code,{children:"clock.now"}),"). Call ",(0,i.jsx)(t.code,{children:"tick(45)"})," once. Expect ",(0,i.jsx)(t.code,{children:"currentStep"})," and ",(0,i.jsx)(t.code,{children:"nextExecutableStep"})," to advance to 2, and ",(0,i.jsx)(t.code,{children:"readDiagnosticsDelta(previousHead).entries"})," to contain two records whose ",(0,i.jsx)(t.code,{children:"metadata.accumulatorBacklogMs"})," equals ",(0,i.jsx)(t.code,{children:"25"})," while queue metrics remain zero. This exercises the clamp path and confirms the remainder surfaces through diagnostics."]}),"\n",(0,i.jsx)(t.h3,{id:"52-backlog-drain-sequence",children:"5.2 Backlog drain sequence"}),"\n",(0,i.jsxs)(t.p,{children:["Using a fresh runtime configured as above, invoke ticks with deltas ",(0,i.jsx)(t.code,{children:"[45, 10, 10, 5]"}),", capturing the timeline delta after each frame. The recorded backlog sequence should be ",(0,i.jsx)(t.code,{children:"[25, 15, 5, 0]"}),", and ",(0,i.jsx)(t.code,{children:"currentStep"})," should advance by ",(0,i.jsx)(t.code,{children:"[2, 2, 2, 1]"})," for a total of 7. This demonstrates deterministic debt reduction once the host stops overshooting and ensures the accumulator never underflows."]}),"\n",(0,i.jsx)(t.h3,{id:"53-fractional-step-precision",children:"5.3 Fractional step precision"}),"\n",(0,i.jsxs)(t.p,{children:["Construct a runtime with ",(0,i.jsx)(t.code,{children:"stepSizeMs = 1000 / 60"}),", ",(0,i.jsx)(t.code,{children:"maxStepsPerFrame: 6"}),", and timeline capacity \u2265 128. Loop 60 times, invoking ",(0,i.jsx)(t.code,{children:"tick(stepSizeMs)"}),". After the loop, assert ",(0,i.jsx)(t.code,{children:"currentStep === nextExecutableStep === 60"})," and the latest backlog reported by diagnostics stays below 1e-6 ms (using ",(0,i.jsx)(t.code,{children:"toBeCloseTo"})," for safety). This safeguards the floating-point carry logic against regression when alternative cadence (e.g., 60 Hz) is configured."]}),"\n",(0,i.jsx)(t.h2,{id:"6-implementation-notes",children:"6. Implementation Notes"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Extend the existing ",(0,i.jsx)(t.code,{children:"createRuntime"})," helper in ",(0,i.jsx)(t.code,{children:"packages/core/src/index.test.ts"})," to accept diagnostics overrides and to surface the runtime head index for timeline reads."]}),"\n",(0,i.jsxs)(t.li,{children:["Provide a tiny local utility (e.g., ",(0,i.jsx)(t.code,{children:"readBacklog(runtime, head)"}),") that wraps ",(0,i.jsx)(t.code,{children:"readDiagnosticsDelta"})," and returns ",(0,i.jsx)(t.code,{children:"{ entries, head }"})," so tests can chain delta reads without repeating boilerplate."]}),"\n",(0,i.jsxs)(t.li,{children:["Use a deterministic ",(0,i.jsx)(t.code,{children:"HighResolutionClock"})," stub returning monotonically increasing integers to keep durations zero while preserving order; the tests only care about backlog metadata."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"7-risks--mitigations",children:"7. Risks & Mitigations"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Floating-point tolerance drift:"})," Use ",(0,i.jsx)(t.code,{children:"toBeCloseTo"})," with an epsilon (1e-6) instead of strict equality so the fractional-step test stays stable across JS engines."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Timeline capacity wrap-around:"})," Configure capacities \u2265 number of expected entries (8 and 128) to avoid dropped records; add an assertion that ",(0,i.jsx)(t.code,{children:"dropped === 0"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Diagnostic overhead in tests:"})," Each runtime instance is short-lived and exercises at most a dozen ticks, so the additional timeline bookkeeping should keep Vitest runtimes negligible (under 5 ms per test)."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"8-rollout-steps",children:"8. Rollout Steps"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Update the test helper and add the backlog reader utility in ",(0,i.jsx)(t.code,{children:"packages/core/src/index.test.ts"}),"."]}),"\n",(0,i.jsx)(t.li,{children:"Implement the three Vitest cases described above, keeping assertions focused on accumulator behaviour."}),"\n",(0,i.jsxs)(t.li,{children:["Run ",(0,i.jsx)(t.code,{children:"pnpm test --filter @idle-engine/core"})," locally and ensure Lefthook\u2019s ",(0,i.jsx)(t.code,{children:"pnpm test:ci"})," passes."]}),"\n",(0,i.jsxs)(t.li,{children:["Cross-link the new coverage in ",(0,i.jsx)(t.code,{children:"docs/runtime-command-queue-design.md"})," Appendix A when landing the change."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"9-open-questions",children:"9. Open Questions"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Should we assert telemetry counters (e.g., ",(0,i.jsx)(t.code,{children:"telemetry.recordTick"}),") alongside diagnostics to guarantee both pathways stay aligned?"]}),"\n",(0,i.jsxs)(t.li,{children:["Do we want to expose a small runtime test helper for backlog reads in other suites, or keep the utility local to ",(0,i.jsx)(t.code,{children:"index.test.ts"})," for now?"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"10-acceptance-criteria",children:"10. Acceptance Criteria"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["New Vitest cases verify clamp backlog values, backlog drainage, and fractional cadence precision in ",(0,i.jsx)(t.code,{children:"packages/core/src/index.test.ts"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Diagnostics delta assertions fail if ",(0,i.jsx)(t.code,{children:"metadata.accumulatorBacklogMs"})," is missing or diverges from the expected remainder."]}),"\n",(0,i.jsx)(t.li,{children:"The fractional-step test leaves accumulator debt below 1e-6 ms after 60 frames."}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"pnpm test --filter @idle-engine/core"})," (and the broader ",(0,i.jsx)(t.code,{children:"pnpm test:ci"}),") completes without regressions."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},7678:(e,t,s)=>{s.d(t,{R:()=>c,x:()=>a});var n=s(9430);const i={},r=n.createContext(i);function c(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);