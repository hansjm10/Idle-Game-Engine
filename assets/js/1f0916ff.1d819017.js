"use strict";(globalThis.webpackChunk_idle_engine_docs=globalThis.webpackChunk_idle_engine_docs||[]).push([[1522],{4473:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>t});const s=JSON.parse('{"id":"issue-814-design","title":"renderer-contract/webgpu: include camera state in RCB for replay correctness (Issue 814)","description":"Document Control","source":"@site/../../docs/issue-814-design.md","sourceDirName":".","slug":"/issue-814-design","permalink":"/Idle-Game-Engine/issue-814-design","draft":false,"unlisted":false,"editUrl":"https://github.com/hansjm10/Idle-Game-Engine/edit/main/docs/../../docs/issue-814-design.md","tags":[],"version":"current","sidebarPosition":99,"frontMatter":{"title":"renderer-contract/webgpu: include camera state in RCB for replay correctness (Issue 814)","sidebar_position":99}}');var i=r(5270),d=r(7678);const c={title:"renderer-contract/webgpu: include camera state in RCB for replay correctness (Issue 814)",sidebar_position:99},l="renderer-contract/webgpu: include camera state in RCB for replay correctness (Issue 814)",a={},t=[{value:"Document Control",id:"document-control",level:2},{value:"1. Summary",id:"1-summary",level:2},{value:"2. Context &amp; Problem Statement",id:"2-context--problem-statement",level:2},{value:"3. Goals &amp; Non-Goals",id:"3-goals--non-goals",level:2},{value:"4. Stakeholders, Agents &amp; Impacted Surfaces",id:"4-stakeholders-agents--impacted-surfaces",level:2},{value:"5. Current State",id:"5-current-state",level:2},{value:"6. Proposed Solution",id:"6-proposed-solution",level:2},{value:"6.1 Architecture Overview",id:"61-architecture-overview",level:3},{value:"6.2 Detailed Design",id:"62-detailed-design",level:3},{value:"6.3 Operational Considerations",id:"63-operational-considerations",level:3},{value:"7. Work Breakdown &amp; Delivery Plan",id:"7-work-breakdown--delivery-plan",level:2},{value:"7.1 Issue Map",id:"71-issue-map",level:3},{value:"7.2 Milestones",id:"72-milestones",level:3},{value:"7.3 Coordination Notes",id:"73-coordination-notes",level:3},{value:"8. Agent Guidance &amp; Guardrails",id:"8-agent-guidance--guardrails",level:2},{value:"9. Alternatives Considered",id:"9-alternatives-considered",level:2},{value:"10. Testing &amp; Validation Plan",id:"10-testing--validation-plan",level:2},{value:"11. Risks &amp; Mitigations",id:"11-risks--mitigations",level:2},{value:"12. Rollout Plan",id:"12-rollout-plan",level:2},{value:"13. Open Questions",id:"13-open-questions",level:2},{value:"14. Follow-Up Work",id:"14-follow-up-work",level:2},{value:"15. References",id:"15-references",level:2},{value:"Appendix A \u2014 Glossary",id:"appendix-a--glossary",level:2},{value:"Appendix B \u2014 Change Log",id:"appendix-b--change-log",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"renderer-contractwebgpu-include-camera-state-in-rcb-for-replay-correctness-issue-814",children:"renderer-contract/webgpu: include camera state in RCB for replay correctness (Issue 814)"})}),"\n",(0,i.jsx)(n.h2,{id:"document-control",children:"Document Control"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Title"}),": Include world camera state in ",(0,i.jsx)(n.code,{children:"RenderCommandBuffer"})," to make RCB-only visual replay correct and self-contained"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authors"}),": Codex (AI)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reviewers"}),": @hansjm10"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Draft"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Last Updated"}),": 2026-01-24"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Related Issues"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/814",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/814"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Execution Mode"}),": AI-led"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"1-summary",children:"1. Summary"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"RenderCommandBuffer"})," (RCB) is intended to be a self-contained, replayable \u201chow to draw this frame\u201d payload. Today, camera state is held as external renderer instance state (",(0,i.jsx)(n.code,{children:"WebGpuRenderer.setWorldCamera(...)"}),") and is not included in the RCB, which makes RCB-only visual replays non-deterministic/incorrect whenever the camera changes. This design adds camera state to the renderer contract under ",(0,i.jsx)(n.code,{children:"rcb.scene.camera"}),", updates the ViewModel\u2192RCB compiler to copy camera state, updates ",(0,i.jsx)(n.code,{children:"@idle-engine/renderer-webgpu"})," to render using the camera included in the RCB (including world-pass scissor calculations), and bumps the renderer contract schema version to reflect the breaking contract change."]}),"\n",(0,i.jsx)(n.h2,{id:"2-context--problem-statement",children:"2. Context & Problem Statement"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Background"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@idle-engine/renderer-contract"})," defines ",(0,i.jsx)(n.code,{children:"ViewModel"})," (includes ",(0,i.jsx)(n.code,{children:"scene.camera"}),") and ",(0,i.jsx)(n.code,{children:"RenderCommandBuffer"})," (currently: ",(0,i.jsx)(n.code,{children:"frame"}),", ",(0,i.jsx)(n.code,{children:"passes"}),", ",(0,i.jsx)(n.code,{children:"draws"}),"). See ",(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/types.ts"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@idle-engine/renderer-webgpu"})," uses camera state to transform world coordinates for world-pass draws and to compute scissor rectangles. Today that camera lives on the renderer instance (",(0,i.jsx)(n.code,{children:"#worldCamera"}),") and is mutated via ",(0,i.jsx)(n.code,{children:"setWorldCamera(...)"}),". See ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The engine\u2019s replay design (Issue 778) relies on hashing ViewModels/RCBs to validate deterministic replay streams and enable \u201cvisual replay\u201d without rerunning sim. See ",(0,i.jsx)(n.code,{children:"docs/desktop-shell-webgpu-renderer-replay-design-issue-778.md"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Problem"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"RCB-only playback has no authoritative record of the camera transform that was used when the frame was rendered."}),"\n",(0,i.jsxs)(n.li,{children:["As a result, world-pass geometry and scissor/clipping are interpreted using whatever camera state happens to be present (often the default ",(0,i.jsx)(n.code,{children:"{ x: 0, y: 0, zoom: 1 }"}),"), producing incorrect visuals during replay (wrong positions, zoom, and clip regions)."]}),"\n",(0,i.jsxs)(n.li,{children:["Because ",(0,i.jsx)(n.code,{children:"hashRenderCommandBuffer(rcb)"})," only hashes the RCB payload, camera changes are currently invisible to hash comparisons, weakening determinism auditing for visual replays."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Forces"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keep the renderer contract \u201cdata-only\u201d, serializable, and hashable (no implicit external state required to interpret the payload)."}),"\n",(0,i.jsx)(n.li,{children:"Preserve deterministic hashing requirements (reject NaN/Infinity, stable canonicalization)."}),"\n",(0,i.jsx)(n.li,{children:"Treat this as a contract-breaking change and make schema evolution explicit."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"3-goals--non-goals",children:"3. Goals & Non-Goals"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goals"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Make RCB-only replay correct with respect to camera (world transforms and world scissor)."}),"\n",(0,i.jsx)(n.li,{children:"Ensure camera state is included in the hashed RCB payload so replay validation catches camera mismatches."}),"\n",(0,i.jsxs)(n.li,{children:["Keep the contract shape aligned with ",(0,i.jsx)(n.code,{children:"ViewModel"})," where possible (use ",(0,i.jsx)(n.code,{children:"scene.camera"}),")."]}),"\n",(0,i.jsx)(n.li,{children:"Provide clear migration notes and a schema version bump to prevent silent mismatches."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Non-Goals"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Redesign the render pass system (e.g., per-pass transform graphs) beyond what is required to carry a single world camera."}),"\n",(0,i.jsx)(n.li,{children:"Solve pixel-identical rendering across different GPU/driver stacks (goal is deterministic inputs + correct camera interpretation)."}),"\n",(0,i.jsx)(n.li,{children:"Add interpolation/tweening semantics to the contract (if needed, they should be recorded explicitly or derived deterministically)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"4-stakeholders-agents--impacted-surfaces",children:"4. Stakeholders, Agents & Impacted Surfaces"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Primary Stakeholders"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Renderer contract maintainers (",(0,i.jsx)(n.code,{children:"packages/renderer-contract"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["WebGPU renderer maintainers (",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Replay/diagnostics maintainers (",(0,i.jsx)(n.code,{children:"packages/core/src/replay/*"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Host applications consuming RCB streams (e.g., ",(0,i.jsx)(n.code,{children:"packages/shell-desktop"}),", tooling, inspectors)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Agent Roles"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Contract Agent"}),": Update ",(0,i.jsx)(n.code,{children:"RenderCommandBuffer"})," types/schema version and publish migration notes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compiler Agent"}),": Update ",(0,i.jsx)(n.code,{children:"compileViewModelToRenderCommandBuffer(...)"})," to include camera state."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Renderer Agent"}),": Update ",(0,i.jsx)(n.code,{children:"WebGpuRenderer.render(rcb)"})," (and related helpers) to consume ",(0,i.jsx)(n.code,{children:"rcb.scene.camera"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Debug/Validation Agent"}),": Update ",(0,i.jsx)(n.code,{children:"@idle-engine/renderer-debug"})," validation and Canvas2D backend to respect ",(0,i.jsx)(n.code,{children:"rcb.scene.camera"})," (optional but recommended for consistent replay tooling)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Docs Agent"}),": Update READMEs and replay docs/examples to include the new required field."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Affected Packages/Services"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/types.ts"})," (contract change + schema bump)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/render-compiler.ts"})," (copy camera into RCB)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})," (consume camera from RCB; scissor math + globals)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/renderer-debug/src/rcb-validation.ts"})," and ",(0,i.jsx)(n.code,{children:"packages/renderer-debug/src/canvas2d-renderer.ts"})," (optional updates)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"packages/core/src/replay/*"})," (record/replay fixtures and any hard-coded RCBs)"]}),"\n",(0,i.jsxs)(n.li,{children:["Package docs/examples (e.g., ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/README.md"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compatibility Considerations"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This is a breaking renderer-contract change: it requires bumping ",(0,i.jsx)(n.code,{children:"RENDERER_CONTRACT_SCHEMA_VERSION"})," and updating all RCB producers/consumers in-tree."]}),"\n",(0,i.jsx)(n.li,{children:"Previously recorded RCB streams (e.g., replay files) will require migration or must be treated as incompatible and rejected by schema version checks."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"5-current-state",children:"5. Current State"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ViewModel"})," includes ",(0,i.jsx)(n.code,{children:"scene.camera"}),", but ",(0,i.jsx)(n.code,{children:"compileViewModelToRenderCommandBuffer(...)"})," discards it and only emits ",(0,i.jsx)(n.code,{children:"frame/passes/draws"}),". See ",(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/render-compiler.ts"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@idle-engine/renderer-webgpu"})," stores camera on the renderer instance (",(0,i.jsx)(n.code,{children:"#worldCamera"}),") and uses it for:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["world pass scissor conversion (",(0,i.jsx)(n.code,{children:"#toDeviceScissorRect(...)"}),"), and"]}),"\n",(0,i.jsxs)(n.li,{children:["writing world globals uniform (",(0,i.jsx)(n.code,{children:"#writeGlobals(WORLD_GLOBALS_OFFSET, this.#worldCamera)"}),").\nSee ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["RCB hashing is used for replay validation (",(0,i.jsx)(n.code,{children:"hashRenderCommandBuffer(rcb)"}),"), but since camera is not inside RCB, camera-dependent visual differences are not reflected in the RCB hash. See ",(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/hashing.ts"})," and ",(0,i.jsx)(n.code,{children:"packages/core/src/replay/sim-replay.ts"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"6-proposed-solution",children:"6. Proposed Solution"}),"\n",(0,i.jsx)(n.h3,{id:"61-architecture-overview",children:"6.1 Architecture Overview"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Treat camera state as per-frame render input, not renderer instance state."}),"\n",(0,i.jsx)(n.li,{children:"Embed world camera state in the RCB so any consumer (WebGPU renderer, debug renderers, tooling) can render the frame correctly without additional ambient state."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"62-detailed-design",children:"6.2 Detailed Design"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime Changes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Update RCB generation (",(0,i.jsx)(n.code,{children:"compileViewModelToRenderCommandBuffer"}),") to include ",(0,i.jsx)(n.code,{children:"scene.camera"})," from the input ",(0,i.jsx)(n.code,{children:"ViewModel"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Update renderers to read camera from the RCB during ",(0,i.jsx)(n.code,{children:"render(rcb)"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["World scissor conversion uses ",(0,i.jsx)(n.code,{children:"rcb.scene.camera"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["World globals uniform uses ",(0,i.jsx)(n.code,{children:"rcb.scene.camera"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["UI continues to use identity camera ",(0,i.jsx)(n.code,{children:"{ x: 0, y: 0, zoom: 1 }"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data & Schemas"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Update the renderer contract:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Add ",(0,i.jsx)(n.code,{children:"scene: { camera: Camera2D }"})," to ",(0,i.jsx)(n.code,{children:"RenderCommandBuffer"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Bump ",(0,i.jsx)(n.code,{children:"RENDERER_CONTRACT_SCHEMA_VERSION"})," (currently ",(0,i.jsx)(n.code,{children:"3"}),") to the next version (expected: ",(0,i.jsx)(n.code,{children:"4"}),")."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Camera numeric constraints:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"camera.x"}),", ",(0,i.jsx)(n.code,{children:"camera.y"}),", ",(0,i.jsx)(n.code,{children:"camera.zoom"})," must be finite numbers (",(0,i.jsx)(n.code,{children:"hashing.normalizeNumbersForHash"})," already rejects NaN/Infinity)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"camera.zoom"})," should be positive (",(0,i.jsx)(n.code,{children:"> 0"}),") for meaningful transforms; enforce in compiler and/or renderers (exact enforcement location is an implementation detail; see Open Questions)."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"APIs & Contracts"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Keep ",(0,i.jsx)(n.code,{children:"WebGpuRenderer.setWorldCamera(camera)"})," for now, but mark it as deprecated in documentation/JSDoc.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["New invariant: ",(0,i.jsx)(n.code,{children:"render(rcb)"})," uses ",(0,i.jsx)(n.code,{children:"rcb.scene.camera"})," and does not require ",(0,i.jsx)(n.code,{children:"setWorldCamera(...)"})," for correctness."]}),"\n",(0,i.jsxs)(n.li,{children:["Optional transitional behavior (if desired): ",(0,i.jsx)(n.code,{children:"render(rcb)"})," may fall back to the instance camera when ",(0,i.jsx)(n.code,{children:"rcb.scene"})," is missing, but only if we choose to support older schema versions in the renderer. Default expectation is strict schema matching."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tooling & Automation"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Update in-tree fixtures and docs that construct RCB objects manually to include ",(0,i.jsx)(n.code,{children:"scene.camera"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Update replay tooling/docs so recorded RCB frames are self-contained and RCB hashes reflect camera state."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"63-operational-considerations",children:"6.3 Operational Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deployment"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Land contract change + schema bump first, then update all dependents in-tree in the same PR to keep the workspace compiling."}),"\n",(0,i.jsx)(n.li,{children:"Explicitly reject mismatched schema versions at entry points (already present in WebGPU renderer; extend as needed elsewhere)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Telemetry & Observability"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No new telemetry required; schema mismatch errors should be descriptive so hosts can instrument them."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security & Compliance"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Improves replay safety by removing reliance on ambient renderer state for interpreting untrusted RCB streams."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"7-work-breakdown--delivery-plan",children:"7. Work Breakdown & Delivery Plan"}),"\n",(0,i.jsx)(n.h3,{id:"71-issue-map",children:"7.1 Issue Map"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Issue Title"}),(0,i.jsx)(n.th,{children:"Scope Summary"}),(0,i.jsx)(n.th,{children:"Proposed Assignee/Agent"}),(0,i.jsx)(n.th,{children:"Dependencies"}),(0,i.jsx)(n.th,{children:"Acceptance Criteria"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"feat(renderer-contract): add camera to RenderCommandBuffer"})}),(0,i.jsxs)(n.td,{children:["Extend RCB type with ",(0,i.jsx)(n.code,{children:"scene.camera"})," and bump ",(0,i.jsx)(n.code,{children:"RENDERER_CONTRACT_SCHEMA_VERSION"})]}),(0,i.jsx)(n.td,{children:"Contract Agent"}),(0,i.jsx)(n.td,{children:"Design approval"}),(0,i.jsx)(n.td,{children:"Types updated; schema version bumped; migration notes captured in doc/PR"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"feat(renderer-contract): compile camera into RCB"})}),(0,i.jsxs)(n.td,{children:["Update ",(0,i.jsx)(n.code,{children:"compileViewModelToRenderCommandBuffer"})," to copy camera from ViewModel into RCB"]}),(0,i.jsx)(n.td,{children:"Compiler Agent"}),(0,i.jsx)(n.td,{children:"Contract change"}),(0,i.jsx)(n.td,{children:"Unit tests updated/added to assert camera is present and stable for hashing"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"refactor(renderer-webgpu): render using rcb.scene.camera"})}),(0,i.jsxs)(n.td,{children:["Replace instance-state camera usage in world scissor and globals with ",(0,i.jsx)(n.code,{children:"rcb.scene.camera"})]}),(0,i.jsx)(n.td,{children:"Renderer Agent"}),(0,i.jsx)(n.td,{children:"Contract change"}),(0,i.jsxs)(n.td,{children:["Existing scissor/camera tests updated; RCB-only render path correct without calling ",(0,i.jsx)(n.code,{children:"setWorldCamera"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"chore(renderer-debug): respect RCB camera"})}),(0,i.jsxs)(n.td,{children:["Update ",(0,i.jsx)(n.code,{children:"renderRenderCommandBufferToCanvas2d"})," and validation to apply world camera for parity with WebGPU"]}),(0,i.jsx)(n.td,{children:"Debug/Validation Agent"}),(0,i.jsx)(n.td,{children:"Contract change"}),(0,i.jsx)(n.td,{children:"Canvas2D output matches WebGPU camera interpretation for the same RCB; tests updated"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"docs(renderer-webgpu/replay): update examples + migration notes"})}),(0,i.jsxs)(n.td,{children:["Update README examples and replay docs to include ",(0,i.jsx)(n.code,{children:"scene.camera"})]}),(0,i.jsx)(n.td,{children:"Docs Agent"}),(0,i.jsx)(n.td,{children:"Contract + implementation"}),(0,i.jsx)(n.td,{children:"Examples compile; docs explain schema bump and required field"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"72-milestones",children:"7.2 Milestones"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 1"}),": Contract change + schema bump + compiler update (workspace compiles)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 2"}),": WebGPU renderer update + tests (RCB-only replay correctness)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 3"}),": Debug tooling parity + docs/migration updates."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"73-coordination-notes",children:"7.3 Coordination Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hand-off Package"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Contract types: ",(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/types.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Compiler: ",(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/render-compiler.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["WebGPU renderer: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Existing scissor/camera tests: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Replay hashing: ",(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/hashing.ts"}),", ",(0,i.jsx)(n.code,{children:"packages/core/src/replay/sim-replay.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Prior replay design: ",(0,i.jsx)(n.code,{children:"docs/desktop-shell-webgpu-renderer-replay-design-issue-778.md"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Communication Cadence"}),": Single reviewer pass after implementation + tests, with a follow-up doc pass for migration notes if schema bump impacts existing replay artifacts."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"8-agent-guidance--guardrails",children:"8. Agent Guidance & Guardrails"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Context Packets"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Load Issue 814 body for acceptance criteria and file references."}),"\n",(0,i.jsx)(n.li,{children:"Review how camera is used today in WebGPU scissor/global uniforms."}),"\n",(0,i.jsxs)(n.li,{children:["Identify any in-tree RCB fixtures/examples that will break when ",(0,i.jsx)(n.code,{children:"scene.camera"})," becomes required."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prompting & Constraints"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Do not edit checked-in ",(0,i.jsx)(n.code,{children:"dist/"})," outputs by hand."]}),"\n",(0,i.jsxs)(n.li,{children:["Use type-only imports/exports (",(0,i.jsx)(n.code,{children:"import type { ... }"}),") per workspace lint rules."]}),"\n",(0,i.jsx)(n.li,{children:"Keep renderer-contract changes minimal and data-only; avoid adding runtime dependencies for validation."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety Rails"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prefer fail-fast behavior on schema mismatch; do not silently assume default camera during replay."}),"\n",(0,i.jsx)(n.li,{children:"Ensure hashing behavior remains deterministic (no NaN/Infinity; stable key ordering)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation Hooks"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pnpm test --filter @idle-engine/renderer-contract"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pnpm test --filter @idle-engine/renderer-webgpu"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"pnpm test --filter @idle-engine/renderer-debug"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pnpm test --filter @idle-engine/core"})," (visual replay tests)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"9-alternatives-considered",children:"9. Alternatives Considered"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Keep camera external (require ",(0,i.jsx)(n.code,{children:"setWorldCamera"})," during replay)"]}),": Rejected; violates the \u201cRCB is self-contained\u201d goal and makes RCB-only replay correctness dependent on caller behavior."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Store camera in ",(0,i.jsx)(n.code,{children:"FrameHeader"})]}),": Simpler shape but semantically mixes \u201cframe identity\u201d and \u201crender state\u201d; also less aligned with ",(0,i.jsx)(n.code,{children:"ViewModel.scene"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Attach camera per pass (",(0,i.jsx)(n.code,{children:"RenderPass"})," carries transform)"]}),": More extensible (multiple cameras/passes), but heavier change than needed for Issue 814 and requires larger refactors across compilers/renderers."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Record camera as a draw command (e.g., ",(0,i.jsx)(n.code,{children:"kind: 'setCamera'"}),")"]}),": Keeps ",(0,i.jsx)(n.code,{children:"RenderCommandBuffer"})," flat but complicates ordering rules and makes camera an implicit state machine again; rejected in favor of explicit ",(0,i.jsx)(n.code,{children:"scene"})," metadata."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"10-testing--validation-plan",children:"10. Testing & Validation Plan"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unit / Integration"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Update renderer-contract compiler tests to assert ",(0,i.jsx)(n.code,{children:"compileViewModelToRenderCommandBuffer(viewModel).scene.camera"})," equals the input camera."]}),"\n",(0,i.jsx)(n.li,{children:"Add/adjust hashing tests to confirm that RCB hashes differ when camera differs (even if draws are identical)."}),"\n",(0,i.jsxs)(n.li,{children:["Update WebGPU renderer tests to remove reliance on ",(0,i.jsx)(n.code,{children:"renderer.setWorldCamera(...)"})," and instead supply camera via the RCB; ensure scissor conversion matches expected device pixels."]}),"\n",(0,i.jsxs)(n.li,{children:["Update any replay fixtures/tests that construct RCBs (in ",(0,i.jsx)(n.code,{children:"packages/core/src/replay/*.test.ts"}),") to include ",(0,i.jsx)(n.code,{children:"scene.camera"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Camera adds a tiny constant payload per frame (3 numbers); no measurable perf impact expected."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tooling / A11y"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Manual sanity check in a host (Electron/web) by capturing an RCB stream with camera movement and replaying it without any external camera calls."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"11-risks--mitigations",children:"11. Risks & Mitigations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Breaking change ripple"}),": Many fixtures/examples create RCB objects manually and will fail to compile until updated.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Mitigation"}),": Land schema bump + in-tree updates in one PR; include a checklist of touched packages."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Camera float nondeterminism"}),": If camera is computed using non-deterministic timing (vsync interpolation), hashes may differ between runs.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Mitigation"}),": Define where camera comes from for \u201cdeterministic replay\u201d mode (derive from sim time or record camera explicitly and treat it as non-authoritative)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Partial adoption"}),": Some renderers/tooling might ignore camera and remain incorrect.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Mitigation"}),": Update ",(0,i.jsx)(n.code,{children:"@idle-engine/renderer-debug"})," as part of the rollout or explicitly document its limitations."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"12-rollout-plan",children:"12. Rollout Plan"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Milestones"}),":","\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Bump schema version and update contract/compiler (RCB includes camera)."}),"\n",(0,i.jsx)(n.li,{children:"Update WebGPU renderer to consume camera from RCB and update tests."}),"\n",(0,i.jsx)(n.li,{children:"Update docs/examples and (optionally) debug tooling parity."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Migration Strategy"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Treat pre-bump RCB streams as incompatible and reject them via schema checks."}),"\n",(0,i.jsx)(n.li,{children:"If legacy replay support is required, add an explicit migration step that injects a default camera or reconstructs camera from recorded host input (out of scope for this issue; see Open Questions)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Communication"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Include migration notes in PR description:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RenderCommandBuffer"})," now requires ",(0,i.jsx)(n.code,{children:"scene.camera"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RENDERER_CONTRACT_SCHEMA_VERSION"})," bumped; old replays must be regenerated or migrated."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"13-open-questions",children:"13. Open Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Should ",(0,i.jsx)(n.code,{children:"camera.zoom"})," be validated as ",(0,i.jsx)(n.code,{children:"> 0"})," at the contract boundary (compiler/renderer), or left to downstream renderers to interpret?"]}),"\n",(0,i.jsxs)(n.li,{children:["Should ",(0,i.jsx)(n.code,{children:"WebGpuRenderer.setWorldCamera(...)"})," be removed (breaking API), formally deprecated, or retained as an override for ad-hoc/manual rendering?"]}),"\n",(0,i.jsxs)(n.li,{children:["Do we want per-pass camera transforms soon (making ",(0,i.jsx)(n.code,{children:"RenderPass"})," carry a transform), or is a single ",(0,i.jsx)(n.code,{children:"rcb.scene.camera"})," sufficient for the foreseeable roadmap?"]}),"\n",(0,i.jsxs)(n.li,{children:["Do replay file formats need an explicit \u201cRCB schema version\u201d field separate from ",(0,i.jsx)(n.code,{children:"FrameHeader.schemaVersion"}),", or is the existing schema version sufficient?"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"14-follow-up-work",children:"14. Follow-Up Work"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Expand \u201cRCB is self-contained\u201d to other renderer state currently implicit (e.g., viewport assumptions, devicePixelRatio semantics), if replay correctness requires it."}),"\n",(0,i.jsx)(n.li,{children:"Consider a small migration utility for replay files when contract schema versions change."}),"\n",(0,i.jsx)(n.li,{children:"Consider adding optional quantization rules for camera (fixed-point) if camera hashing proves too sensitive for deterministic validation workflows."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"15-references",children:"15. References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Issue 814: ",(0,i.jsx)(n.a,{href:"https://github.com/hansjm10/Idle-Game-Engine/issues/814",children:"https://github.com/hansjm10/Idle-Game-Engine/issues/814"})]}),"\n",(0,i.jsxs)(n.li,{children:["Renderer contract types: ",(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/types.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["ViewModel\u2192RCB compiler: ",(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/render-compiler.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["WebGPU renderer implementation: ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["WebGPU renderer tests (camera/scissor): ",(0,i.jsx)(n.code,{children:"packages/renderer-webgpu/src/webgpu-renderer.test.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Replay hashing: ",(0,i.jsx)(n.code,{children:"packages/renderer-contract/src/hashing.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Replay validation logic: ",(0,i.jsx)(n.code,{children:"packages/core/src/replay/sim-replay.ts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Prior replay design doc (Issue 778): ",(0,i.jsx)(n.code,{children:"docs/desktop-shell-webgpu-renderer-replay-design-issue-778.md"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"appendix-a--glossary",children:"Appendix A \u2014 Glossary"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"RCB (RenderCommandBuffer)"}),": A per-frame, data-only rendering payload describing passes and ordered draws for a renderer backend."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ViewModel"}),": A higher-level per-frame description (scene + UI) that is compiled into an RCB."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Camera2D"}),": The world camera transform ",(0,i.jsx)(n.code,{children:"{ x, y, zoom }"})," used to map world coordinates into device/pixel space."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"appendix-b--change-log",children:"Appendix B \u2014 Change Log"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Date"}),(0,i.jsx)(n.th,{children:"Author"}),(0,i.jsx)(n.th,{children:"Change Summary"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2026-01-24"}),(0,i.jsx)(n.td,{children:"Codex (AI)"}),(0,i.jsx)(n.td,{children:"Initial draft for Issue 814"})]})})]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},7678:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>l});var s=r(9430);const i={},d=s.createContext(i);function c(e){const n=s.useContext(d);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(d.Provider,{value:n},e.children)}}}]);