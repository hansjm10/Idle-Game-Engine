#!/usr/bin/env node

/**
 * Generates version.ts from package.json to ensure version synchronization.
 *
 * This script auto-generates the RUNTIME_VERSION constant from the
 * @idle-engine/core package.json version, while preserving the manually-managed
 * PERSISTENCE_SCHEMA_VERSION constant.
 *
 * Modes:
 * - Default: Generate version.ts from package.json
 * - --check: Validate that version.ts is up-to-date (exits 1 if stale)
 *
 * Exit codes:
 * - 0: Success (generation complete or file up-to-date)
 * - 1: Error (generation failed or file is stale in --check mode)
 */

import { readFile, rename, rm, writeFile } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
import { basename, dirname, join } from 'node:path';

const __dirname = dirname(fileURLToPath(import.meta.url));
const projectRoot = join(__dirname, '../..');

const CHECK_MODE = process.argv.includes('--check');

async function writeFileIfChangedAtomic(filePath, nextContent) {
  try {
    const currentContent = await readFile(filePath, 'utf-8');
    if (currentContent === nextContent) {
      return { wrote: false };
    }
  } catch (error) {
    if (error.code !== 'ENOENT') {
      throw error;
    }
  }

  const dirPath = dirname(filePath);
  const tempPath = join(
    dirPath,
    `.${basename(filePath)}.${process.pid}.${Date.now()}.tmp`,
  );

  await writeFile(tempPath, nextContent, 'utf-8');

  try {
    await rename(tempPath, filePath);
  } catch (error) {
    if (error.code === 'EEXIST' || error.code === 'EPERM') {
      await rm(filePath, { force: true });
      await rename(tempPath, filePath);
    } else {
      throw error;
    }
  } finally {
    await rm(tempPath, { force: true });
  }

  return { wrote: true };
}

async function generateVersionFile() {
  try {
    // Read package.json version
    const packageJsonPath = join(projectRoot, 'packages/core/package.json');
    const packageJsonContent = await readFile(packageJsonPath, 'utf-8');
    const packageJson = JSON.parse(packageJsonContent);
    const packageVersion = packageJson.version;

    if (!packageVersion) {
      console.error('❌ Error: Could not find version in packages/core/package.json');
      process.exit(1);
    }

    // Validate semver format
    if (!/^\d+\.\d+\.\d+$/.test(packageVersion)) {
      console.error('❌ Error: Invalid semver format in package.json version:', packageVersion);
      console.error('   Expected format: x.y.z (e.g., 0.1.0)');
      process.exit(1);
    }

    // Read current version.ts to extract PERSISTENCE_SCHEMA_VERSION
    const versionTsPath = join(projectRoot, 'packages/core/src/version.ts');
    let persistenceSchemaVersion = 1; // Default value

    try {
      const currentContent = await readFile(versionTsPath, 'utf-8');
      const persistenceMatch = currentContent.match(
        /export\s+const\s+PERSISTENCE_SCHEMA_VERSION\s*=\s*(\d+)/
      );
      if (persistenceMatch) {
        persistenceSchemaVersion = parseInt(persistenceMatch[1], 10);
      }
    } catch (error) {
      // File doesn't exist yet or can't be read - use default value
      console.warn('⚠️  Warning: Could not read existing version.ts, using default PERSISTENCE_SCHEMA_VERSION=1');
    }

    // Generate the new file content
    const generatedContent = `/* @generated */
// This file was auto-generated by tools/scripts/generate-version.mjs
// Do not edit this file directly.
//
// RUNTIME_VERSION is synchronized with packages/core/package.json version.
// To update PERSISTENCE_SCHEMA_VERSION, edit this file and run the generator.

/**
 * Runtime version constants
 *
 * These constants are used for serialization boundaries, persistence schemas,
 * and compatibility checks across the Idle Engine runtime.
 */

/**
 * Runtime semantic version.
 *
 * Corresponds to the @idle-engine/core package version. Used for:
 * - Session snapshot compatibility validation
 * - Runtime migration detection
 * - Telemetry and diagnostics correlation
 *
 * AUTO-GENERATED: This value is synchronized with packages/core/package.json.
 * Do not edit manually - run \`pnpm generate:version\` to regenerate.
 */
export const RUNTIME_VERSION = '${packageVersion}';

/**
 * Persistence schema version for session snapshots.
 *
 * Increment when the structure of session snapshot payloads changes in a
 * backwards-incompatible way. Used for:
 * - Triggering migration logic when restoring old saves
 * - Validating snapshot payload structure
 * - Coordinating with SessionPersistenceAdapter implementations
 *
 * MANUALLY MANAGED: Update this constant in version.ts before running the generator.
 * The generator preserves this value across regenerations.
 *
 * Current schema (v${persistenceSchemaVersion}):
 * - persistenceSchemaVersion: ${persistenceSchemaVersion}
 * - slotId: string
 * - capturedAt: ISO timestamp
 * - workerStep: number
 * - monotonicMs: number
 * - state: SerializedResourceState
 * - runtimeVersion: string
 * - contentDigest: ResourceDefinitionDigest
 * - flags?: { pendingMigration?, abortedRestore? }
 */
export const PERSISTENCE_SCHEMA_VERSION = ${persistenceSchemaVersion};
`;

    // In check mode, verify the file is up-to-date
    if (CHECK_MODE) {
      try {
        const currentContent = await readFile(versionTsPath, 'utf-8');
        if (currentContent === generatedContent) {
          console.log('✅ version.ts is up-to-date');
          console.log(`   RUNTIME_VERSION: ${packageVersion}`);
          console.log(`   PERSISTENCE_SCHEMA_VERSION: ${persistenceSchemaVersion}`);
          process.exit(0);
        } else {
          console.error('❌ version.ts is stale or manually edited!');
          console.error('');
          console.error('   The file does not match the expected generated output.');
          console.error('');
          console.error('   To fix:');
          console.error('   1. Run: pnpm generate:version');
          console.error('   2. Commit the regenerated file');
          console.error('');
          console.error('   If you need to update PERSISTENCE_SCHEMA_VERSION:');
          console.error('   1. Edit packages/core/src/version.ts');
          console.error('   2. Update the PERSISTENCE_SCHEMA_VERSION constant');
          console.error('   3. Run: pnpm generate:version');
          console.error('   4. Update tests in packages/core/src/version.test.ts');
          console.error('');
          process.exit(1);
        }
      } catch (error) {
        console.error('❌ Error: version.ts does not exist');
        console.error('   Run: pnpm generate:version');
        process.exit(1);
      }
    }

    // Write the generated file
    const result = await writeFileIfChangedAtomic(versionTsPath, generatedContent);

    console.log(
      result.wrote
        ? '✅ Generated version.ts successfully'
        : '✅ version.ts already up-to-date',
    );
    console.log(`   RUNTIME_VERSION: ${packageVersion}`);
    console.log(`   PERSISTENCE_SCHEMA_VERSION: ${persistenceSchemaVersion}`);
    process.exit(0);

  } catch (error) {
    console.error('❌ Error during version generation:', error.message);
    if (error.stack) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}

generateVersionFile();
